<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Alpha Hunter</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 40'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2300d4aa'/%3E%3Cstop offset='100%25' stop-color='%237c3aed'/%3E%3C/linearGradient%3E%3C/defs%3E%3Ccircle cx='20' cy='20' r='14' fill='none' stroke='url(%23g)' stroke-width='2.5'/%3E%3Ccircle cx='20' cy='20' r='3' fill='%2300d4aa'/%3E%3Cline x1='20' y1='2' x2='20' y2='10' stroke='url(%23g)' stroke-width='2' stroke-linecap='round'/%3E%3Cline x1='20' y1='30' x2='20' y2='38' stroke='url(%23g)' stroke-width='2' stroke-linecap='round'/%3E%3Cline x1='2' y1='20' x2='10' y2='20' stroke='url(%23g)' stroke-width='2' stroke-linecap='round'/%3E%3Cline x1='30' y1='20' x2='38' y2='20' stroke='url(%23g)' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E">
<style>

    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');

    /* ===== PREMIUM WHITE THEME ===== */
    :root {
      --white: #ffffff;
      --bg: #f8f9fb;
      --card-bg: #ffffff;
      --border: #e5e7eb;
      --border-light: #f1f3f5;
      --text-primary: #1a1a2e;
      --text-secondary: #6b7280;
      --text-muted: #9ca3af;
      --accent: #00d4aa;
      --accent-light: #ecfdf8;
      --accent-hover: #00b896;
      --green: #10b981;
      --green-light: #ecfdf5;
      --red: #ef4444;
      --red-light: #fef2f2;
      --orange: #f59e0b;
      --orange-light: #fffbeb;
      --purple: #7c3aed;
      --purple-light: #f5f3ff;
      --shadow-xs: 0 1px 2px rgba(0,0,0,0.03);
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.04), 0 1px 2px rgba(0,0,0,0.02);
      --shadow-md: 0 4px 12px rgba(0,0,0,0.05), 0 1px 3px rgba(0,0,0,0.03);
      --shadow-lg: 0 8px 30px rgba(0,0,0,0.07), 0 2px 8px rgba(0,0,0,0.04);
      --radius: 12px;
      --radius-sm: 8px;
      --radius-lg: 16px;
      --radius-xl: 20px;
    }

    /* ===== DARK MODE ===== */
    [data-theme="dark"] {
      --white: #1a1a2e; --bg: #0f0f1a; --card-bg: #1a1a2e; --border: #2d2d44; --border-light: #252540;
      --text-primary: #e2e8f0; --text-secondary: #94a3b8; --text-muted: #64748b;
      --accent: #00d4aa; --accent-light: #0d3d33; --accent-hover: #00e8bb;
      --green: #10b981; --green-light: #0d3d33;
      --red: #ef4444; --red-light: #3b1111;
      --orange: #f59e0b; --orange-light: #3b2e0a;
      --purple: #8b5cf6; --purple-light: #2e1f5e;
      --shadow-xs: 0 1px 2px rgba(0,0,0,0.2);
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.3); --shadow-md: 0 4px 12px rgba(0,0,0,0.35); --shadow-lg: 0 8px 30px rgba(0,0,0,0.45);
    }
    [data-theme="dark"] .header { background: #1a1a2e; border-bottom-color: #2d2d44; }
    [data-theme="dark"] .game-card-header { background: #151525; }
    [data-theme="dark"] .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
    [data-theme="dark"] input, [data-theme="dark"] select, [data-theme="dark"] textarea { background: #252540; color: #e2e8f0; border-color: #2d2d44; }
    [data-theme="dark"] .modal { background: #1a1a2e; }
    [data-theme="dark"] .edge-box { background: #151525; border-color: #2d2d44; }
    [data-theme="dark"] .signal-strip { background: #1a1a2e; border-color: #2d2d44; }
    [data-theme="dark"] .tab-bar { background: #1a1a2e; border-bottom-color: #2d2d44; }
    [data-theme="dark"] .odds-row { background: linear-gradient(135deg,#1a1a2e,#16213e); }
    [data-theme="dark"] .header-controls { background: rgba(255,255,255,0.04); border-color: #2d2d44; }
    [data-theme="dark"] .stat-card { border-color: #2d2d44; }
    [data-theme="dark"] .stat-card:hover { border-color: var(--accent); }

    /* ===== RESET & BASE ===== */
    .team-3pt-avg { font-size: 9px; font-weight: 600; color: var(--accent); opacity: 0.8; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text-primary);
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      letter-spacing: -0.01em;
    }

    /* ===== HEADER ===== */
    .header {
      background: var(--white);
      border-bottom: 1px solid var(--border);
      padding: 16px 32px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 200;
      min-height: 64px;
    }
    .header h1, .header .title { font-size: 18px; font-weight: 800; color: var(--accent); letter-spacing: -0.3px; }
    .header .subtitle, .header p, .header small { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
    .logo-wrap { display: flex; align-items: center; gap: 14px; }
    .logo-icon { width: 36px; height: 36px; flex-shrink: 0; filter: drop-shadow(0 0 8px rgba(0,212,170,0.3)); }
    .logo-icon .scope-ring { fill: none; stroke: url(#logoGrad); stroke-width: 2; }
    .logo-icon .scope-cross { stroke: url(#logoGrad); stroke-width: 1.5; stroke-linecap: round; }
    .logo-icon .scope-dot { fill: var(--accent); }
    .logo-icon .scope-pulse { fill: var(--accent); opacity: 0; animation: logoPulse 2.5s ease-in-out infinite; }
    @keyframes logoPulse { 0%,100%{ opacity:0; r:2; } 50%{ opacity:0.4; r:7; } }
    .logo-text { display: flex; flex-direction: column; line-height: 1.15; }
    .logo-text .logo-main { font-size: 19px; font-weight: 900; letter-spacing: 2px; background: linear-gradient(135deg, #00d4aa 0%, #00b4d8 50%, #7c3aed 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .logo-text .logo-sub { font-size: 9px; font-weight: 600; letter-spacing: 3.5px; color: var(--text-muted); text-transform: uppercase; margin-top: 2px; }
    [data-theme="dark"] .logo-icon { filter: drop-shadow(0 0 10px rgba(0,212,170,0.5)); }
    [data-theme="dark"] .logo-text .logo-main { background: linear-gradient(135deg, #00ffc8 0%, #00d4ff 50%, #a78bfa 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }

    /* Header controls group */
    .header-right, .header-actions, .header .actions { display: flex; gap: 8px; align-items: center; }
    .header-controls {
      display: flex;
      gap: 6px;
      align-items: center;
      background: var(--bg);
      border: 1px solid var(--border-light);
      border-radius: 28px;
      padding: 4px 6px;
    }

    /* ===== BUTTONS ===== */
    button, .btn {
      font-family: 'Inter', sans-serif;
      font-size: 13px;
      font-weight: 600;
      border: none;
      border-radius: var(--radius-sm);
      padding: 8px 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      letter-spacing: -0.01em;
    }
    button:hover { transform: translateY(-1px); box-shadow: var(--shadow-md); }
    button:active { transform: translateY(0); }
    .btn-primary, button[style*="background: #00d4aa"], button[style*="background:#00d4aa"] { background: var(--accent) !important; color: white !important; }
    .btn-danger, button[style*="background: #ef4444"] { background: var(--red) !important; color: white !important; }
    .espn-btn, button[onclick*="espn"] { background: var(--white); color: var(--text-secondary); border: 1px solid var(--border); font-size: 12px; padding: 6px 14px; border-radius: var(--radius-sm); }
    .espn-btn:hover, button[onclick*="espn"]:hover { background: var(--bg); border-color: var(--accent); color: var(--accent); }
    #soundToggle { background: var(--accent) !important; color: white !important; border-radius: 24px !important; padding: 6px 14px !important; font-size: 11px !important; font-weight: 600 !important; }
    #demoToggle { background: var(--accent) !important; color: white !important; border-radius: 24px !important; padding: 6px 14px !important; font-size: 11px !important; font-weight: 600 !important; }
    #modeToggleBtn { border-radius: 24px !important; font-size: 12px !important; font-weight: 700 !important; padding: 7px 18px !important; letter-spacing: 0.5px !important; }
    #darkModeToggle { background: var(--bg) !important; color: var(--text-secondary) !important; border: 1px solid var(--border) !important; border-radius: 24px !important; padding: 6px 14px !important; font-size: 11px !important; font-weight: 600 !important; }
    #darkModeToggle:hover { background: var(--border-light) !important; color: var(--text-primary) !important; }

    /* Status indicators */
    .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
    .status-dot.green, .status-dot.live { background: var(--green); box-shadow: 0 0 6px rgba(16,185,129,0.4); }
    .status-dot.red, .status-dot.off { background: var(--red); }

    /* ===== TAB BAR ===== */
    .tab-bar {
      display: flex;
      background: var(--white);
      border-bottom: 1px solid var(--border);
      padding: 0 32px;
      position: sticky;
      top: 64px;
      z-index: 100;
      gap: 0;
      overflow-x: auto;
      scrollbar-width: none;
    }
    .tab-bar::-webkit-scrollbar { display: none; }
    .tab {
      padding: 14px 22px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-muted);
      border-bottom: 2px solid transparent;
      transition: all 0.2s ease;
      white-space: nowrap;
      position: relative;
    }
    .tab:hover { color: var(--text-primary); }
    .tab.active {
      color: var(--accent);
      font-weight: 700;
      border-bottom: 2.5px solid var(--accent);
      margin-bottom: -1px;
    }
    .tab .badge {
      font-size: 10px;
      padding: 1px 7px;
      border-radius: 10px;
      margin-left: 4px;
      vertical-align: middle;
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* ===== CONTENT AREA ===== */
    .content, .main-content, .tab-content { padding: 28px 32px; max-width: 1440px; margin: 0 auto; }

    /* ===== TYPOGRAPHY ===== */
    h2, .section-title { font-size: 20px; font-weight: 800; color: var(--text-primary); letter-spacing: -0.4px; margin-bottom: 4px; }
    h3, h4 { font-size: 15px; font-weight: 700; color: var(--text-primary); letter-spacing: -0.2px; }

    /* ===== STATS ROW (KPI TILES) ===== */
    .stats-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px; margin-bottom: 28px; }
    .stat-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px 18px;
      text-align: center;
      box-shadow: var(--shadow-xs);
      transition: all 0.25s ease;
      position: relative;
      overflow: hidden;
    }
    .stat-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--accent);
      opacity: 0;
      transition: opacity 0.25s ease;
    }
    .stat-card:hover { box-shadow: var(--shadow-md); transform: translateY(-2px); border-color: var(--accent); }
    .stat-card:hover::before { opacity: 1; }
    .stat-label {
      font-size: 10px;
      font-weight: 700;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1.2px;
      margin-bottom: 8px;
    }
    .stat-value { font-size: 30px; font-weight: 800; color: var(--text-primary); letter-spacing: -1.5px; line-height: 1.1; }
    .stat-value.red { color: var(--red); }
    .stat-value.orange { color: var(--orange); }
    .stat-value.green { color: var(--green); }
    .stat-value.purple { color: var(--purple); }

    /* ===== SIGNAL STRIP ===== */
    .signal-strip {
      display: flex;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: visible;
      background: var(--card-bg);
      box-shadow: var(--shadow-xs);
      margin-bottom: 24px;
    }
    .signal-chip {
      flex: 1;
      padding: 14px 8px;
      text-align: center;
      border-right: 1px solid var(--border-light);
      transition: all 0.2s ease;
      cursor: default;
      position: relative;
    }
    .signal-chip:last-child { border-right: none; }
    .signal-chip:hover { background: var(--bg); }
    .signal-chip .chip-value { font-size: 22px; font-weight: 800; color: var(--text-primary); letter-spacing: -0.5px; line-height: 1.2; }
    .signal-chip .chip-label { font-size: 9px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-top: 4px; }
    .signal-chip .chip-value.orange { color: var(--orange); }
    .signal-chip .chip-value.teal { color: var(--green); }
    .signal-chip .chip-value.red { color: var(--red); }
    .signal-chip .chip-value.purple { color: var(--purple); }
    .signal-chip .chip-value.green { color: var(--green); }
    .signal-chip .chip-label.orange { color: var(--orange); }
    .signal-chip .chip-label.teal { color: var(--green); }
    .signal-chip .chip-label.red { color: var(--red); }
    .signal-chip .chip-label.purple { color: var(--purple); }
    .signal-chip .chip-label.green { color: var(--green); }
    .signal-chip .chip-desc { display:none; position:absolute; bottom:100%; left:50%; transform:translateX(-50%); background:#1e293b; color:#fff; font-size:10px; padding:6px 10px; border-radius:6px; white-space:nowrap; z-index:100; pointer-events:none; margin-bottom:6px; box-shadow:0 4px 12px rgba(0,0,0,.15); }
    .signal-chip:hover .chip-desc { display:block; }
    .signal-chip-clickable { cursor: pointer; transition: all 0.2s ease; border-radius: 0; }
    .signal-chip-clickable:hover { background: var(--accent-light); }
    .signal-chip-clickable:active { transform: scale(0.98); }

    /* Chip detail dropdown */
    .chip-detail-panel { display:none; position:absolute; top:100%; left:50%; transform:translateX(-50%); background:var(--card-bg); border:1px solid var(--border); border-radius:var(--radius); box-shadow:var(--shadow-lg); z-index:150; min-width:300px; max-width:380px; padding:0; margin-top:8px; text-align:left; overflow:hidden; animation:slideUp 0.2s ease; }
    .chip-detail-panel.active { display:block; }
    .chip-detail-panel::before { content:''; position:absolute; top:-6px; left:50%; transform:translateX(-50%); border-left:6px solid transparent; border-right:6px solid transparent; border-bottom:6px solid var(--border); }
    .chip-detail-panel::after { content:''; position:absolute; top:-5px; left:50%; transform:translateX(-50%); border-left:5px solid transparent; border-right:5px solid transparent; border-bottom:5px solid var(--card-bg); }
    .chip-detail-header { padding:10px 14px; background:var(--bg); border-bottom:1px solid var(--border-light); font-size:11px; font-weight:700; color:var(--text-muted); text-transform:uppercase; letter-spacing:0.5px; }
    .chip-detail-item { padding:10px 14px; border-bottom:1px solid var(--border-light); font-size:12px; }
    .chip-detail-item:last-child { border-bottom:none; }
    .chip-detail-clickable { cursor:pointer; transition:background 0.15s ease; }
    .chip-detail-clickable:hover { background:var(--accent-light); }
    .chip-detail-game { font-weight:700; color:var(--text-primary); font-size:12px; }
    .chip-detail-score { font-size:11px; color:var(--text-muted); margin-top:2px; }
    .chip-detail-sig { font-size:11px; color:var(--text-secondary); margin-top:4px; line-height:1.5; }
    .chip-detail-empty { padding:16px; text-align:center; font-size:11px; color:var(--text-muted); }

    @keyframes signalFlash { 0%{box-shadow:0 0 0 0 rgba(0,212,170,0.5);} 30%{box-shadow:0 0 16px 4px rgba(0,212,170,0.3);} 100%{box-shadow:var(--shadow-sm);} }
    .signal-highlight-flash { animation:signalFlash 2.5s ease; border-color:var(--accent) !important; }

    /* ===== DIVIDERS ===== */
    .section-divider { height: 1px; background: var(--border-light); margin: 20px 0; }

    /* ===== EDGE THESIS ===== */
    .edge-thesis-header { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
    .edge-thesis-header h2 { font-size: 13px; font-weight: 700; color: var(--text-primary); letter-spacing: 1px; text-transform: uppercase; margin: 0; }
    .edge-count-badge, .thesis-count { background: var(--accent); color: white; font-size: 11px; font-weight: 700; padding: 3px 12px; border-radius: 20px; min-width: 24px; text-align: center; }

    /* ===== AUTO REFRESH BAR ===== */
    .auto-refresh-bar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 0;
      font-size: 12px;
      color: var(--text-secondary);
      flex-wrap: wrap;
    }
    .refresh-pill { padding: 5px 14px; font-size: 11px; font-weight: 700; border-radius: 20px; border: 1px solid var(--accent); color: var(--accent); background: transparent; cursor: pointer; transition: all 0.2s; }
    .refresh-pill:hover { background: var(--accent); color: white; }
    .countdown-bar { flex: 0 0 120px; height: 3px; background: var(--border-light); border-radius: 2px; overflow: hidden; }
    .countdown-fill { height: 100%; background: var(--accent); border-radius: 2px; transition: width 1s linear; }

    /* ===== CARDS ===== */
    .card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 22px;
      box-shadow: var(--shadow-xs);
      margin-bottom: 20px;
      transition: all 0.25s ease;
    }
    .card:hover { box-shadow: var(--shadow-sm); }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 14px;
      font-weight: 700;
      font-size: 15px;
      color: var(--text-primary);
      letter-spacing: -0.2px;
    }
    .card-body { font-size: 13px; color: var(--text-secondary); line-height: 1.7; }

    /* ===== GAME CARDS ===== */
    .games-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 16px; }
    .game-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      transition: all 0.25s ease;
    }
    .game-card:hover { box-shadow: var(--shadow-md); border-color: #d1d5db; }
    .game-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      background: var(--bg);
      border-bottom: 1px solid var(--border-light);
      font-size: 11px;
      color: var(--text-muted);
      font-weight: 600;
      letter-spacing: .3px;
    }
    .game-card-body { padding: 14px 16px; }
    .game-teams { display: flex; align-items: center; justify-content: space-between; gap: 4px; }
    .team-block { text-align: center; flex: 1; min-width: 0; }
    .team-block strong, .team-block b { display: block; font-size: 15px; font-weight: 700; color: var(--text-primary); margin-bottom: 1px; }
    .team-block small { font-size: 11px; color: var(--text-muted); }
    .team-name { font-size: 15px; font-weight: 800; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 160px; margin: 0 auto; letter-spacing: -0.3px; display: flex; align-items: center; justify-content: center; gap: 5px; }
    .team-name img { flex-shrink: 0; }
    .watch-link { display: inline-flex; align-items: center; gap: 3px; font-size: 9px; font-weight: 600; color: var(--accent); background: var(--accent-light); padding: 2px 7px; border-radius: 3px; text-decoration: none; letter-spacing: 0.3px; transition: opacity 0.15s; }
    .watch-link:hover { opacity: 0.7; }
    .game-links { display: flex; justify-content: center; gap: 6px; flex-wrap: wrap; margin-top: 4px; }
    .tp-inline { cursor: pointer; }
    .tp-inline:hover { text-decoration: underline; }
    .tp-modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,.35); z-index: 1000; justify-content: center; align-items: center; }
    .tp-modal-overlay.active { display: flex; }
    .tp-modal { background: var(--card-bg); border: 1px solid var(--border); border-radius: 12px; padding: 20px 24px; box-shadow: 0 12px 40px rgba(0,0,0,.2); min-width: 280px; max-width: 340px; animation: slideUp 0.2s ease; }
    .tp-modal-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
    .tp-modal-header h3 { font-size: 16px; font-weight: 800; margin: 0; display: flex; align-items: center; gap: 8px; }
    .tp-modal-close { background: none; border: none; font-size: 18px; cursor: pointer; color: var(--text-muted); padding: 4px 8px; border-radius: 4px; }
    .tp-modal-close:hover { background: var(--bg); }
    .tp-section { margin-bottom: 10px; }
    .tp-section-title { font-size: 9px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; padding-bottom: 4px; border-bottom: 1px solid var(--border-light); margin-bottom: 4px; }
    .tp-row { display: flex; justify-content: space-between; padding: 2px 0; font-size: 12px; }
    .tp-row .tp-label { color: var(--text-muted); }
    .tp-row .tp-val { font-weight: 700; color: var(--text-primary); }
    .team-score { font-size: 28px; font-weight: 900; color: var(--text-primary); margin-top: 4px; letter-spacing: -1px; line-height: 1; }
    .team-record { font-size: 10px; color: var(--text-muted); margin-top: 2px; }
    .team-3pt-avg { font-size: 10px; color: var(--text-muted); }
    .vs-block { padding: 0 10px; color: var(--border); font-size: 14px; font-weight: 300; display: flex; flex-direction: column; align-items: center; gap: 4px; }
    .sound-toggle { display: none!important; }
    .scenario-alert-panel { position: fixed; bottom: 0; left: 0; right: 0; z-index: 500; background: var(--white); border-top: 1px solid var(--border); box-shadow: 0 -4px 20px rgba(0,0,0,.06); padding: 14px 28px; max-height: 160px; overflow-y: auto; }

    /* ===== EMPTY STATES ===== */
    .empty-state {
      text-align: center;
      padding: 60px 24px;
      color: var(--text-muted);
      font-size: 14px;
    }
    .empty-state .icon {
      font-size: 40px;
      margin-bottom: 12px;
      opacity: 0.3;
      filter: grayscale(1);
    }
    .empty-state p { max-width: 320px; margin: 0 auto; line-height: 1.6; }

    /* ===== FORMS ===== */
    .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px; }

    /* ===== BADGES ===== */
    .signal-badge, .badge {
      display: inline-block;
      padding: 3px 10px;
      border-radius: 20px;
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.4px;
    }
    .signal-badge.hot, .badge.hot, .badge-hot { background: var(--red-light); color: var(--red); }
    .signal-badge.cold, .badge.cold, .badge-cold { background: var(--accent-light); color: var(--accent); }
    .signal-badge.warm, .badge.warm { background: var(--orange-light); color: var(--orange); }

    /* ===== PANELS ===== */
    .panel, .section {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 22px;
      margin-bottom: 20px;
      box-shadow: var(--shadow-xs);
    }
    .panel-header, .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding-bottom: 14px; border-bottom: 1px solid var(--border-light); }
    .grid-section-label { grid-column: 1/-1; padding: 12px 0 4px; border-top: 1px solid var(--border); margin-top: 8px; }
    .grid-section-label span { font-size: 11px; font-weight: 700; letter-spacing: 1px; text-transform: uppercase; }
    .grid-section-label:first-child { border-top: none; margin-top: 0; }

    /* ===== TABLES ===== */
    table { width: 100%; border-collapse: separate; border-spacing: 0; font-size: 13px; }
    thead th {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      text-align: left;
      background: var(--bg);
    }
    tbody td { padding: 12px 14px; border-bottom: 1px solid var(--border-light); color: var(--text-primary); font-weight: 500; }
    tbody tr { transition: background 0.15s ease; }
    tbody tr:hover { background: var(--bg); }
    tbody tr:last-child td { border-bottom: none; }
    tbody tr:nth-child(even) { background: rgba(0,0,0,0.008); }
    [data-theme="dark"] tbody tr:nth-child(even) { background: rgba(255,255,255,0.015); }

    /* ===== 3PT & TRACKER CARDS ===== */
    .three-pt-card, .tracker-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow-xs);
    }
    .quarter-box, .qtr-box { display: inline-flex; align-items: center; justify-content: center; min-width: 36px; height: 28px; padding: 2px 8px; border-radius: var(--radius-sm); font-size: 12px; font-weight: 700; background: var(--bg); color: var(--text-secondary); border: 1px solid var(--border-light); }
    .quarter-box.hot, .qtr-box.hot { background: var(--red-light); color: var(--red); border-color: transparent; }

    /* ===== THESIS / EDGE CARDS ===== */
    .thesis-card, .edge-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: var(--shadow-xs);
      margin-bottom: 16px;
      transition: all 0.25s ease;
    }
    .thesis-card:hover { box-shadow: var(--shadow-sm); }
    .criteria-item { display: flex; gap: 12px; padding: 12px 0; border-bottom: 1px solid var(--border-light); }
    .criteria-item:last-child { border-bottom: none; }
    .criteria-item.met { background: transparent; }
    .criteria-item.not-met { opacity: 0.4; }
    .criteria-check { font-size: 16px; flex-shrink: 0; margin-top: 2px; }
    .criteria-text { flex: 1; }
    .criteria-label { font-size: 13px; font-weight: 700; color: var(--text-primary); display: block; margin-bottom: 4px; letter-spacing: -0.1px; }
    .criteria-value {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent);
      display: inline-block;
      padding: 2px 10px;
      background: var(--accent-light);
      border-radius: 20px;
      margin-bottom: 6px;
    }
    .criteria-value.warn { color: var(--orange); background: var(--orange-light); }
    .criteria-value.neg { color: var(--text-muted); background: var(--bg); }
    .criteria-detail { font-size: 12px; color: var(--text-secondary); line-height: 1.7; display: block; }
    .criteria-detail strong { color: var(--text-primary); font-weight: 700; }
    .thesis-game-bar { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 14px; padding-bottom: 12px; border-bottom: 1px solid var(--border-light); }
    .thesis-game-label { font-size: 16px; font-weight: 800; color: var(--text-primary); letter-spacing: -0.3px; }
    .thesis-game-period { font-size: 12px; color: var(--text-muted); margin-top: 3px; }
    .thesis-bet-line {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 14px;
      border: 1px solid var(--border-light);
    }
    .thesis-bet-action { font-size: 17px; font-weight: 800; color: var(--accent); letter-spacing: -0.3px; }
    .thesis-bet-side { font-size: 12px; color: var(--text-muted); margin-top: 4px; }
    .thesis-logic { margin-bottom: 14px; }
    .thesis-logic-title { font-size: 11px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
    .thesis-logic-text { font-size: 13px; color: var(--text-secondary); line-height: 1.7; }
    .thesis-criteria { margin-bottom: 14px; }
    .thesis-actions { display: flex; justify-content: space-between; align-items: center; padding-top: 12px; border-top: 1px solid var(--border-light); }
    .thesis-confidence { text-align: right; }
    .conf-meter { display: flex; gap: 4px; justify-content: flex-end; margin-bottom: 6px; }
    .conf-dot { width: 10px; height: 10px; border-radius: 50%; background: var(--border-light); border: 1px solid var(--border); transition: all 0.2s; }
    .conf-dot.lit { background: var(--accent); border-color: var(--accent); box-shadow: 0 0 4px rgba(0,212,170,0.3); }
    .conf-dot.lit-red { background: var(--red); border-color: var(--red); box-shadow: 0 0 4px rgba(239,68,68,0.3); }
    .conf-label { font-size: 11px; font-weight: 600; }
    .conf-label.high { color: var(--green); }
    .conf-label.medium { color: var(--orange); }
    .conf-label.low { color: var(--text-muted); }

    /* ===== MODALS ===== */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.25);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.2s ease;
    }
    .modal-overlay.active { display: flex; }
    .modal {
      background: var(--white);
      border-radius: var(--radius-lg);
      padding: 32px;
      width: 90%;
      max-width: 520px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.12), 0 4px 16px rgba(0,0,0,0.06);
      animation: slideUp 0.25s ease;
      border: 1px solid var(--border);
    }
    .modal h2, .modal h3 { font-size: 18px; font-weight: 800; margin-bottom: 24px; color: var(--text-primary); letter-spacing: -0.3px; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

    /* ===== FORM CONTROLS ===== */
    input, select, textarea {
      font-family: 'Inter', sans-serif;
      font-size: 13px;
      padding: 10px 14px;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--white);
      color: var(--text-primary);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      width: 100%;
    }
    input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(0,212,170,0.12); }
    select { appearance: none; background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%236b7280' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 12px center; padding-right: 32px; }

    /* ===== SCROLLBAR ===== */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

    /* ===== BANKROLL ===== */
    .bankroll-section, .bankroll-settings { background: var(--card-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 22px; box-shadow: var(--shadow-xs); margin-bottom: 20px; }
    .bankroll-section label, label { font-size: 12px; font-weight: 600; color: var(--text-secondary); display: block; margin-bottom: 6px; }
    .stop-loss, .rules-box, [style*="border-left: 3px solid"] { background: var(--orange-light) !important; border: 1px solid #fde68a !important; border-left: 3px solid var(--orange) !important; border-radius: var(--radius-sm) !important; padding: 12px 16px !important; color: #92400e !important; font-size: 13px !important; }
    .notification-toast, .toast { position: fixed; top: 20px; right: 20px; background: var(--white); border: 1px solid var(--border); border-radius: var(--radius); padding: 16px 22px; box-shadow: var(--shadow-lg); z-index: 2000; font-size: 13px; font-weight: 500; animation: slideIn 0.3s ease; max-width: 360px; }
    @keyframes slideIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
    .auto-refresh-controls, .refresh-controls { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; margin-bottom: 16px; font-size: 13px; color: var(--text-secondary); }
    .auto-refresh-controls select, .refresh-controls select { width: auto; min-width: 80px; }
    .game-score, .score { font-size: 20px; font-weight: 800; color: var(--text-primary); }
    .game-teams, .matchup, .teams { font-weight: 600; color: var(--text-primary); font-size: 14px; }
    .game-status, .status { font-size: 12px; color: var(--text-muted); font-weight: 500; }
    .signal-list, .signals { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
    a { color: var(--accent); text-decoration: none; transition: color 0.15s; }
    a:hover { color: var(--accent-hover); text-decoration: underline; }
    strong, b { font-weight: 700; }

    /* ===== REMOVE BUTTONS ===== */
    .remove-btn, button.remove, [onclick*="remove"] { background: var(--red-light) !important; color: var(--red) !important; border: none !important; border-radius: var(--radius-sm) !important; width: 32px !important; height: 32px !important; display: inline-flex !important; align-items: center !important; justify-content: center !important; font-weight: 700 !important; font-size: 14px !important; padding: 0 !important; cursor: pointer; }
    .remove-btn:hover, button.remove:hover, [onclick*="remove"]:hover { background: var(--red) !important; color: white !important; }

    /* ===== TOOLTIPS ===== */
    .tooltip-wrap{position:relative;display:inline-block;cursor:help}
    .tooltip-wrap .info-dot{display:inline-flex;align-items:center;justify-content:center;width:14px;height:14px;border-radius:50%;background:var(--border);color:var(--text-muted);font-size:9px;font-weight:700;margin-left:4px;vertical-align:middle}
    .tooltip-wrap .tip{visibility:hidden;opacity:0;position:absolute;bottom:calc(100% + 8px);left:50%;transform:translateX(-50%);background:#1e293b;color:#e0e0e0;padding:10px 14px;border-radius:var(--radius-sm);font-size:11px;line-height:1.5;white-space:normal;width:240px;z-index:100;box-shadow:0 8px 24px rgba(0,0,0,.2);pointer-events:none;transition:opacity .2s,visibility .2s}
    .tooltip-wrap:hover .tip{visibility:visible;opacity:1}
    .tooltip-wrap .tip::after{content:'';position:absolute;top:100%;left:50%;transform:translateX(-50%);border:6px solid transparent;border-top-color:#1e293b}

    /* ===== EDGE GLOW ===== */
    @keyframes edgeGlow{0%,100%{box-shadow:0 0 6px rgba(0,212,170,0.2),0 0 16px rgba(0,212,170,0.1);}50%{box-shadow:0 0 12px rgba(0,212,170,0.4),0 0 32px rgba(0,212,170,0.2);}}
    .signal-chip.combined-active{animation:edgeGlow 2.5s ease-in-out infinite;background:var(--accent-light);border-radius:0;}
    .signal-chip.combined-active:first-child { border-radius: var(--radius) 0 0 var(--radius); }
    .signal-chip.combined-active:last-child { border-radius: 0 var(--radius) var(--radius) 0; }

    /* ===== GUIDE ===== */
    .guide-section{padding:24px 0}
    .guide-intro{color:var(--text-secondary);font-size:13px;margin-bottom:20px;line-height:1.7}
    .guide-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:18px}
    .guide-card{background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);padding:20px;transition:all .25s}
    .guide-card:hover{border-color:var(--accent);box-shadow:var(--shadow-sm)}
    .guide-card h3{font-size:15px;margin-bottom:10px;display:flex;align-items:center;gap:8px}
    .guide-card .edge-label{font-size:12px;color:var(--accent);font-weight:600;margin-bottom:8px}
    .guide-card p{font-size:12px;color:var(--text-secondary);line-height:1.6;margin-bottom:10px}
    .guide-card .threshold{font-size:11px;color:var(--text-secondary);background:var(--bg);padding:10px 14px;border-radius:var(--radius-sm);border-left:3px solid var(--accent);line-height:1.6}

    /* ===== SIGNAL BADGES ===== */
    .signal-badge{display:inline-block;padding:3px 10px;border-radius:20px;font-size:10px;font-weight:700;letter-spacing:.4px;color:#fff}
    .signal-badge.badge-3pt{background:#3b82f6}
    .signal-badge.badge-star{background:#f59e0b}
    .signal-badge.badge-fragile{background:#ef4444}
    .signal-badge.badge-paint{background:#10b981}
    .signal-badge.badge-foul{background:#8b5cf6}
    .signal-badge.badge-hustle{background:#f59e0b}
    .signal-badge.badge-road{background:#06b6d4}
    .signal-badge.badge-combined{background:#00d4aa}
    .signal-badge.badge-hot{background:#ef4444}
    .signal-badge.badge-warm{background:#f97316}
    .signal-badge.badge-qtr{background:#eab308}
    .signal-badge.badge-3ptFragile{background:#3b82f6}

    /* ===== THEORY PANEL ===== */
    .theory-toggle{background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);padding:12px 18px;margin:16px auto;max-width:1200px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;transition:all .2s}
    .theory-toggle:hover{border-color:var(--orange);background:var(--orange-light)}
    .theory-toggle h3{margin:0;font-size:14px;color:var(--text-primary)}.theory-toggle .arrow{transition:transform .3s;font-size:16px;color:var(--text-muted)}
    .theory-toggle.open .arrow{transform:rotate(180deg)}
    .theory-panel{max-width:1200px;margin:0 auto 20px;background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);padding:0;max-height:0;overflow:hidden;transition:max-height .4s ease,padding .3s ease}
    .theory-panel.open{max-height:8000px;padding:24px 28px}
    .theory-panel h4{color:var(--orange);font-size:15px;margin:20px 0 10px;font-weight:700}.theory-panel h4:first-child{margin-top:0}
    .theory-panel p{color:var(--text-secondary);font-size:13px;line-height:1.8;margin:0 0 12px}
    .theory-panel .edge-box{background:var(--orange-light);border-left:3px solid var(--orange);padding:12px 16px;border-radius:0 var(--radius-sm) var(--radius-sm) 0;margin:14px 0}
    .theory-panel .edge-box p{margin:0;font-size:12px;line-height:1.6}
    .theory-panel .edge-box.green{background:var(--green-light);border-left-color:var(--green)}
    .theory-panel .edge-box.blue{background:rgba(37,99,235,.06);border-left-color:var(--accent)}
    .theory-panel .edge-box.red{background:var(--red-light);border-left-color:var(--red)}
    .theory-panel .edge-box.purple{background:var(--purple-light);border-left-color:var(--purple)}
    .theory-panel .thresh-grid{display:grid;grid-template-columns:1fr 1fr;gap:14px;margin:14px 0}
    .theory-panel .thresh-card{background:var(--bg);border:1px solid var(--border);border-radius:var(--radius-sm);padding:12px 16px}
    .theory-panel .thresh-card h5{margin:0 0 6px;font-size:13px;color:var(--green)}
    .theory-panel .thresh-card p{font-size:12px;margin:2px 0}
    .theory-panel .tag{display:inline-block;padding:2px 8px;border-radius:20px;font-size:11px;font-weight:600;margin:2px 4px 2px 0}
    .theory-panel .tag.l2{background:var(--red-light);color:var(--red)}.theory-panel .tag.l1{background:var(--orange-light);color:var(--orange)}
    .theory-panel .tag.diff{background:var(--purple-light);color:var(--purple)}
    .theory-panel .signal-divider{border:none;border-top:1px solid var(--border-light);margin:28px 0}
    @media(max-width:600px){.theory-panel .thresh-grid{grid-template-columns:1fr}}

    /* ===== ODDS ROW ===== */
    .odds-row{display:flex;justify-content:space-between;align-items:center;padding:6px 10px;margin:6px 0;background:var(--bg);border:1px solid var(--border-light);border-radius:var(--radius-sm);font-size:11px;color:var(--text-secondary);}
    .odds-row .odds-label{color:var(--text-muted);font-weight:600;font-size:10px;text-transform:uppercase;letter-spacing:0.5px;}
    .odds-row .odds-val{font-weight:700;font-size:13px;font-family:'Inter',monospace;color:var(--text-primary);}
    .odds-row .odds-val.fav{color:var(--green);}
    .odds-row .odds-val.dog{color:var(--red);}
    .odds-row .odds-val.even{color:var(--orange);}
    .odds-row .odds-src{color:var(--text-muted);font-size:9px;}
    .odds-row .odds-implied{color:var(--text-muted);font-size:10px;}
    .odds-stale{opacity:0.5;}
    #odds-status{font-size:10px;color:var(--text-muted);margin-left:8px;}
    [data-theme="dark"] .odds-row { background: linear-gradient(135deg,#1a1a2e,#16213e); border-color: #2d2d44; color: #e0e0e0; }
    [data-theme="dark"] .odds-row .odds-label { color: #8892b0; }
    [data-theme="dark"] .odds-row .odds-val { color: #e0e0e0; }
    [data-theme="dark"] .odds-row .odds-val.fav { color: #00e676; }
    [data-theme="dark"] .odds-row .odds-val.dog { color: #ff5252; }
    [data-theme="dark"] .odds-row .odds-val.even { color: #ffd740; }
    [data-theme="dark"] .odds-row .odds-src { color: #546e7a; }
    [data-theme="dark"] .odds-row .odds-implied { color: #78909c; }

    /* ===== LIVE INDICATOR ===== */
    .live-indicator { display: inline-flex; align-items: center; gap: 6px; font-size: 11px; font-weight: 700; color: var(--green); letter-spacing: 0.5px; }
    .live-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--green); animation: livePulse 1.5s ease-in-out infinite; }
    @keyframes livePulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.4; transform: scale(0.8); } }

    /* ===== SIGNAL FIRE / WARN GAME CARDS ===== */
    .game-card.signal-fire { border: 2px solid var(--accent); box-shadow: 0 0 0 1px var(--accent-light), var(--shadow-sm); }
    .game-card.signal-fire:hover { box-shadow: 0 0 0 1px var(--accent-light), var(--shadow-md); }
    .game-card.signal-warn { border: 1px solid var(--orange); }

    /* ===== STAT BARS (game card inline stats) ===== */
    .stat-bars { margin-top: 10px; }
    .stat-bar-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-size: 11px; }
    .stat-bar-label { font-size: 10px; font-weight: 700; color: var(--text-muted); min-width: 52px; text-transform: uppercase; letter-spacing: 0.3px; }
    .stat-bar-track { flex: 1; height: 6px; background: var(--border-light); border-radius: 3px; position: relative; overflow: visible; }
    .stat-bar-fill { height: 100%; border-radius: 3px; font-size: 0; line-height: 0; transition: width 0.5s ease; }
    .stat-bar-fill.hot { background: var(--red); }
    .stat-bar-fill.normal { background: var(--accent); }
    .stat-bar-fill.cold { background: var(--text-muted); }
    .stat-bar-avg { position: absolute; top: -3px; width: 1px; height: 12px; background: var(--text-muted); opacity: 0.4; }
    .stat-bar-value { font-size: 10px; font-weight: 600; color: var(--text-secondary); min-width: 36px; text-align: right; font-variant-numeric: tabular-nums; }

    /* Durability bars */
    .durability-bar { display: flex; align-items: center; gap: 6px; font-size: 10px; color: var(--text-muted); margin-top: 4px; }
    .durability-meter { flex: 1; height: 4px; background: var(--border-light); border-radius: 2px; overflow: hidden; }
    .durability-meter-fill { height: 100%; border-radius: 2px; transition: width 0.5s ease; }

    /* Pace indicator */
    .pace-indicator { display: inline-block; width: 60px; height: 5px; background: var(--border-light); border-radius: 3px; overflow: hidden; vertical-align: middle; margin-right: 4px; }
    .pace-fill { height: 100%; border-radius: 3px; transition: width 0.5s ease; }

    /* 3PT tracker cards */
    .three-pt-card-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 16px; background: var(--bg); border-bottom: 1px solid var(--border-light); font-size: 12px; font-weight: 600; color: var(--text-secondary); border-radius: var(--radius) var(--radius) 0 0; }
    .three-pt-card-body { padding: 14px 16px; }
    .hot-card { border-color: var(--red) !important; }
    .warm-card { border-color: var(--orange) !important; }
    .qtr-grid { display: flex; gap: 6px; margin-top: 6px; }

    /* Signal badge variants in game cards */
    .signal-fire { font-weight: 700; }
    .signal-moderate { background: var(--orange-light); color: var(--orange); }
    .signal-none { background: var(--bg); color: var(--text-muted); }

    /* Fav star */
    .fav-star { opacity: 0.4; transition: opacity 0.2s; }
    .fav-star:hover { opacity: 1; }

    /* Edge thesis container */
    .edge-thesis-container { margin-bottom: 20px; }
    .edge-thesis-container:not(.active) { display: none; }
    .edge-thesis-container.active { display: block; }

    /* Connection status */
    .conn-status { font-size: 10px; padding: 2px 8px; border-radius: 20px; font-weight: 600; }
    .conn-ok { color: var(--green); }
    .conn-err { color: var(--red); }
    .conn-loading { color: var(--orange); }

    /* Live pulse header */
    .live-pulse { background: linear-gradient(135deg, var(--accent-light), var(--bg)) !important; }

    /* Btn variants */
    .btn-sm { font-size: 12px; padding: 6px 14px; }
    .btn-green { background: var(--accent); color: white; }
    .btn-green:hover { background: var(--accent-hover); }
    .btn-red { background: var(--red); color: white; }
    .btn-purple { background: var(--purple); color: white; }
    .btn-orange { background: var(--orange); color: white; }
    .btn-outline { background: var(--card-bg); color: var(--text-secondary); border: 1px solid var(--border); }
    .btn-outline:hover { border-color: var(--accent); color: var(--accent); }

    /* Odds history button */
    .odds-hist-btn { margin: 8px 10px !important; padding: 5px 14px !important; font-size: 11px !important; font-weight: 600 !important; border: 1px solid var(--border) !important; color: var(--text-secondary) !important; background: var(--bg) !important; border-radius: 20px !important; cursor: pointer !important; transition: all 0.2s !important; }
    .odds-hist-btn:hover { background: var(--accent-light) !important; border-color: var(--accent) !important; color: var(--accent) !important; }

    /* ===== MOBILE RESPONSIVE ===== */
    @media (max-width: 768px) {
      .header { padding: 12px 16px; flex-wrap: wrap; gap: 8px; min-height: auto; }
      .header h1 { font-size: 15px; }
      .header .subtitle { font-size: 10px; }
      .logo-icon { width: 30px; height: 30px; }
      .logo-text .logo-main { font-size: 16px; letter-spacing: 1px; }
      .logo-text .logo-sub { font-size: 8px; letter-spacing: 2px; }
      .logo-wrap { gap: 8px; }
      .header-right { gap: 4px; }
      .header-right button { font-size: 10px; padding: 4px 8px; }
      .tab-bar { padding: 0 16px; top: auto; }
      .tabs { overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
      .tabs::-webkit-scrollbar { display: none; }
      .tab { padding: 10px 14px; font-size: 12px; }
      .signal-strip { flex-wrap: wrap; }
      .signal-chip { flex: 1 1 30%; min-width: 90px; padding: 10px 6px; }
      .signal-chip .chip-value { font-size: 20px; }
      .signal-chip .chip-label { font-size: 10px; }
      .signal-chip .chip-desc { display: none; }
      .game-card-body { padding: 10px 12px; }
      .game-card { margin-bottom: 12px; }
      .modal { width: 95%; padding: 20px; }
      .container { padding: 12px; }
      .content, .main-content, .tab-content { padding: 16px; }
      #live-games, #tab-3pt, #tab-star, #tab-betlog, #tab-bankroll, #tab-guide { padding: 12px; }
      .edge-panel { padding: 12px; }
      .guide-card { padding: 14px; }
      .games-grid { grid-template-columns: 1fr; }
      .stats-row { grid-template-columns: repeat(2, 1fr); }
    }
    @media (max-width: 480px) {
      .header h1 { font-size: 13px; }
      .signal-chip { flex: 1 1 45%; }
      .tab { padding: 8px 10px; font-size: 11px; }
      .logo-icon { width: 24px; height: 24px; }
      .logo-text .logo-main { font-size: 14px; }
      .logo-text .logo-sub { display: none; }
      .logo-wrap { gap: 6px; }
      .stats-row { grid-template-columns: repeat(2, 1fr); gap: 10px; }
      .stat-card { padding: 14px 10px; }
      .stat-value { font-size: 24px; }
    }

</style>
</head>
<body>

<div class="header">
  <div class="logo-wrap">
    <svg class="logo-icon" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="logoGrad" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" stop-color="#00d4aa"/>
          <stop offset="50%" stop-color="#00b4d8"/>
          <stop offset="100%" stop-color="#7c3aed"/>
        </linearGradient>
        <radialGradient id="glowGrad" cx="50%" cy="50%" r="50%">
          <stop offset="0%" stop-color="#00d4aa" stop-opacity="0.3"/>
          <stop offset="100%" stop-color="#00d4aa" stop-opacity="0"/>
        </radialGradient>
      </defs>
      <circle class="scope-pulse" cx="20" cy="20" r="2"/>
      <circle class="scope-ring" cx="20" cy="20" r="14"/>
      <circle class="scope-ring" cx="20" cy="20" r="8" stroke-dasharray="3 3"/>
      <line class="scope-cross" x1="20" y1="2" x2="20" y2="10"/>
      <line class="scope-cross" x1="20" y1="30" x2="20" y2="38"/>
      <line class="scope-cross" x1="2" y1="20" x2="10" y2="20"/>
      <line class="scope-cross" x1="30" y1="20" x2="38" y2="20"/>
      <circle class="scope-dot" cx="20" cy="20" r="2.5"/>
      <path d="M14 11 L20 5 L26 11" fill="none" stroke="url(#logoGrad)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.6"/>
    </svg>
    <div class="logo-text">
      <span class="logo-main" id="main-title">ALPHA HUNTER</span>
      <span class="logo-sub" id="main-subtitle">NBA &bull; DATA-DRIVEN ANALYTICS</span>
    </div>
  </div>
  <div class="header-right">
    <span class="conn-status conn-ok" id="connStatus" style="display:none;font-size:10px;color:var(--text-muted);">Connected</span>
    <div style="display:flex;align-items:center;gap:6px;">
      <span class="status-dot off" id="statusDot"></span>
      <span id="statusText" style="font-size:11px;color:var(--text-muted);">ESPN Feed</span>
    </div>
    <span id="ncaa-star-status" style="font-size:10px;color:var(--accent);font-weight:600;"></span>
    <div class="header-controls">
      <button id="modeToggleBtn" onclick="switchMode(currentMode==='nba'?'ncaab':'nba')" title="Switch NBA/NCAAB" style="background:var(--purple)!important;color:white!important;">NBA</button>
      <button id="darkModeToggle" onclick="toggleDarkMode()" title="Toggle dark mode">Dark</button>
      <button class="sound-toggle" id="soundToggle" onclick="toggleSound()" title="Toggle alert sounds">&#x1F50A; Sound</button>
    </div>
  </div>
</div>

<div class="tab-bar" id="tabBar">
  <div class="tab active" onclick="switchTab('live')" id="tab-live">Live Games <span class="badge" id="live-badge" style="display:none;">0</span></div>
  <div class="tab" onclick="switchTab('threept')" id="tab-threept">3PT Tracker <span class="badge badge-purple" id="threept-badge" style="display:none;">0</span></div>
  <div class="tab" onclick="switchTab('stars')" id="tab-stars">Star Tracker</div>
  <div class="tab" onclick="switchTab('log')" id="tab-log">Bet Log</div>
  <div class="tab" onclick="switchTab('bankroll')" id="tab-bankroll">Bankroll</div>
  <div class="tab" onclick="switchTab('history')" id="tab-history">History</div>
  <div class="tab" onclick="switchTab('tracker')" id="tab-tracker">Backtest</div>
  <div class="tab" onclick="switchTab('guide')" id="tab-guide">Signal Guide</div>
</div>

<div class="container">
  <div id="quarter-alerts"></div>

  <!-- ==================== LIVE GAMES TAB ==================== -->
  <div class="tab-content active" id="content-live">
    <!-- EDGE THESIS PANEL -->
    <div class="edge-thesis-container" id="edgeThesisContainer">
      <div class="edge-thesis-header">
        <h2>LIVE EDGE OPPORTUNITIES</h2>
        <span class="thesis-count" id="thesisCount">0</span>
      </div>
      <div id="edgeThesisCards"></div>
    </div>

    <div class="auto-refresh-bar" style="background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);padding:10px 16px;margin-bottom:16px;">
      <span class="dot" id="autoRefreshDot" style="width:6px;height:6px;border-radius:50%;background:var(--text-muted);flex-shrink:0;"></span>
      <span style="font-weight:500;">Auto-refresh: <strong id="autoRefreshLabel" style="color:var(--text-primary);">OFF</strong></span>
      <button class="btn btn-sm btn-green" id="autoRefreshBtn" onclick="toggleAutoRefresh()" style="background:var(--accent);color:white;border:none;padding:6px 16px;border-radius:20px;font-size:11px;font-weight:700;">Start</button>
      <span style="color:var(--text-muted);font-size:11px;">Every:</span>
      <select id="refreshInterval" style="padding:4px 8px;font-size:11px;border-radius:6px;border:1px solid var(--border);width:auto;min-width:60px;" onchange="updateRefreshInterval()">
        <option value="30" selected>30s</option>
        <option value="60">60s</option>
        <option value="120">2min</option>
      </select>
      <div class="countdown-bar"><div class="countdown-fill" id="countdownFill" style="width:100%;"></div></div>
      <span class="live-indicator" id="liveIndicator" style="display:none"><span class="live-dot"></span>LIVE</span>
      <span style="margin-left:auto;color:var(--text-muted);font-size:10px;">Last: <span id="live-last-update">-</span> | Errors: <span id="errorCount">0</span></span>
    </div>

    <div class="signal-strip">
      <div class="signal-chip">
        <div class="chip-value" id="live-games-count">-</div>
        <div class="chip-label">Games</div>
        <div class="chip-desc">Total live games tracked</div>
      </div>
      <div class="signal-chip signal-chip-clickable" onclick="toggleSignalDetail('3ptfragile')">
        <div class="chip-value" id="live-3ptfragile-signals">0</div>
        <div class="chip-label">3PT Fragile</div>
        <div class="chip-desc">Hot 3PT shooting + fragile lead composition</div>
        <div class="chip-detail-panel" id="chip-detail-3ptfragile"></div>
      </div>
      <div class="signal-chip signal-chip-clickable" onclick="toggleSignalDetail('star')">
        <div class="chip-value" id="live-star-signals">0</div>
        <div class="chip-label">Star Coil</div>
        <div class="chip-desc">Star cold + game close + Q2-Q3</div>
        <div class="chip-detail-panel" id="chip-detail-star"></div>
      </div>

      <div class="signal-chip signal-chip-clickable" onclick="toggleSignalDetail('combined')">
        <div class="chip-value" id="live-combined-signals">0</div>
        <div class="chip-label">Combined</div>
        <div class="chip-desc">2+ signals on same side</div>
        <div class="chip-detail-panel" id="chip-detail-combined"></div>
      </div>
    </div>

<!-- QUICK BET ACTION CARDS -->
<div id="quick-bet-panel" style="display:none; margin-bottom: 20px;">
  <div style="font-size: 11px; font-weight: 700; color: var(--accent); text-transform: uppercase; letter-spacing: 1.2px; margin-bottom: 10px; display:flex; align-items:center; gap:8px;">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>
    ACTION REQUIRED
  </div>
  <div id="quick-bet-cards"></div>
</div>

    <div class="card">
      <div class="card-header"><span>Live Game Monitor</span>
        <button class="btn btn-green btn-sm" onclick="fetchESPNScoreboard()">Refresh Now</button>
      </div>
      <div class="card-body">
        <div class="games-grid" id="live-games-grid">
          <div class="empty-state" style="grid-column:1/-1;">
            <div style="width:56px;height:56px;margin:0 auto 16px;background:var(--bg);border:2px solid var(--border);border-radius:50%;display:flex;align-items:center;justify-content:center;">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
            </div>
            <p style="font-weight:600;color:var(--text-secondary);margin-bottom:4px;">Waiting for games</p>
            <p style="font-size:12px;">Click "Refresh Now" or start auto-refresh to load live games.</p>
          </div>
        </div>
      </div>
    </div>

    </div>
  </div>

  <!-- ==================== 3PT TRACKER TAB ==================== -->
  <div class="tab-content" id="content-threept">
    <div class="stats-row">
      <div class="stat-card"><div class="stat-label">Teams 50%+ 3PT</div><div class="stat-value red" id="threept-hot-count">0</div></div>
      <div class="stat-card"><div class="stat-label">Teams 45-50%</div><div class="stat-value orange" id="threept-warm-count">0</div></div>
      <div class="stat-card"><div class="stat-label">Qtr Alerts</div><div class="stat-value purple" id="threept-qtr-alerts">0</div></div>
      </div>
    <div class="card">
      <div class="card-header"><span>3-Point Shooting Tracker - Live</span><span style="font-size:10px;color:var(--text-muted);">Alert: 50%+ on 8+ att</span></div>
      <div class="card-body"><div class="games-grid" id="threept-grid"><div class="empty-state" style="grid-column:1/-1;"><p>3PT tracking populates when live games run.</p></div></div></div>
    </div>
    <div class="card">
      <div class="card-header"><span>Quarter-End Alerts</span><button class="btn btn-sm btn-outline" onclick="clearQtrAlerts()">Clear</button></div>
      <div class="card-body">
        <table><thead><tr><th>Time</th><th>Team</th><th>Qtr</th><th>3PT%</th><th>Made/Att</th><th>Game</th><th>Action</th></tr></thead>
        <tbody id="qtr-alerts-body"><tr><td colspan="7" class="empty-state">No quarter-end alerts yet.</td></tr></tbody></table>
      </div>
    </div>
  </div>

  <!-- ==================== STAR TRACKER TAB ==================== -->
  <div class="tab-content" id="content-stars">
    <div class="card">
      <div class="card-header"><span id="star-db-title">Star Player Database (21+ PPG)</span><span id="star-db-subtitle" style="font-size:10px;color:var(--text-muted);">Signal: &lt;65% of expected pace</span></div>
      <div class="card-body" style="font-size:12px;">
        <p style="margin-bottom:10px;color:var(--text-muted);">Players tracked automatically in live games. Signal fires when scoring falls below 60% of expected pace. Tracks Q1 and halftime pace separately.</p>
        <table>
          <thead><tr><th>Player</th><th>Team</th><th>PPG</th><th>Q1 Exp</th><th>Half Exp</th><th>Signal (&lt;60%)</th><th></th></tr></thead>
          <tbody id="star-db-body"></tbody>
        </table>
        <div style="margin-top:10px;">
          <div class="form-grid" style="max-width:700px;">
            <div class="form-group"><label>Player Name</label><input type="text" id="add-star-name" placeholder="e.g., LeBron James" /></div>
            <div class="form-group"><label>Team</label><input type="text" id="add-star-team" placeholder="e.g., LAL" /></div>
            <div class="form-group"><label>PPG</label><input type="number" id="add-star-ppg" placeholder="e.g., 28.5" step="0.1" /></div>
            <div class="form-group" style="justify-content:flex-end;"><button class="btn btn-green" onclick="addStar()">Add</button></div>
          </div>
        </div>
      </div>
    </div>
    <div class="card">
      <div class="card-header">Live Star Status</div>
      <div class="card-body">
        <table><thead><tr><th>Player</th><th>Game</th><th>Pts</th><th id="star-col-q1">Q1 Pace</th><th>Half Pace</th><th>Overall %</th><th>Period</th><th>Signal</th></tr></thead>
        <tbody id="live-star-status"><tr><td colspan="8" class="empty-state">Star stats populate when live games are running.</td></tr></tbody></table>
      </div>
    </div>
  </div>

  <!-- ==================== BET LOG TAB ==================== -->
  <div class="tab-content" id="content-log">
    <div style="margin-bottom:20px">
      <h2 style="font-size:18px;font-weight:800;margin-bottom:4px">Bet Tracker</h2>
      <p style="font-size:12px;color:var(--text-muted)">Auto-logged when signals fire. Results auto-resolved from ESPN final scores.</p>
    </div>
    <div id="backtest-panel" style="display:grid;grid-template-columns:repeat(5,1fr);gap:12px;margin-bottom:20px">
      <div class="stat-card"><div class="stat-label">TOTAL BETS</div><div class="stat-value" id="bt-total" style="font-size:24px">0</div></div>
      <div class="stat-card"><div class="stat-label">WIN RATE</div><div class="stat-value" id="bt-winrate" style="font-size:24px;color:var(--green)">-</div></div>
      <div class="stat-card"><div class="stat-label">ROI</div><div class="stat-value" id="bt-roi" style="font-size:24px">-</div></div>
      <div class="stat-card"><div class="stat-label">AVG EDGE</div><div class="stat-value" id="bt-edge" style="font-size:24px;color:var(--accent)">-</div></div>
      <div class="stat-card"><div class="stat-label">UNITS P/L</div><div class="stat-value" id="bt-units" style="font-size:24px">0.00</div></div>
    </div>
    <div id="signal-breakdown" style="margin-bottom:20px"></div>
    <div style="display:flex;gap:10px;margin-bottom:16px;align-items:center">
      <button style="background:var(--accent);color:white;border:none;padding:8px 16px;border-radius:20px;font-size:12px;font-weight:600;cursor:pointer" onclick="exportBetLog()">Export CSV</button>
      <button style="background:var(--card-bg);color:var(--text-muted);border:1px solid var(--border);padding:8px 16px;border-radius:20px;font-size:12px;font-weight:600;cursor:pointer" onclick="if(confirm('Clear all bet log data?'))clearBetLog()">Clear Log</button>
      <span style="margin-left:auto;font-size:11px;color:var(--text-muted)">Bets auto-log when combined signals fire</span>
    </div>
    <div class="card" style="padding:0;overflow:hidden">
      <div id="bet-log-entries" style="overflow-x:auto"></div>
    </div>
  </div>

  <!-- ==================== BANKROLL TAB ==================== -->
  <div class="tab-content" id="content-bankroll">
    <div style="margin-bottom:20px">
      <h2 style="font-size:18px;font-weight:800;margin-bottom:4px">Position Sizing</h2>
      <p style="font-size:12px;color:var(--text-muted)">Kelly criterion-based bet sizing. Conservative by default - capped at 5% max per bet.</p>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:24px">
      <div class="card" style="padding:20px">
        <h3 style="font-size:14px;font-weight:700;color:var(--accent);margin-bottom:16px">Settings</h3>
        <div style="margin-bottom:14px">
          <label style="font-size:11px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px">Bankroll</label>
          <input type="number" id="bankroll-input" value="1000" min="1" style="margin-top:4px;font-size:16px;font-weight:700" onchange="saveBankrollSettings()">
        </div>
        <div style="margin-bottom:14px">
          <label style="font-size:11px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px">Kelly Fraction</label>
          <select id="kelly-fraction" style="margin-top:4px" onchange="saveBankrollSettings()">
            <option value="0.25">Quarter Kelly (25%) - Safest</option>
            <option value="0.5" selected>Half Kelly (50%) - Recommended</option>
            <option value="0.75">Three-Quarter Kelly (75%)</option>
            <option value="1">Full Kelly (100%) - Max Risk</option>
          </select>
        </div>
        <div style="margin-bottom:14px">
          <label style="font-size:11px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px">Edge Estimate</label>
          <select id="edge-mode" style="margin-top:4px" onchange="saveBankrollSettings()">
            <option value="conservative">Conservative (2-5%)</option>
            <option value="moderate" selected>Moderate (3.5-6.5%)</option>
            <option value="aggressive">Aggressive (6-9%)</option>
            <option value="backtest">From Your Bet History</option>
          </select>
        </div>
        <div style="background:var(--bg);border-radius:8px;padding:12px;margin-top:12px">
          <div style="font-size:10px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px">Sizing Rules</div>
          <div style="font-size:11px;color:var(--text-secondary);line-height:1.6">
            Max bet: 5% of bankroll<br>
            Min bet: 0.5% (if edge exists)<br>
            Edge scales with signal count<br>
            Probability capped at 90%
          </div>
        </div>
      </div>
      <div class="card" style="padding:20px">
        <h3 style="font-size:14px;font-weight:700;color:var(--accent);margin-bottom:16px">Kelly Formula</h3>
        <div style="background:var(--bg);border-radius:8px;padding:16px;font-family:'Courier New',monospace;font-size:13px;color:var(--text-secondary);line-height:2">
          f* = (b x p - q) / b<br>
          <span style="color:var(--text-muted);font-size:11px">b = decimal odds - 1</span><br>
          <span style="color:var(--text-muted);font-size:11px">p = market prob + estimated edge</span><br>
          <span style="color:var(--text-muted);font-size:11px">q = 1 - p</span><br><br>
          <span style="color:var(--accent);font-weight:bold">Bet = Bankroll x f* x Fraction</span>
        </div>
        <div style="margin-top:16px;padding:12px;background:var(--accent-light);border-radius:8px;border-left:3px solid var(--accent)">
          <div style="font-size:11px;color:var(--accent);font-weight:600">How edge is estimated</div>
          <div style="font-size:11px;color:var(--text-secondary);margin-top:4px;line-height:1.5">
            Base edge depends on your mode setting. Each additional signal on the same game adds +1% edge (up to +3%). More signals = higher confidence = larger position.
          </div>
        </div>
      </div>
    </div>
    <div class="card" style="padding:20px">
      <h3 style="font-size:14px;font-weight:700;color:var(--accent);margin-bottom:16px">Active Recommendations</h3>
      <div id="kelly-recs"><p style="color:var(--text-muted);text-align:center;padding:30px;font-size:13px">Refresh games to see Kelly-sized recommendations</p></div>
    </div>
  </div>
</div>



<!-- LOG BET MODAL -->
<div class="modal-overlay" id="logModal">
  <div class="modal">
    <h3>Log This Bet</h3>
    <div class="form-grid">
      <div class="form-group"><label>Game</label><input type="text" id="modal-game" /></div>
      <div class="form-group"><label>Side</label><input type="text" id="modal-side" /></div>
      <div class="form-group"><label>Strategy</label><select id="modal-strategy"><option>Mean Reversion</option><option>3PT Fragile</option><option>Star Coil</option><option>Combined Edge</option></select></div>
      <div class="form-group"><label>Line / Price</label><input type="text" id="modal-price" /></div>
      <div class="form-group"><label>Units</label><input type="number" id="modal-units" value="1" step="0.5" min="0.5" max="2" /></div>
      <div class="form-group"><label>Notes</label><input type="text" id="modal-notes" /></div>
    </div>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
      <button class="btn btn-outline" onclick="closeModal()">Cancel</button>
      <button class="btn btn-green" onclick="confirmLogBet()">Log Bet</button>
    </div>
  </div>
</div>


  <div id="scenario-alert-panel" class="scenario-alert-panel" style="display:none;"></div>

  <!-- No toast container  signals show on chips and game cards only -->

<script>
const TEAM_3PT_AVG = {
  // NBA (2025-26)
  BOS:38.1, CLE:37.9, OKC:38.9, HOU:36.2, GSW:37.8, DEN:36.5, DAL:37.6, MIL:36.8,
  MIN:36.3, NYK:37.8, PHI:36.9, PHX:38.2, LAC:36.5, MEM:35.9, SAC:37.5, MIA:36.8,
  IND:36.7, ORL:35.4, ATL:37.2, CHI:34.2, BKN:35.4, CHA:34.8, TOR:36.1, POR:35.6,
  SAS:35.3, DET:35.7, LAL:36.3, WAS:34.5, UTA:37.0, NOP:35.1, NY:37.8, GS:37.8,
  SA:35.3, NO:35.1
};
function getTeam3PtAvg(abbr) {
  if (isNCAA()) return ncaaTeam3ptCache[abbr] || 33.5; // per-team NCAA avg, fallback to league avg
  return TEAM_3PT_AVG[abbr] || null; // NBA: hardcoded per-team
}

// ==================== SUPPORTING CAST ANALYSIS ====================
// Pure live-data approach: no season averages, no assumptions.
// Compares the star's teammates' output directly to the opponent's total output.
//
// castScore = teamScore - starPts (what teammates produced)
// castGap = castScore - opponentScore (how close cast alone is to matching the opponent)
//
// If castGap  0: Cast is MATCHING or BEATING the opponent without the star. Star regression = dominant.
// If castGap > -8: Cast is close. Star regression likely flips the game. Strong edge.
// If castGap -8 to -15: Cast is behind but game is still in range. Standard edge.
// If castGap < -15: Cast is way behind. Whole team broken. Star alone won't save it. Weak edge.
//
// Also computes starDeficit = star's expected pts - star's actual pts (the "missing" points).
// If starDeficit > |castGap|, star regression alone closes the gap. This is the key insight:
//   the star has MORE missing points than the team is behind = regression flips the lead.
//
function analyzeSupportingCast(starPts, teamScore, opponentScore, starPPG, elapsedMinutes) {
  const castScore = teamScore - starPts;
  const castGap = castScore - opponentScore;
  const starExpected = starPPG * (elapsedMinutes / getTotalGameMinutes());
  const starDeficit = starExpected - starPts;  // how many points the star is "missing"
  const regressionFlips = starDeficit > 0 && starDeficit > Math.abs(Math.min(castGap, 0));

  if (elapsedMinutes < 8) return { castScore, castGap, starDeficit, regressionFlips, strong: false, moderate: false, weak: true, label: 'N/A', emoji: '', reason: 'too early' };

  // Classify based on cast gap
  const strong = castGap >= -8;     // cast within 8 of opponent or ahead
  const moderate = castGap >= -15 && castGap < -8;
  const weak = castGap < -15;

  let label, emoji;
  if (castGap >= 0) { label = 'CAST LEADING'; emoji = ''; }
  else if (strong) { label = 'CAST CLOSE'; emoji = ''; }
  else if (moderate) { label = 'CAST BEHIND'; emoji = ''; }
  else { label = 'CAST BROKEN'; emoji = ''; }

  return {
    castScore, castGap, starDeficit: Math.round(starDeficit * 10) / 10,
    starExpected: Math.round(starExpected * 10) / 10,
    regressionFlips,
    strong, moderate, weak, label, emoji,
    reason: `Cast ${castScore}pts vs opp ${opponentScore}pts (gap: ${castGap > 0 ? '+' : ''}${castGap}). Star missing ~${starDeficit.toFixed(0)}pts.${regressionFlips ? ' Regression flips the lead.' : ''}`
  };
}

let currentMode='nba';

// NCAA Star Database  built PRE-GAME from ESPN team leaders API (real season PPG)
let ncaaStarCache = JSON.parse(localStorage.getItem('ncaaStarCache') || '[]');
let ncaaStarCacheTime = parseInt(localStorage.getItem('ncaaStarCacheTime') || '0');
const NCAA_STAR_CACHE_TTL = 86400000; // 24h cache
let ncaaStarBuildInProgress = false;

function isNCAA() { return currentMode === 'ncaab'; }

// NCAA team 3PT season averages  per-team (not flat league average)
let ncaaTeam3ptCache = JSON.parse(localStorage.getItem('ncaaTeam3ptCache') || '{}');

// Build NCAA star database + team 3PT averages from ESPN Core API
// Fetches ALL 362 D-I teams (not just today's games)
// Pipeline: teams endpoint  team leaders (PPG)  resolve names for 16+ PPG + team 3PT stats
async function buildNcaaStarDB(forceRefresh) {
  if (ncaaStarBuildInProgress) return;
  if (!forceRefresh && ncaaStarCache.length > 0 && (Date.now() - ncaaStarCacheTime) < NCAA_STAR_CACHE_TTL) {
    console.log('[NCAA] Using cached DB:', ncaaStarCache.length, 'stars,', Object.keys(ncaaTeam3ptCache).length, 'team 3PT avgs');
    return;
  }
  ncaaStarBuildInProgress = true;
  const statusEl = document.getElementById('ncaa-star-status');
  if (statusEl) statusEl.textContent = 'Building full NCAA database...';
  console.log('[NCAA] Building full database (all D-I teams)...');

  try {
    // Step 1: Get ALL D-I teams from ESPN teams endpoint
    const teamsResp = await fetch('https://site.api.espn.com/apis/site/v2/sports/basketball/mens-college-basketball/teams?limit=500');
    if (!teamsResp.ok) throw new Error('Teams endpoint failed');
    const teamsData = await teamsResp.json();
    const allTeams = [];
    const leagueTeams = teamsData.sports?.[0]?.leagues?.[0]?.teams || [];
    for (const t of leagueTeams) {
      const team = t.team || {};
      if (team.id && team.abbreviation) {
        allTeams.push({ id: team.id, abbr: team.abbreviation, name: team.displayName || '' });
      }
    }
    if (statusEl) statusEl.textContent = `Scanning ${allTeams.length} teams...`;
    console.log('[NCAA] Found', allTeams.length, 'D-I teams');

    // Step 2: Fetch team leaders (PPG) + team 3PT stats  8 at a time
    const candidates = [];
    const team3pt = {};
    const batchSize = 8;

    for (let i = 0; i < allTeams.length; i += batchSize) {
      const batch = allTeams.slice(i, i + batchSize);
      if (i > 0 && i % 80 === 0) {
        if (statusEl) statusEl.textContent = `${i}/${allTeams.length} teams... (${candidates.length} stars)`;
      }

      const results = await Promise.allSettled(batch.map(async (team) => {
        const teamResult = { stars: [], abbr: team.abbr, fg3Pct: null };

        // Fetch team leaders (PPG)
        try {
          const url = `https://sports.core.api.espn.com/v2/sports/basketball/leagues/mens-college-basketball/seasons/2026/types/2/teams/${team.id}/leaders`;
          const resp = await fetch(url);
          if (resp.ok) {
            const d = await resp.json();
            for (const cat of (d.categories || [])) {
              if (cat.name === 'pointsPerGame' || cat.name === 'points' || cat.displayName === 'Points Per Game') {
                for (const l of (cat.leaders || [])) {
                  const ppg = l.value || 0;
                  if (ppg >= 16) {
                    const ref = l.athlete?.$ref || '';
                    teamResult.stars.push({ ppg: Math.round(ppg * 10) / 10, ref, team: team.abbr, teamId: team.id });
                  }
                }
                break;
              }
            }
          }
        } catch(e) { /* skip */ }

        // Fetch team statistics for 3PT season average
        try {
          const sUrl = `https://sports.core.api.espn.com/v2/sports/basketball/leagues/mens-college-basketball/seasons/2026/types/2/teams/${team.id}/statistics`;
          const sResp = await fetch(sUrl);
          if (sResp.ok) {
            const sData = await sResp.json();
            for (const cat of (sData.splits?.categories || [])) {
              for (const stat of (cat.stats || [])) {
                if (stat.name === 'threePointFieldGoalPct') {
                  teamResult.fg3Pct = parseFloat(stat.value) || null;
                }
              }
            }
          }
        } catch(e) { /* skip */ }

        return teamResult;
      }));

      for (const r of results) {
        if (r.status !== 'fulfilled' || !r.value) continue;
        candidates.push(...r.value.stars);
        if (r.value.fg3Pct !== null) {
          team3pt[r.value.abbr] = Math.round(r.value.fg3Pct * 10) / 10;
        }
      }
    }

    if (statusEl) statusEl.textContent = `Resolving ${candidates.length} star names...`;

    // Step 3: Resolve athlete names
    const stars = [];
    for (let i = 0; i < candidates.length; i += batchSize) {
      const batch = candidates.slice(i, i + batchSize);
      const promises = batch.map(async (cand) => {
        try {
          if (!cand.ref) return cand;
          const resp = await fetch(cand.ref);
          if (!resp.ok) return cand;
          const ath = await resp.json();
          cand.name = ath.displayName || '?';
          cand.id = ath.id || '';
          return cand;
        } catch { return cand; }
      });
      const resolved = await Promise.all(promises);
      stars.push(...resolved.filter(s => s.name));
    }

    // Save stars
    ncaaStarCache = stars;
    ncaaStarCacheTime = Date.now();
    localStorage.setItem('ncaaStarCache', JSON.stringify(stars));
    localStorage.setItem('ncaaStarCacheTime', String(ncaaStarCacheTime));
    // Save team 3PT averages
    ncaaTeam3ptCache = team3pt;
    localStorage.setItem('ncaaTeam3ptCache', JSON.stringify(team3pt));
    console.log('[NCAA] Full DB built:', stars.length, 'stars,', Object.keys(team3pt).length, 'team 3PT avgs');
    if (statusEl) statusEl.textContent = `${stars.length} stars, ${Object.keys(team3pt).length} team 3PT avgs`;
    setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 5000);
  } catch (e) {
    console.warn('[NCAA] Build error:', e);
    if (statusEl) statusEl.textContent = 'DB error  using fallback';
  } finally {
    ncaaStarBuildInProgress = false;
  }
}

function switchMode(mode) {
  currentMode = mode;
  localStorage.setItem('alphaMode', mode);
  // Update UI labels
  const subtitle = document.getElementById('main-subtitle');
  if (subtitle) subtitle.innerHTML = mode === 'ncaab' ? 'NCAAB &bull; DATA-DRIVEN ANALYTICS' : 'NBA &bull; DATA-DRIVEN ANALYTICS';
  const modeBtn = document.getElementById('modeToggleBtn');
  if (modeBtn) modeBtn.textContent = mode === 'ncaab' ? 'NCAAB' : 'NBA';
  const starCol = document.getElementById('star-col-q1');
  if (starCol) starCol.textContent = mode === 'ncaab' ? 'H1 Pace' : 'Q1 Pace';
  const starTitle = document.getElementById('star-db-title');
  if (starTitle) starTitle.textContent = mode === 'ncaab' ? 'Star Player Database (16+ PPG)' : 'Star Player Database (21+ PPG)';
  const starSub = document.getElementById('star-db-subtitle');
  if (starSub) starSub.textContent = mode === 'ncaab' ? 'Signal: <65% pace, 8-35 min, margin 12' : 'Signal: <65% of expected pace';
  // Swap star database
  if (mode === 'ncaab') {
    // Save current NBA stars if switching away
    if (!state._nbaStars) state._nbaStars = DEFAULT_STARS;
    // Load NCAA stars from cache or empty
    state.stars = ncaaStarCache.length > 0 ? ncaaStarCache.map(s => ({name:s.name,team:s.team,ppg:s.ppg})) : [];
  } else {
    // Restore NBA stars
    state.stars = state._nbaStars || DEFAULT_STARS;
  }
  renderStarDB();
  // Update Signal Guide for current mode
  updateSignalGuide(mode);
  // Reset caches for fresh data
  teamScorerCache = {}; teamScorerLastFetch = 0;
  oddsCache = {}; oddsCacheTime = 0;
  state.scoreHistory = {};
  state.lastKnownPeriods = {};
  state.prevTeamData = {};
  // Build NCAA star database BEFORE fetching games
  if (mode === 'ncaab') {
    buildNcaaStarDB().then(() => {
      // Update stars after build completes
      if (ncaaStarCache.length > 0) {
        state.stars = ncaaStarCache.map(s => ({name:s.name,team:s.team,ppg:s.ppg}));
        renderStarDB();
      }
      fetchESPNScoreboard();
    });
  } else {
    fetchESPNScoreboard();
  }
}

// === LIVE ODDS (The Odds API) ===
let oddsCache={};let oddsCacheTime=0;const ODDS_CACHE_TTL=120000;
let oddsRequestCount=parseInt(localStorage.getItem('oddsReqCount')||'0');
let oddsReqMonth=localStorage.getItem('oddsReqMonth')||'';
function getOddsSport(){return isNCAA() ? 'basketball_ncaab' : 'basketball_nba';}
function impliedProb(am){const n=parseInt(am);if(n<0)return(Math.abs(n)/(Math.abs(n)+100)*100).toFixed(1);return(100/(n+100)*100).toFixed(1);}
function oddsClass(am){const n=parseInt(am);if(n<=-150)return'fav';if(n>=150)return'dog';return'even';}
async function fetchLiveOdds(){
  const now=Date.now();
  if(now-oddsCacheTime<ODDS_CACHE_TTL&&Object.keys(oddsCache).length>0)return oddsCache;
  const curMonth=new Date().toISOString().slice(0,7);
  if(oddsReqMonth!==curMonth){oddsRequestCount=0;oddsReqMonth=curMonth;}
  if(oddsRequestCount>=480){console.warn('Odds API near limit');return oddsCache;}
  try{
    const sport=getOddsSport();
    const resp=await fetch('https://api.the-odds-api.com/v4/sports/'+sport+'/odds/?apiK'+'ey=4ca2c6a2ed9e162809eb03722e2dc734&regions=us&markets=h2h,totals&oddsFormat=american&bookmakers=fanduel,draftkings,betmgm');
    if(!resp.ok){console.warn('Odds API:',resp.status);return oddsCache;}
    const data=await resp.json();
    oddsRequestCount++;
    localStorage.setItem('oddsReqCount',oddsRequestCount.toString());
    localStorage.setItem('oddsReqMonth',curMonth);
    const remaining=resp.headers.get('x-requests-remaining');
    const el=document.getElementById('odds-status');
    if(el)el.textContent='Odds: '+(remaining||'?')+' calls left';
    const nc={};
    for(const g of data){
      // Find h2h from any bookmaker
      let homeML=null,awayML=null,bookName='';
      for(const bk of (g.bookmakers||[])){
        const mk=bk.markets?.find(m=>m.key==='h2h');
        if(mk){
          const ho=mk.outcomes?.find(o=>o.name===g.home_team);
          const ao=mk.outcomes?.find(o=>o.name===g.away_team);
          if(ho&&ao){homeML=ho.price;awayML=ao.price;bookName=bk.title;break;}
        }
      }
      if(homeML===null||awayML===null)continue;
      // Find totals from ANY bookmaker (not just the first one)
      let ouLine=null,overPrice=null,underPrice=null;
      for(const bk of (g.bookmakers||[])){
        const totMkt=bk.markets?.find(m=>m.key==='totals');
        if(totMkt){
          const overO=totMkt.outcomes?.find(o=>o.name==='Over');
          const underO=totMkt.outcomes?.find(o=>o.name==='Under');
          if(overO){ouLine=overO.point;overPrice=overO.price;}
          if(underO){underPrice=underO.price;if(!ouLine)ouLine=underO.point;}
          if(ouLine)break; // found it, stop searching
        }
      }
      nc[g.away_team+' vs '+g.home_team]={home:g.home_team,away:g.away_team,homeML,awayML,book:bookName,ouLine,overPrice,underPrice};
    }
    oddsCache=nc;oddsCacheTime=now;
    // Record odds history for LEC (Live Edge Captured) tracking
    const ts = Date.now();
    for (const k of Object.keys(nc)) {
      if (!state.oddsHistory[k]) state.oddsHistory[k] = [];
      const hist = state.oddsHistory[k];
      // Only record if odds changed or >60s since last snapshot
      if (hist.length === 0 || ts - hist[hist.length-1].ts > 60000) {
        hist.push({ ts, homeML: nc[k].homeML, awayML: nc[k].awayML });
        if (hist.length > 50) hist.splice(0, hist.length - 50); // keep last 50 snapshots
      }
    }
    // Prune stale game keys (>24h old)
    for (const k of Object.keys(state.oddsHistory)) {
      const h = state.oddsHistory[k];
      if (h.length > 0 && ts - h[h.length-1].ts > 86400000) delete state.oddsHistory[k];
    }
    localStorage.setItem('oddsHistory', JSON.stringify(state.oddsHistory));
    // Update LEC on any active signals
    updateLEC();
    return nc;
  }catch(e){console.warn('Odds error:',e);return oddsCache;}
}
// === LIVE EDGE CAPTURED (LEC) ===
// Tracks whether the line moved in your favor after signal entry.
// LEC > 0 = you captured edge (line moved your way). LEC < 0 = you paid a premium.
function updateLEC() {
  const now = Date.now();
  let changed = false;
  for (const sig of state.signalTracker) {
    if (sig.gameCompleted) continue;
    if (!sig.entryOddsKey) continue; // no odds key recorded
    const hist = state.oddsHistory[sig.entryOddsKey];
    if (!hist || hist.length === 0) continue;
    const entryTs = sig.timestamp;
    const sigIsAway = sig.signalSide === sig.awayTeam;
    const entryML = sig.marketOdds;
    // Find odds ~5 min after entry
    if (!sig.lec5minOdds && (now - entryTs) >= 300000) {
      const snap5 = hist.find(h => h.ts >= entryTs + 240000 && h.ts <= entryTs + 420000);
      if (snap5) {
        const postML = sigIsAway ? snap5.awayML : snap5.homeML;
        sig.lec5minOdds = postML;
        sig.lec5min = entryML - postML; // positive = line moved in your favor (you got better odds)
        changed = true;
      }
    }
    // Find odds ~10 min after entry
    if (!sig.lec10minOdds && (now - entryTs) >= 600000) {
      const snap10 = hist.find(h => h.ts >= entryTs + 540000 && h.ts <= entryTs + 720000);
      if (snap10) {
        const postML = sigIsAway ? snap10.awayML : snap10.homeML;
        sig.lec10minOdds = postML;
        sig.lec10min = entryML - postML;
        changed = true;
      }
    }
  }
  if (changed) {
    localStorage.setItem('signalTracker', JSON.stringify(state.signalTracker));
  }
}

function matchOdds(aAbbr,hAbbr,aFull,hFull){
  // Strategy 1: Exact full-name match (most reliable)
  for(const k of Object.keys(oddsCache)){
    const g=oddsCache[k];
    if(!g.home||!g.away)continue;
    if(g.home.toUpperCase()===hFull.toUpperCase()&&g.away.toUpperCase()===aFull.toUpperCase())return g;
  }
  // Strategy 2: Full name contains (one direction)  require BOTH teams match
  for(const k of Object.keys(oddsCache)){
    const g=oddsCache[k];
    if(!g.home||!g.away)continue;
    const gH=g.home.toUpperCase(),gA=g.away.toUpperCase();
    const hUp=hFull.toUpperCase(),aUp=aFull.toUpperCase();
    // Check if ESPN name is contained in Odds API name or vice versa
    const hM=gH.includes(hUp)||hUp.includes(gH);
    const aM=gA.includes(aUp)||aUp.includes(gA);
    if(hM&&aM)return g;
  }
  // Strategy 3: Match on BOTH first word AND last word (prevents Alabama vs Alabama A&M)
  for(const k of Object.keys(oddsCache)){
    const g=oddsCache[k];
    if(!g.home||!g.away)continue;
    const gHW=g.home.toUpperCase().split(' '),gAW=g.away.toUpperCase().split(' ');
    const hW=hFull.toUpperCase().split(' '),aW=aFull.toUpperCase().split(' ');
    const hFirst=hW[0],hLast=hW[hW.length-1],aFirst=aW[0],aLast=aW[aW.length-1];
    const gHFirst=gHW[0],gHLast=gHW[gHW.length-1],gAFirst=gAW[0],gALast=gAW[gAW.length-1];
    const hM=(gHFirst===hFirst&&gHLast===hLast)||(gHW.includes(hAbbr));
    const aM=(gAFirst===aFirst&&gALast===aLast)||(gAW.includes(aAbbr));
    if(hM&&aM)return g;
  }
  return null;
}
function buildOddsHTML(aAbbr,hAbbr,aFull,hFull){const o=matchOdds(aAbbr,hAbbr,aFull,hFull);if(!o)return'';const aML=(o.awayML>0?'+':'')+o.awayML;const hML=(o.homeML>0?'+':'')+o.homeML;return'<div class="odds-row"><span><span class="odds-label">'+aAbbr+' ML</span> <span class="odds-val '+oddsClass(aML)+'">'+aML+'</span> <span class="odds-implied">('+impliedProb(aML)+'%)</span></span><span class="odds-src">'+o.book+'</span><span><span class="odds-implied">('+impliedProb(hML)+'%)</span> <span class="odds-val '+oddsClass(hML)+'">'+hML+'</span> <span class="odds-label">'+hAbbr+' ML</span></span></div>';}

function getESPNUrl(){return isNCAA() ? 'https://site.api.espn.com/apis/site/v2/sports/basketball/mens-college-basketball/scoreboard' : 'https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard';}

// ==================== STAR DATABASE (23+ PPG) ====================
const DEFAULT_STARS = [
  { name: "Luka Doncic", team: "LAL", ppg: 32.5 },
  { name: "Shai Gilgeous-Alexander", team: "OKC", ppg: 31.8 },
  { name: "Anthony Edwards", team: "MIN", ppg: 29.6 },
  { name: "Jaylen Brown", team: "BOS", ppg: 29.2 },
  { name: "Tyrese Maxey", team: "PHI", ppg: 29.1 },
  { name: "Nikola Jokic", team: "DEN", ppg: 28.8 },
  { name: "Donovan Mitchell", team: "CLE", ppg: 28.5 },
  { name: "Kawhi Leonard", team: "LAC", ppg: 28.0 },
  { name: "Lauri Markkanen", team: "UTA", ppg: 26.7 },
  { name: "Jalen Brunson", team: "NYK", ppg: 26.7 },
  { name: "Kevin Durant", team: "HOU", ppg: 25.9 },
  { name: "Jamal Murray", team: "DEN", ppg: 25.5 },
  { name: "Cade Cunningham", team: "DET", ppg: 25.3 },
  { name: "Devin Booker", team: "PHX", ppg: 24.7 },
  { name: "Michael Porter Jr.", team: "BKN", ppg: 24.6 },
  { name: "James Harden", team: "LAC", ppg: 24.5 },
  { name: "Deni Avdija", team: "POR", ppg: 24.4 },
  { name: "Victor Wembanyama", team: "SAS", ppg: 24.2 },
  { name: "Pascal Siakam", team: "IND", ppg: 23.9 },
  { name: "Keyonte George", team: "UTA", ppg: 23.8 },
  { name: "Jalen Johnson", team: "ATL", ppg: 23.0 },
  { name: "Norman Powell", team: "MIA", ppg: 22.9 },
  { name: "Trey Murphy III", team: "NOP", ppg: 21.9 },
  { name: "Julius Randle", team: "MIN", ppg: 21.9 },
  { name: "Zion Williamson", team: "NOP", ppg: 21.8 },
];

const TEAM_MAP = {
  'Atlanta Hawks':'ATL','Boston Celtics':'BOS','Brooklyn Nets':'BKN','Charlotte Hornets':'CHA',
  'Chicago Bulls':'CHI','Cleveland Cavaliers':'CLE','Dallas Mavericks':'DAL','Denver Nuggets':'DEN',
  'Detroit Pistons':'DET','Golden State Warriors':'GSW','Houston Rockets':'HOU','Indiana Pacers':'IND',
  'LA Clippers':'LAC','Los Angeles Clippers':'LAC','Los Angeles Lakers':'LAL','Memphis Grizzlies':'MEM',
  'Miami Heat':'MIA','Milwaukee Bucks':'MIL','Minnesota Timberwolves':'MIN','New Orleans Pelicans':'NOP',
  'New York Knicks':'NYK','Oklahoma City Thunder':'OKC','Orlando Magic':'ORL','Philadelphia 76ers':'PHI',
  'Phoenix Suns':'PHX','Portland Trail Blazers':'POR','Sacramento Kings':'SAC','San Antonio Spurs':'SAS',
  'Toronto Raptors':'TOR','Utah Jazz':'UTA','Washington Wizards':'WAS',
};
function shortName(n) { return TEAM_MAP[n] || n.split(' ').pop().substring(0,3).toUpperCase(); }
function teamDisplay(abbr, fullName) { return abbr; }
function teamDisplayShort(abbr, fullName) { return abbr; }
function teamLogoImg(logoUrl, size) { if (!logoUrl) return ''; return `<img src="${logoUrl}" alt="" onerror="this.style.display='none'" style="width:${size||20}px;height:${size||20}px;object-fit:contain;vertical-align:middle;">`; }
function gameLinksHTML(espnLink, leaguePassLink) {
  let links = [];
  if (espnLink) links.push(`<a href="${espnLink}" target="_blank" class="watch-link">ESPN</a>`);
  if (leaguePassLink) links.push(`<a href="${leaguePassLink}" target="_blank" class="watch-link">League Pass</a>`);
  if (!isNCAA()) links.push(`<a href="https://sports.qq.com/nba/" target="_blank" class="watch-link">WATCH </a>`);
  return links.length ? `<div class="game-links">${links.join('')}</div>` : '';
}

// ==================== STATE ====================
let state = {
  betLog: JSON.parse(localStorage.getItem('betLog') || '[]'),
  bankroll: JSON.parse(localStorage.getItem('bankroll') || '{"start":0,"current":0}'),
  stars: JSON.parse(localStorage.getItem('starPlayers') || 'null') || DEFAULT_STARS,
  autoRefresh: false, refreshTimer: null, countdownTimer: null,
  quarterAlerts: JSON.parse(localStorage.getItem('quarterAlerts') || '[]'),
  lastKnownPeriods: {}, prevTeamData: {},
  scoreHistory: {},  // { gameId: [ {ts, aS, hS}, ... ] }  tracks score over time for momentum
  errorCount: 0, consecutiveErrors: 0,
  signalFirstSeen: {},
  favorites: JSON.parse(localStorage.getItem('favorites') || '[]'),
  signalHistory: JSON.parse(localStorage.getItem('signalHistory') || '[]'),
  signalTracker: JSON.parse(localStorage.getItem('signalTracker') || '[]'),
  oddsHistory: JSON.parse(localStorage.getItem('oddsHistory') || '{}'), // { gameKey: [{ts, homeML, awayML}, ...] }
  nearMisses: JSON.parse(localStorage.getItem('nearMisses') || '[]'), // counterfactual: level-1 signals
};

// ==================== INIT ====================
const _bsEl = document.getElementById('bankroll-start');
const _bcEl = document.getElementById('bankroll-current');
if (_bsEl) _bsEl.value = state.bankroll.start || '';
if (_bcEl) _bcEl.value = state.bankroll.current || '';
renderBetLog(); renderStarDB(); renderQtrAlerts(); loadBankrollSettings();

// ==================== TEAM PROFILES CACHE ====================
// Full team data: record, standing, streak + offense/defense stats from ESPN statistics API
let teamProfileCache = {};
let teamProfileLastFetch = 0;
let _teamProfileMode = ''; // track mode changes

// Top 3 scorers per team by season PPG  { teamAbbr: [{name, ppg}] }
let teamScorerCache = {};
let teamScorerLastFetch = 0;
async function fetchTeamScorers() {
  const now = Date.now();
  if (now - teamScorerLastFetch < 60 * 60 * 1000 && Object.keys(teamScorerCache).length > 0) return;
  if (isNCAA()) {
    // NCAA: build from ncaaStarCache (already fetched per-team leaders)
    const byTeam = {};
    ncaaStarCache.forEach(s => {
      if (!byTeam[s.team]) byTeam[s.team] = [];
      byTeam[s.team].push({ name: s.name, ppg: s.ppg });
    });
    for (const t in byTeam) {
      byTeam[t].sort((a, b) => b.ppg - a.ppg);
      byTeam[t] = byTeam[t].slice(0, 3);
    }
    teamScorerCache = byTeam;
    teamScorerLastFetch = now;
    console.log(`[TeamScorers] NCAA: Cached top 3 scorers for ${Object.keys(byTeam).length} teams from ncaaStarCache`);
    return;
  }
  try {
    const res = await fetch('https://site.web.api.espn.com/apis/common/v3/sports/basketball/nba/statistics/byathlete?season=2025&limit=500&sort=offensive.avgPoints', { signal: AbortSignal.timeout(8000) });
    if (!res.ok) return;
    const data = await res.json();
    const byTeam = {};
    (data.athletes || []).forEach(a => {
      const name = a.athlete?.displayName || '';
      const team = a.athlete?.teamShortName || '';
      const ppg = parseFloat(a.categories?.[1]?.values?.[0]) || 0;
      if (!name || !team || ppg <= 0) return;
      if (!byTeam[team]) byTeam[team] = [];
      byTeam[team].push({ name, ppg });
    });
    for (const t in byTeam) {
      byTeam[t].sort((a, b) => b.ppg - a.ppg);
      byTeam[t] = byTeam[t].slice(0, 3);
    }
    teamScorerCache = byTeam;
    teamScorerLastFetch = now;
    console.log(`[TeamScorers] NBA: Cached top 3 scorers for ${Object.keys(byTeam).length} teams`);
  } catch (e) {
    console.warn('[TeamScorers] Fetch error:', e);
  }
}

async function fetchTeamProfiles() {
  const now = Date.now();
  const mode = isNCAA() ? 'ncaab' : 'nba';
  // Refresh every 30 min, or immediately if mode changed
  if (mode === _teamProfileMode && now - teamProfileLastFetch < 30 * 60 * 1000 && Object.keys(teamProfileCache).length > 0) return;
  _teamProfileMode = mode;
  try {
    const league = isNCAA() ? 'mens-college-basketball' : 'nba';

    // Step 1: Get team IDs. NBA: all 30. NCAA: today's scoreboard teams.
    let teamIds = [];
    if (isNCAA()) {
      const sbRes = await fetch(`https://site.api.espn.com/apis/site/v2/sports/basketball/${league}/scoreboard`);
      if (!sbRes.ok) return;
      const sbData = await sbRes.json();
      const idSet = new Set();
      for (const ev of (sbData.events || [])) {
        for (const c of (ev.competitions?.[0]?.competitors || [])) {
          if (c.team?.id) idSet.add(c.team.id);
        }
      }
      teamIds = [...idSet];
    } else {
      teamIds = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30];
    }

    // Step 2: Fetch team info + statistics in parallel
    const teamFetches = teamIds.map(id =>
      fetch(`https://site.api.espn.com/apis/site/v2/sports/basketball/${league}/teams/${id}`)
        .then(r => r.ok ? r.json() : null).catch(() => null)
    );
    const statFetches = teamIds.map(id =>
      fetch(`https://site.api.espn.com/apis/site/v2/sports/basketball/${league}/teams/${id}/statistics`)
        .then(r => r.ok ? r.json() : null).catch(() => null)
    );
    const [teamResults, statResults] = await Promise.all([
      Promise.all(teamFetches),
      Promise.all(statFetches)
    ]);

    for (let i = 0; i < teamIds.length; i++) {
      const tData = teamResults[i];
      const sData = statResults[i];
      if (!tData?.team) continue;
      parseTeamProfile(tData.team, sData);
    }

    teamProfileLastFetch = now;
    console.log(`[TeamProfiles] Cached ${Object.keys(teamProfileCache).length} teams with full stats`);
  } catch (e) {
    console.warn('[TeamProfiles] Fetch error:', e);
  }
}

function parseTeamProfile(team, statsData) {
  const abbr = team.abbreviation;
  if (!abbr) return;
  const rec = team.record || {};
  const items = rec.items || [];
  const total = items.find(i => i.type === 'total') || {};
  const home = items.find(i => i.type === 'home') || {};
  const road = items.find(i => i.type === 'road') || {};
  const getStat = (item, name) => { const s = (item.stats || []).find(x => x.name === name); return s ? s.value : null; };

  // Parse statistics categories
  const cats = statsData?.results?.stats?.categories || [];
  const offCat = cats.find(c => c.displayName === 'Offensive') || {};
  const defCat = cats.find(c => c.displayName === 'Defensive') || {};
  const genCat = cats.find(c => c.displayName === 'General') || {};
  const getS = (cat, name) => { const s = (cat.stats || []).find(x => x.name === name); return s ? parseFloat(s.displayValue) : null; };

  teamProfileCache[abbr] = {
    // Record
    seed: getStat(total, 'playoffSeed'),
    standing: team.standingSummary || '',
    streak: getStat(total, 'streak'),
    ppg: getStat(total, 'avgPointsFor'),
    oppg: getStat(total, 'avgPointsAgainst'),
    diff: getStat(total, 'differential'),
    homeRec: home.summary || '',
    roadRec: road.summary || '',
    winPct: getStat(total, 'winPercent'),
    // Offense
    fgPct: getS(offCat, 'fieldGoalPct'),
    threePct: getS(offCat, 'threePointPct') || getS(offCat, 'threePointFieldGoalPct'),
    ftPct: getS(offCat, 'freeThrowPct'),
    avgPts: getS(offCat, 'avgPoints'),
    avg3PM: getS(offCat, 'avgThreePointFieldGoalsMade'),
    avg3PA: getS(offCat, 'avgThreePointFieldGoalsAttempted'),
    avgAst: getS(offCat, 'avgAssists'),
    avgTO: getS(offCat, 'avgTurnovers'),
    avgOReb: getS(offCat, 'avgOffensiveRebounds'),
    avgFTM: getS(offCat, 'avgFreeThrowsMade'),
    avgFTA: getS(offCat, 'avgFreeThrowsAttempted'),
    // Defense
    avgDReb: getS(defCat, 'avgDefensiveRebounds'),
    avgBlk: getS(defCat, 'avgBlocks'),
    avgStl: getS(defCat, 'avgSteals'),
    // General
    avgReb: getS(genCat, 'avgRebounds'),
    astToRatio: getS(genCat, 'assistTurnoverRatio'),
    avgFouls: getS(genCat, 'avgFouls'),
  };
}

function teamProfileHTML(abbr, homeAway, logoUrl) {
  const p = teamProfileCache[abbr];
  if (!p) return '';
  const streakStr = p.streak != null ? (p.streak > 0 ? 'W' + Math.round(p.streak) : 'L' + Math.abs(Math.round(p.streak))) : '';
  const streakColor = p.streak > 0 ? 'var(--green)' : 'var(--red)';
  const seedStr = p.seed != null ? '#' + Math.round(p.seed) : '';
  const ctxRec = homeAway === 'home' ? (p.homeRec || '') : (p.roadRec || '');

  const chips = [];
  if (seedStr) chips.push(`<span style="font-weight:700;color:var(--accent);">${seedStr}</span>`);
  if (ctxRec) chips.push(`<span>${homeAway === 'home' ? 'H' : 'R'}:${ctxRec}</span>`);
  if (streakStr) chips.push(`<span style="font-weight:700;color:${streakColor};">${streakStr}</span>`);

  return `<div style="font-size:9px;color:var(--text-muted);margin-top:1px;">
    <span class="tp-inline" onclick="openTeamProfile('${abbr}','${homeAway}','${(logoUrl||'').replace(/'/g,'')}')">${chips.join(' <span style="opacity:0.4;"></span> ')}</span>
  </div>`;
}

function openTeamProfile(abbr, homeAway, logoUrl) {
  const p = teamProfileCache[abbr];
  if (!p) return;
  const diff = p.diff != null ? (p.diff > 0 ? '+' + p.diff.toFixed(1) : p.diff.toFixed(1)) : '';
  const diffColor = p.diff > 0 ? 'var(--green)' : p.diff < 0 ? 'var(--red)' : 'var(--text-muted)';

  const row = (label, val, color) => `<div class="tp-row"><span class="tp-label">${label}</span><span class="tp-val"${color ? ' style="color:'+color+'"' : ''}>${val}</span></div>`;

  let html = `<div class="tp-modal">
    <div class="tp-modal-header">
      <h3>${logoUrl ? '<img src="'+logoUrl+'" style="width:24px;height:24px;object-fit:contain;">' : ''}${abbr}</h3>
      <button class="tp-modal-close" onclick="this.closest('.tp-modal-overlay').classList.remove('active')">&times;</button>
    </div>`;

  if (p.standing) html += `<div style="font-size:11px;color:var(--accent);font-weight:600;margin-bottom:8px;">${p.standing}</div>`;

  // Record
  html += `<div class="tp-section"><div class="tp-section-title">Record</div>`;
  if (p.homeRec) html += row('Home', p.homeRec);
  if (p.roadRec) html += row('Road', p.roadRec);
  if (p.diff != null) html += row('Point Diff', diff, diffColor);
  html += `</div>`;

  // Offense
  html += `<div class="tp-section"><div class="tp-section-title">Offense</div>`;
  if (p.avgPts != null) html += row('PPG', p.avgPts);
  if (p.fgPct != null) html += row('FG%', p.fgPct + '%');
  if (p.threePct != null) html += row('3PT%', p.threePct + '%' + (p.avg3PM != null ? ' (' + p.avg3PM.toFixed(1) + '/' + p.avg3PA.toFixed(1) + ')' : ''));
  if (p.ftPct != null) html += row('FT%', p.ftPct + '%');
  if (p.avgAst != null) html += row('Assists', p.avgAst);
  if (p.avgTO != null) html += row('Turnovers', p.avgTO);
  if (p.astToRatio != null) html += row('AST/TO', p.astToRatio);
  html += `</div>`;

  // Defense
  html += `<div class="tp-section"><div class="tp-section-title">Defense</div>`;
  if (p.oppg != null) html += row('Opp PPG', p.oppg.toFixed(1));
  if (p.avgReb != null) html += row('Rebounds', p.avgReb);
  if (p.avgOReb != null) html += row('Off Reb', p.avgOReb);
  if (p.avgDReb != null) html += row('Def Reb', p.avgDReb);
  if (p.avgStl != null) html += row('Steals', p.avgStl);
  if (p.avgBlk != null) html += row('Blocks', p.avgBlk);
  html += `</div>`;

  // General
  html += `<div class="tp-section"><div class="tp-section-title">General</div>`;
  if (p.avgFouls != null) html += row('Fouls/Game', p.avgFouls);
  if (p.avgReb != null) html += row('Total Reb', p.avgReb);
  html += `</div></div>`;

  // Create or reuse overlay
  let overlay = document.getElementById('tp-modal-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'tp-modal-overlay';
    overlay.className = 'tp-modal-overlay';
    overlay.addEventListener('click', function(e) { if (e.target === overlay) overlay.classList.remove('active'); });
    document.body.appendChild(overlay);
  }
  overlay.innerHTML = html;
  overlay.classList.add('active');
}

// Kill browser notifications permanently  we use in-app toasts only
if (window.Notification) { window.Notification = function(){}; window.Notification.permission = 'denied'; window.Notification.requestPermission = function(){ return Promise.resolve('denied'); }; }

// In-app toast notification system
let notifiedSignals = new Set(JSON.parse(localStorage.getItem('notifiedSignals') || '[]'));
function sendSignalNotification(title, body, gameId, signalType) {
  // No popups  signals show on chips and game cards only
  const key = gameId + '_' + signalType + '_' + new Date().getHours();
  if (notifiedSignals.has(key)) return;
  notifiedSignals.add(key);
  if (notifiedSignals.size > 200) notifiedSignals = new Set([...notifiedSignals].slice(-100));
  localStorage.setItem('notifiedSignals', JSON.stringify([...notifiedSignals]));
  // Play pleasant chime for new signals
  if (signalType.startsWith('star_')) playAlertSound('coil');
  else if (signalType.startsWith('3ptfragile')) playAlertSound('hot3pt');
}

// ==================== TABS ====================
function switchTab(t) {
  document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(x => x.classList.remove('active'));
  document.getElementById('tab-'+t).classList.add('active');
  document.getElementById('content-'+t).classList.add('active');
}

// ==================== SIGNAL CHIP CLICK-TO-EXPAND ====================
function toggleSignalDetail(type) {
  const panel = document.getElementById('chip-detail-' + type);
  if (!panel) return;

  // Close all other panels first
  document.querySelectorAll('.chip-detail-panel.active').forEach(p => {
    if (p.id !== 'chip-detail-' + type) p.classList.remove('active');
  });

  // Toggle this panel
  const isOpen = panel.classList.contains('active');
  if (isOpen) {
    panel.classList.remove('active');
    return;
  }

  // Build panel content from stored signal games
  const games = window._signalGames ? window._signalGames[type] : [];
  const labels = { '3ptfragile': '3PT Fragile', 'star': 'Star Coil', 'combined': 'Combined Edge' };

  if (!games || games.length === 0) {
    panel.innerHTML = `<div class="chip-detail-header">${labels[type] || type} Games</div><div class="chip-detail-empty">No active ${labels[type] || ''} signals right now</div>`;
  } else {
    const periodLabel = (per) => isNCAA() ? (per <= 2 ? `H${per}` : `OT${per-2}`) : `Q${per}`;
    panel.innerHTML = `<div class="chip-detail-header">${labels[type] || type}  ${games.length} game${games.length>1?'s':''}</div>` +
      games.map(g => {
        const truncDetail = g.sigDetail && g.sigDetail.length > 120 ? g.sigDetail.substring(0, 120) + '...' : (g.sigDetail || '');
        const eid = g.eventId || '';
        return `<div class="chip-detail-item chip-detail-clickable" onclick="scrollToGame('${eid}')" title="Click to jump to game">
          <div class="chip-detail-game">${g.gameFull || g.game} <span style="font-size:9px;color:var(--accent);margin-left:4px;"> go</span></div>
          <div class="chip-detail-score">${g.aScore} - ${g.hScore} | ${periodLabel(g.per)} ${g.clk}</div>
          <div class="chip-detail-sig">${truncDetail}</div>
        </div>`;
      }).join('');
  }

  panel.classList.add('active');
}

// Scroll to a game card when clicking from signal dropdown
function scrollToGame(eventId) {
  if (!eventId) return;
  // Close all chip detail panels
  document.querySelectorAll('.chip-detail-panel.active').forEach(p => p.classList.remove('active'));
  // Find the game card
  const card = document.querySelector(`.game-card[data-game-id="${eventId}"]`);
  if (card) {
    // Smooth scroll to the card
    card.scrollIntoView({ behavior: 'smooth', block: 'center' });
    // Flash highlight effect
    card.classList.add('signal-highlight-flash');
    setTimeout(() => card.classList.remove('signal-highlight-flash'), 2500);
  }
}

// Close signal detail panels when clicking outside
document.addEventListener('click', function(e) {
  if (!e.target.closest('.signal-chip-clickable')) {
    document.querySelectorAll('.chip-detail-panel.active').forEach(p => p.classList.remove('active'));
  }
});

// ==================== AUTO REFRESH ====================
function toggleAutoRefresh() {
  state.autoRefresh = !state.autoRefresh;
  const btn = document.getElementById('autoRefreshBtn'), dot = document.getElementById('autoRefreshDot'), lbl = document.getElementById('autoRefreshLabel');
  if (state.autoRefresh) {
    btn.textContent = 'Stop'; btn.className = 'btn btn-sm btn-red'; dot.className = 'dot'; lbl.textContent = 'ON';
    document.getElementById('liveIndicator').style.display = 'inline-flex';
    fetchESPNScoreboard(); startCountdown();
  } else {
    btn.textContent = 'Start'; btn.className = 'btn btn-sm btn-green'; dot.className = 'dot off'; lbl.textContent = 'OFF';
    document.getElementById('liveIndicator').style.display = 'none';
    clearInterval(state.refreshTimer); clearInterval(state.countdownTimer);
    if (_bgWorker) { _bgWorker.postMessage({ cmd: 'stop' }); _bgWorker.terminate(); _bgWorker = null; }
    document.getElementById('countdownFill').style.width = '100%';
  }
}
// === BACKGROUND-SAFE TIMER ===
// Browsers throttle setInterval in background tabs (60s+ delay).
// Use a Web Worker blob to keep the timer alive even when tab is hidden.
let _bgWorker = null;
function _createBgWorker() {
  if (_bgWorker) _bgWorker.terminate();
  try {
    const blob = new Blob([`
      let iv = 30000;
      let tid = null;
      self.onmessage = function(e) {
        if (e.data.cmd === 'start') { iv = e.data.interval || 30000; clearInterval(tid); tid = setInterval(()=>self.postMessage('tick'), iv); self.postMessage('tick'); }
        if (e.data.cmd === 'stop') { clearInterval(tid); tid = null; }
      };
    `], { type: 'application/javascript' });
    _bgWorker = new Worker(URL.createObjectURL(blob));
    _bgWorker.onmessage = function() { if (state.autoRefresh) fetchESPNScoreboard(); };
    return true;
  } catch(e) { console.warn('[BG Worker] Not available, falling back to setInterval'); return false; }
}

function startCountdown() {
  const iv = parseInt(document.getElementById('refreshInterval').value) * 1000;
  let rem = iv;
  clearInterval(state.refreshTimer); clearInterval(state.countdownTimer);
  // Try Web Worker for background-safe timer; fall back to setInterval
  const workerOk = _createBgWorker();
  if (workerOk) {
    _bgWorker.postMessage({ cmd: 'start', interval: iv });
  } else {
    state.refreshTimer = setInterval(() => { if (state.autoRefresh) { fetchESPNScoreboard(); } }, iv);
  }
  state.countdownTimer = setInterval(() => { rem -= 1000; if (rem <= 0) rem = iv; document.getElementById('countdownFill').style.width = Math.max(0, rem/iv*100)+'%'; }, 1000);
}
function updateRefreshInterval() { if (state.autoRefresh) startCountdown(); }

// === VISIBILITY CHANGE  catch up when tab wakes up ===
document.addEventListener('visibilitychange', function() {
  if (document.visibilityState === 'visible' && state.autoRefresh) {
    console.log('[Visibility] Tab visible  immediate refresh to catch missed signals');
    fetchESPNScoreboard();
  }
});

// ==================== PACE HELPERS ====================
function getQ1Expected(ppg) { return ppg * 0.25; }
function getHalfExpected(ppg) { return ppg * 0.5; }
function getExpectedByTime(ppg, mins) { return ppg * (mins / getTotalGameMinutes()); }

// ==================== SIGNAL URGENCY ====================
function getUrgency(period, clock) {
  const gMins = getElapsedMinutes(period, clock);
  const pct = gMins / getTotalGameMinutes();
  if (pct < 0.30) return { level: 'DEVELOPING', mult: 0.70, pct, color: 'var(--text-muted)', icon: '' };
  if (pct < 0.60) return { level: 'PRIME', mult: 1.00, pct, color: 'var(--green)', icon: '' };
  if (pct < 0.85) return { level: 'ACT_NOW', mult: 0.85, pct, color: 'var(--orange)', icon: '' };
  return { level: 'CLOSING', mult: 0.50, pct, color: 'var(--red)', icon: '' };
}

// ==================== BET RECOMMENDATION ENGINE ====================
// Uses live margin + time remaining to decide: ML, Spread, or Watch
// Signal detection is unchanged  this only runs AFTER a signal fires
function getRecommendation(awayScore, homeScore, awayAbbr, homeAbbr, period, clock, signalLevel) {
  const margin = Math.abs(homeScore - awayScore);
  const tied = homeScore === awayScore;
  const trailingTeam = tied ? null : (awayScore < homeScore ? awayAbbr : homeAbbr);
  const leadingTeam = tied ? null : (awayScore < homeScore ? homeAbbr : awayAbbr);

  // Calculate time remaining (mode-aware: NBA 48min/4Q, NCAA 40min/2H)
  const _perLen = getPeriodLength();
  const clockMin = parseFloat(clock?.split(':')[0] || _perLen);
  const clockSec = parseFloat(clock?.split(':')[1] || 0);
  const gameMinElapsed = (period - 1) * _perLen + (_perLen - clockMin - clockSec / 60);
  const gameMinRemaining = Math.max(0, getTotalGameMinutes() - gameMinElapsed);

  // Default: WATCH
  let rec = { type: 'WATCH', side: null, spreadLine: '', units: 0, reasoning: '', margin: margin, minRemaining: Math.round(gameMinRemaining) };

  // OT or <3 min left  always WATCH
  if (period >= getOTPeriod()) {
    rec.reasoning = 'Overtime  too volatile for mean reversion plays.';
    return rec;
  }
  if (gameMinRemaining < 3) {
    rec.reasoning = 'Under 3 min remaining  not enough time for reversion.';
    return rec;
  }

  // Only generate actionable recs for strong signals (level 2)
  if (signalLevel < 2) {
    rec.reasoning = 'Developing signal  monitor, no action yet.';
    return rec;
  }

  // Determine base recommendation from margin
  let type, units;
  if (margin <= 5) {
    type = 'ML'; units = 1.5;
  } else if (margin <= 15) {
    type = 'SPREAD'; units = margin <= 10 ? 1.5 : 1;
  } else if (margin <= 20) {
    type = 'SPREAD'; units = 1;
  } else {
    // 21+ pts  too far gone
    rec.reasoning = `Down ${margin} pts  margin too large for mean reversion play.`;
    return rec;
  }

  // Time adjustment: <6 min remaining  downgrade one tier
  if (gameMinRemaining < 6) {
    if (type === 'ML') {
      type = 'SPREAD'; // ML  SPREAD
    } else if (margin > 15) {
      // cautious SPREAD  WATCH
      rec.reasoning = `Down ${margin} with only ${Math.round(gameMinRemaining)} min left  not enough time.`;
      return rec;
    }
    units = Math.min(units, 1); // cap units when time is short
  }

  // Build the recommendation
  const side = tied ? awayAbbr : trailingTeam; // if tied, pick away team as default
  const spreadLine = type === 'SPREAD' ? `+${margin}` : '';
  const timeStr = Math.round(gameMinRemaining);

  let reasoning = '';
  if (type === 'ML') {
    reasoning = `${side} only down ${margin} pts with ${timeStr} min left  close enough for ML.`;
    if (tied) reasoning = `Game tied with ${timeStr} min left  ML play.`;
  } else {
    reasoning = `${side} down ${margin} with ${timeStr} min left  take the spread for mean reversion.`;
    if (margin > 15) reasoning = `${side} down ${margin}  cautious spread play, large deficit.`;
  }

  rec = { type, side, spreadLine, units, reasoning, margin, minRemaining: timeStr };
  return rec;
}

// === TIME HELPERS (NBA / NCAA) ===
function getTotalGameMinutes() { return isNCAA() ? 40 : 48; }
function getPeriodLength() { return isNCAA() ? 20 : 12; }
function getRegulationPeriods() { return isNCAA() ? 2 : 4; }
function getOTPeriod() { return isNCAA() ? 3 : 5; }
function getElapsedMinutes(per, clk) {
  const perLen = getPeriodLength();
  const parts = (clk || '0:00').split(':');
  const cM = parseFloat(parts[0]) || 0;
  const cS = parseFloat(parts[1]) || 0;
  const clockRemaining = cM + cS / 60;
  return (per - 1) * perLen + (perLen - clockRemaining);
}
function getGamePct(per, clk) {
  return Math.min(getElapsedMinutes(per, clk) / getTotalGameMinutes(), 1);
}

// ==================== SCORE MOMENTUM / DAMAGE LOCKED ====================
// Tracks score snapshots over time to detect if a deficit is growing/stable (damage locked in)
// Anti-bias: requires minimum time span (not just snapshot count), score must change, game must be 15+ min in
function trackScoreMomentum(gameId, aS, hS) {
  if (!state.scoreHistory[gameId]) state.scoreHistory[gameId] = [];
  const hist = state.scoreHistory[gameId];
  const now = Date.now();
  // Only record if 25+ seconds since last snapshot (avoid duplicates from rapid refreshes)
  if (hist.length === 0 || (now - hist[hist.length-1].ts) >= 25000) {
    hist.push({ ts: now, aS, hS });
  }
  // Keep last 15 snapshots (~6-7 min of data at 30s intervals)
  if (hist.length > 15) hist.splice(0, hist.length - 15);
}

// Analyze if the score deficit for a given team is locked in (stable or growing)
// Anti-bias checks:
//   1. Minimum TIME SPAN between first & last snapshot (not just count)  avoids timeout/dead-ball bias
//   2. Score must have changed  avoids frozen-game false positives
//   3. Called only after 15+ game minutes (checked by caller via gMins)
// Returns: { locked, trend, deficitNow, deficitThen, deficitChange, snapshots, timeSpanSec, scoreChanged, reason }
function analyzeDamageLocked(gameId, teamSide, minSnapshots, gMins) {
  const hist = state.scoreHistory[gameId];
  const need = minSnapshots || 4;  // bumped from 3 to 4 for more data
  const MIN_TIME_SPAN_MS = 180000; // 3 minutes minimum between first and last snapshot
  const MIN_GAME_MINUTES = 15;     // don't evaluate before mid-Q2

  if (!hist || hist.length < need) return { locked: false, trend: 'unknown', snapshots: hist?.length || 0, reason: `need ${need} snapshots, have ${hist?.length || 0}` };

  // Anti-bias #3: game must be far enough along
  if (gMins && gMins < MIN_GAME_MINUTES) return { locked: false, trend: 'unknown', snapshots: hist.length, reason: `game only ${gMins.toFixed(0)} min in (need ${MIN_GAME_MINUTES})` };

  // Use all available snapshots (not just last N) for better signal
  const recent = hist.slice(-Math.max(need, hist.length));
  const first = recent[0];
  const last = recent[recent.length - 1];
  const timeSpanMs = last.ts - first.ts;

  // Anti-bias #1: minimum time span between first and last snapshot
  if (timeSpanMs < MIN_TIME_SPAN_MS) return { locked: false, trend: 'unknown', snapshots: recent.length, timeSpanSec: Math.round(timeSpanMs/1000), reason: `time span ${Math.round(timeSpanMs/1000)}s < ${MIN_TIME_SPAN_MS/1000}s minimum` };

  // Anti-bias #2: score must have changed (at least one team scored)
  const totalScoreFirst = first.aS + first.hS;
  const totalScoreLast = last.aS + last.hS;
  const scoreChanged = totalScoreLast !== totalScoreFirst;
  if (!scoreChanged) return { locked: false, trend: 'unknown', snapshots: recent.length, timeSpanSec: Math.round(timeSpanMs/1000), scoreChanged: false, reason: 'no scoring activity  dead ball or timeout' };

  // Calculate deficit FROM the perspective of the team we're evaluating
  // teamSide: 'away' or 'home'  the team whose star is cold / who is trailing
  const getDeficit = (snap) => {
    // Positive deficit = team is behind. Negative = team is ahead.
    return teamSide === 'away' ? (snap.hS - snap.aS) : (snap.aS - snap.hS);
  };

  const deficitNow = getDeficit(last);
  const deficitThen = getDeficit(first);
  const deficitChange = deficitNow - deficitThen;

  // "Locked" = the team was behind AND the deficit didn't shrink (grew or stayed)
  const isTrailing = deficitNow > 0;
  const deficitStable = deficitChange >= 0; // didn't shrink

  // Check if deficit has been consistently non-shrinking across all snapshots
  // Allow small 2-pt fluctuations (single basket noise) but flag any real comeback attempt
  let consistentlyBehind = true;
  let maxRecovery = 0; // track the biggest single-interval recovery
  for (let i = 1; i < recent.length; i++) {
    const recovery = getDeficit(recent[i-1]) - getDeficit(recent[i]);
    if (recovery > maxRecovery) maxRecovery = recovery;
    if (recovery > 3) {
      consistentlyBehind = false; // deficit shrank by more than 3 pts in one interval = comeback attempt
      break;
    }
  }

  let trend = 'unknown';
  if (deficitChange > 3) trend = 'growing';
  else if (deficitChange >= -2) trend = 'stable';
  else trend = 'shrinking';

  const locked = isTrailing && deficitStable && consistentlyBehind;
  const timeSpanSec = Math.round(timeSpanMs / 1000);

  return { locked, trend, deficitNow, deficitThen, deficitChange, snapshots: recent.length, timeSpanSec, scoreChanged, consistentlyBehind, maxRecovery, reason: locked ? 'deficit stable/growing over ' + timeSpanSec + 's with scoring activity' : (isTrailing ? 'trailing but deficit shrinking or inconsistent' : 'not trailing') };
}

// ==================== CONNECTION STATUS ====================
function setConnStatus(status) {
  const el = document.getElementById('connStatus');
  const dot = document.getElementById('statusDot');
  el.style.display = 'inline';
  if (status === 'ok') { el.textContent = 'Connected'; el.className = 'conn-status conn-ok'; dot.className = 'status-dot live'; state.consecutiveErrors = 0; }
  else if (status === 'error') { el.textContent = 'Error'; el.className = 'conn-status conn-err'; dot.className = 'status-dot error'; state.consecutiveErrors++; state.errorCount++; }
  else { el.textContent = 'Loading...'; el.className = 'conn-status conn-loading'; }
  document.getElementById('errorCount').textContent = state.errorCount;
}

// ==================== QUARTER-END DETECTION ====================
function checkQuarterEnd(gameId, teamAbbr, currentPeriod, pct, made, att, gameLabel) {
  const key = `${gameId}_${teamAbbr}`;
  const prev = state.lastKnownPeriods[key] || 0;
  if (currentPeriod > prev && prev > 0) {
    const p = state.prevTeamData[key];
    if (p) {
      const qM = (parseInt(made)||0) - (p.made||0), qA = (parseInt(att)||0) - (p.att||0);
      const qP = qA > 0 ? (qM/qA*100) : 0;
      if (qP >= 50 && qA >= 4) {
        const a = { id: Date.now()+Math.random(), time: new Date().toLocaleTimeString(), team: teamAbbr, quarter: prev, pct: qP.toFixed(1), made: qM, att: qA, game: gameLabel };
        state.quarterAlerts.unshift(a); localStorage.setItem('quarterAlerts', JSON.stringify(state.quarterAlerts));
        renderQtrAlerts(); showQuarterToast(a);
      }
    }
  }
  state.lastKnownPeriods[key] = currentPeriod;
  state.prevTeamData[key] = { made: parseInt(made)||0, att: parseInt(att)||0, period: currentPeriod };
}

function showQuarterToast(a) {
  // No popup  just update the badge count silently
  const badge = document.getElementById('threept-badge');
  if (state.quarterAlerts.length > 0) { badge.style.display = 'inline'; badge.textContent = state.quarterAlerts.length; }
}

function renderQtrAlerts() {
  const tb = document.getElementById('qtr-alerts-body');
  if (!state.quarterAlerts.length) { tb.innerHTML = '<tr><td colspan="7" class="empty-state">No quarter-end alerts yet.</td></tr>'; document.getElementById('threept-qtr-alerts').textContent = '0'; return; }
  tb.innerHTML = state.quarterAlerts.map(a => { const pLabel = isNCAA() ? (a.quarter <= 2 ? `H${a.quarter}` : `OT`) : `Q${a.quarter}`; return `<tr><td>${a.time}</td><td><strong>${a.team}</strong></td><td>${pLabel}</td><td style="color:var(--red);font-weight:800;">${a.pct}%</td><td>${a.made}/${a.att}</td><td>${a.game}</td><td><button class="btn btn-purple btn-sm" onclick="openLogModal('${a.game}','3PT ${pLabel}','3PT Regression')">Log</button></td></tr>`; }).join('');
  document.getElementById('threept-qtr-alerts').textContent = state.quarterAlerts.length;
}
function clearQtrAlerts() { if(confirm('Clear all?')) { state.quarterAlerts=[]; localStorage.setItem('quarterAlerts','[]'); renderQtrAlerts(); document.getElementById('threept-badge').style.display='none'; } }

// ==================== LEAD DURABILITY (PAINT vs 3PT) ====================
function analyzeScoringDurability(teamAbbr, score, fg3Made, opponentScore) {
  const s = parseInt(score) || 0;
  const m3 = parseInt(fg3Made) || 0;
  if (s <= 0) return { pct3: 0, durability: 'neutral', label: '-', fragile: false };
  const pts3 = m3 * 3;
  const pct3 = (pts3 / s * 100);
  const nonThreePts = s - pts3;
  // League average: ~35% of points come from 3PT. Above 42% is fragile, below 28% is durable
  const isLeading = s > (parseInt(opponentScore) || 0);
  const fragile = pct3 >= getFragile3PtThreshold() && isLeading && s >= 20;
  const durable = pct3 <= 28 && isLeading && s >= 20;
  let label = `${pct3.toFixed(0)}% from 3`;
  let durability = 'neutral';
  if (fragile) { durability = 'fragile'; label = `${pct3.toFixed(0)}% from 3 - FRAGILE lead`; }
  else if (durable) { durability = 'durable'; label = `${pct3.toFixed(0)}% from 3 - DURABLE lead`; }
  return { pct3, durability, label, fragile, durable, pts3, nonThreePts };
}




// ==================== ESPN SCOREBOARD ====================

function getLeague3PtAvg() { return isNCAA() ? 33.5 : 36.5; }
// Team Season 3PT% Averages

function getFragile3PtThreshold() { return isNCAA() ? 40 : 42; }
function getLeagueName() { return isNCAA() ? 'NCAAB' : 'NBA'; }
let _modeFetchController = null;

async function fetchESPNScoreboard() {
  if (_modeFetchController) _modeFetchController.abort();
  _modeFetchController = new AbortController();
  const grid = document.getElementById('live-games-grid');
  const tpGrid = document.getElementById('threept-grid');
  setConnStatus('loading');
    await fetchLiveOdds();
    await Promise.all([fetchTeamProfiles(), fetchTeamScorers()]); // must complete before rendering cards

  try {
    const modeSignal = _modeFetchController ? _modeFetchController.signal : undefined;
    const timeout = setTimeout(() => { if (_modeFetchController) _modeFetchController.abort(); }, 10000);
    const res = await fetch(getESPNUrl(), { signal: modeSignal });
    clearTimeout(timeout);
    if (!res.ok) throw new Error('ESPN ' + res.status);
    const data = await res.json();
    setConnStatus('ok');
    let events = data.events || [];
    document.getElementById('live-last-update').textContent = new Date().toLocaleTimeString();

    // Also fetch upcoming games (tomorrow) if no live games
    const inProgress = events.filter(e => e.status?.type?.state === 'in');
    const preGames = events.filter(e => e.status?.type?.state === 'pre');
    const postGames = events.filter(e => e.status?.type?.state === 'post');
    document.getElementById('live-games-count').textContent = inProgress.length;

    // If no live/pre games, fetch tomorrow's schedule too
    if (inProgress.length === 0 && preGames.length === 0) {
      try {
        const tmrw = new Date(Date.now() + 86400000);
        const dateStr = tmrw.getFullYear() + String(tmrw.getMonth()+1).padStart(2,'0') + String(tmrw.getDate()).padStart(2,'0');
        const tmrwRes = await fetch(getESPNUrl() + '?dates=' + dateStr, { signal: AbortSignal.timeout(8000) });
        if (tmrwRes.ok) {
          const tmrwData = await tmrwRes.json();
          const tmrwEvents = (tmrwData.events || []).filter(e => e.status?.type?.state === 'pre');
          tmrwEvents.forEach(e => { e._upcoming = true; });
          events = events.concat(tmrwEvents);
        }
      } catch(e) { /* tomorrow fetch optional */ }
    }

    // Build ordered event list: live first, then pre, then post
    const liveEvents = events.filter(e => e.status?.type?.state === 'in');
    const upcomingEvents = events.filter(e => e.status?.type?.state === 'pre');
    const completedEvents = events.filter(e => e.status?.type?.state === 'post');
    const allDisplayEvents = [...liveEvents, ...upcomingEvents, ...completedEvents];

    if (allDisplayEvents.length === 0) {
      grid.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><div style="width:56px;height:56px;margin:0 auto 16px;background:var(--bg);border:2px solid var(--border);border-radius:50%;display:flex;align-items:center;justify-content:center;"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="1.5"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg></div><p style="font-weight:600;color:var(--text-secondary);margin-bottom:4px;">No ${getLeagueName()} games right now</p><p style="font-size:12px;">Check back when games are scheduled or in progress.</p></div>`;
      tpGrid.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><div class="icon">&#x1F3AF;</div><p>No live games.</p></div>`;
      document.getElementById('edgeThesisContainer').classList.remove('active');
      return;
    }

    // Fetch boxscores for live games (parallel)  gives us all player stats, not just leader
    const _boxscoreMap = {}; // gameId  { away: [{name,pts}], home: [{name,pts}] }
    if (liveEvents.length > 0) {
      const league = isNCAA() ? 'mens-college-basketball' : 'nba';
      const boxFetches = liveEvents.map(e =>
        fetch(`https://site.api.espn.com/apis/site/v2/sports/basketball/${league}/summary?event=${e.id}`, { signal: AbortSignal.timeout(6000) })
          .then(r => r.ok ? r.json() : null)
          .catch(() => null)
      );
      const boxResults = await Promise.all(boxFetches);
      boxResults.forEach((bx, i) => {
        if (!bx?.boxscore?.players) return;
        const ev = liveEvents[i];
        const gid = ev.id;
        const comp = ev.competitions?.[0];
        const awayAbbr = comp?.competitors?.find(c=>c.homeAway==='away')?.team?.abbreviation || '';
        const homeAbbr = comp?.competitors?.find(c=>c.homeAway==='home')?.team?.abbreviation || '';
        const map = { away: [], home: [] };
        bx.boxscore.players.forEach(team => {
          const abbr = team.team?.abbreviation || '';
          const side = abbr === awayAbbr ? 'away' : 'home';
          (team.statistics?.[0]?.athletes || []).forEach(a => {
            const pts = parseFloat(a.stats?.[1]) || 0;
            const name = a.athlete?.displayName || a.athlete?.shortName || '?';
            map[side].push({ name, pts, team: abbr });
          });
        });
        _boxscoreMap[gid] = map;
      });
    }

    // Section headers
    let sectionHeaders = { live: false, upcoming: false, completed: false };

    let sig3Fragile=0, sigStar=0, sigCombined=0, hotTeams=0, warmTeams=0;
    let cards='', tpCards='', gameTheses=[];
    // Per-signal game tracking for chip click-to-expand
    let signalGames = { '3ptfragile': [], 'star': [], 'combined': [] };

    for (const event of allDisplayEvents) {
      const comp = event.competitions?.[0]; if (!comp) continue;
      const away = comp.competitors?.find(c => c.homeAway==='away');
      const home = comp.competitors?.find(c => c.homeAway==='home');
      if (!away || !home) continue;

      const gid = event.id;
      const aA = away.team?.abbreviation || shortName(away.team?.displayName||'');
      const aFull = away.team?.displayName||'';
      const hFull = home.team?.displayName||'';
      const hA = home.team?.abbreviation || shortName(home.team?.displayName||'');
      const aLogo = away.team?.logo || '';
      const hLogo = home.team?.logo || '';
      // Game links: ESPN gamecast + NBA League Pass
      const espnLink = event.links?.[0]?.href || '';
      const gameSlug = espnLink ? espnLink.split('/').pop() : '';
      const leaguePassLink = !isNCAA() && gameSlug ? 'https://www.nba.com/game/' + gameSlug : '';
      const aS = parseInt(away.score)||0, hS = parseInt(home.score)||0;
      const gameState = event.status?.type?.state;
      const isLive = gameState === 'in';
      const isUpcoming = gameState === 'pre';
      const isCompleted = gameState === 'post';
      const per = event.status?.period||0, clk = event.status?.displayClock||'';
      const detail = event.status?.type?.shortDetail||'';
      const gLabel = `${aA} @ ${hA}`;
      const aRec = away.records?.[0]?.summary||'', hRec = home.records?.[0]?.summary||'';

      // Section headers
      if (isLive && !sectionHeaders.live) {
        cards += `<div class="grid-section-label" style="border-top:none;margin-top:0;padding-top:8px;"><span style="color:var(--red);">LIVE</span></div>`;
        sectionHeaders.live = true;
      } else if (isUpcoming && !sectionHeaders.upcoming) {
        cards += `<div class="grid-section-label"><span style="color:var(--accent);">UPCOMING</span></div>`;
        sectionHeaders.upcoming = true;
      } else if (isCompleted && !sectionHeaders.completed) {
        cards += `<div class="grid-section-label"><span style="color:var(--text-muted);">COMPLETED</span></div>`;
        sectionHeaders.completed = true;
      }

      // Upcoming game card  minimal style with tipoff time
      if (isUpcoming) {
        const tipoff = event.date ? new Date(event.date) : null;
        const tipoffStr = tipoff ? tipoff.toLocaleString('en-US', { weekday: 'short', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' }) : detail;
        const broadcast = comp.broadcasts?.[0]?.names?.[0] || '';
        const oddsDetail = comp.odds?.[0]?.details || '';
        const ou = comp.odds?.[0]?.overUnder || '';
        const isFav = state.favorites.includes(gid);
        cards += `<div class="game-card" data-game-id="${gid}" style="opacity:0.85;">
          <div class="game-card-header">
            <span style="color:var(--accent);font-weight:600;">UPCOMING</span>
            <span style="display:flex;align-items:center;gap:6px;">
              ${broadcast ? '<span style="font-size:9px;font-weight:600;color:var(--text-muted);background:var(--bg);padding:1px 6px;border-radius:3px;">' + broadcast + '</span>' : ''}
              <span class="fav-star" onclick="toggleFavorite('${gid}')" style="cursor:pointer;font-size:14px;">${isFav?'\u2605':'\u2606'}</span>
            </span>
          </div>
          <div class="game-card-body">
            <div class="game-teams">
              <div class="team-block">
                <div class="team-name">${teamLogoImg(aLogo, 20)}${teamDisplayShort(aA, aFull)}</div>
                <div class="team-record">${aRec}</div>
                ${teamProfileHTML(aA, 'away', aLogo)}
                <div class="team-score" style="color:var(--text-muted);">-</div>
              </div>
              <div class="vs-block">
                <div class="vs-text" style="font-size:11px;font-weight:500;color:var(--text-muted);opacity:0.6;">vs</div>
              </div>
              <div class="team-block">
                <div class="team-name">${teamLogoImg(hLogo, 20)}${teamDisplayShort(hA, hFull)}</div>
                <div class="team-record">${hRec}</div>
                ${teamProfileHTML(hA, 'home', hLogo)}
                <div class="team-score" style="color:var(--text-muted);">-</div>
              </div>
            </div>
            <div style="text-align:center;padding:8px 0 4px;">
              <div style="font-size:12px;font-weight:600;color:var(--text-secondary);">${tipoffStr}</div>
              ${oddsDetail || ou ? '<div style="font-size:11px;color:var(--text-muted);margin-top:2px;">' + (oddsDetail ? oddsDetail : '') + (ou ? ' | O/U ' + ou : '') + '</div>' : ''}
              ${gameLinksHTML(espnLink, leaguePassLink)}
            </div>
          </div>
        </div>`;
        continue;
      }

      // Completed game card  muted style with final score
      if (isCompleted) {
        const winner = aS > hS ? 'away' : 'home';
        const isFav = state.favorites.includes(gid);
        cards += `<div class="game-card" data-game-id="${gid}" style="opacity:0.75;">
          <div class="game-card-header">
            <span style="color:var(--text-muted);font-weight:600;">FINAL</span>
            <span class="fav-star" onclick="toggleFavorite('${gid}')" style="cursor:pointer;font-size:14px;">${isFav?'\u2605':'\u2606'}</span>
          </div>
          <div class="game-card-body">
            <div class="game-teams">
              <div class="team-block">
                <div class="team-name" ${winner==='away'?'style="color:var(--accent);font-weight:900;"':''}>${teamLogoImg(aLogo, 20)}${teamDisplayShort(aA, aFull)}</div>
                <div class="team-record">${aRec}</div>
                ${teamProfileHTML(aA, 'away', aLogo)}
                <div class="team-score" ${winner==='away'?'style="color:var(--accent);"':'style="color:var(--text-muted);"'}>${aS}</div>
              </div>
              <div class="vs-block">
                <div class="vs-text" style="font-size:11px;font-weight:500;color:var(--text-muted);opacity:0.6;">vs</div>
              </div>
              <div class="team-block">
                <div class="team-name" ${winner==='home'?'style="color:var(--accent);font-weight:900;"':''}>${teamLogoImg(hLogo, 20)}${teamDisplayShort(hA, hFull)}</div>
                <div class="team-record">${hRec}</div>
                ${teamProfileHTML(hA, 'home', hLogo)}
                <div class="team-score" ${winner==='home'?'style="color:var(--accent);"':'style="color:var(--text-muted);"'}>${hS}</div>
              </div>
            </div>
          </div>
        </div>`;
        continue;
      }

      let aStats={}, hStats={};
      (away.statistics||[]).forEach(s => { aStats[s.name]=s.displayValue; });
      (home.statistics||[]).forEach(s => { hStats[s.name]=s.displayValue; });

      let a3P=aStats.threePointFieldGoalPct||aStats.threePointPct||'-';
      let h3P=hStats.threePointFieldGoalPct||hStats.threePointPct||'-';
      let a3M=aStats.threePointFieldGoalsMade||'-', a3A=aStats.threePointFieldGoalsAttempted||'-';
      let h3M=hStats.threePointFieldGoalsMade||'-', h3A=hStats.threePointFieldGoalsAttempted||'-';
      let aFouls=aStats.fouls||aStats.totalFouls||'0', hFouls=hStats.fouls||hStats.totalFouls||'0';

      // Track score momentum for Damage Locked detection
      if (isLive) trackScoreMomentum(gid, aS, hS);
      let aFTA = parseInt(aStats.freeThrowsAttempted)||0;
      let hFTA = parseInt(hStats.freeThrowsAttempted)||0;

      if (isLive) { checkQuarterEnd(gid, aA, per, a3P, a3M, a3A, gLabel); checkQuarterEnd(gid, hA, per, h3P, h3M, h3A, gLabel); }

      let aLeaders=[], hLeaders=[];
      (comp.competitors||[]).forEach(c => {
        (c.leaders||[]).forEach(cat => {
          if (cat.name==='points'||cat.displayName==='Points') {
            (cat.leaders||[]).forEach(l => {
              const e = { name: l.athlete?.shortName||l.athlete?.displayName||'?', pts: parseFloat(l.value)||0, team: c.homeAway==='away'?aA:hA };
              if (c.homeAway==='away') aLeaders.push(e); else hLeaders.push(e);
            });
          }
        });
      });

      let signals=[], signalLevel=0;
      const gLabelFull = gLabel;
      let thesis = { game: gLabel, gameFull: gLabelFull, aTeam: aA, hTeam: hA, aTeamFull: aFull, hTeamFull: hFull, aLogo, hLogo, aScore: aS, hScore: hS, per, clk, detail, criteria: {}, betSide: '', betSideFull: '', betLogic: '', signals: [] };

      if (isLive) {
        // 3PT CHECK  evaluate shooting stats (used as input for 3PT Fragile signal)
        const chk3 = (p,m,a,t,side,tFull) => {
          const pn=parseFloat(p), an=parseInt(a), mn=parseInt(m);
          const tD = teamDisplay(t, tFull);
          // NCAA: lower thresholds (fewer possessions, lower league avg 3PT%)
          const isHot = isNCAA() ? ((pn>=48&&an>=10)||(pn>=52&&an>=7)) : ((pn>=50&&an>=12)||(pn>=55&&an>=8));
          const isWarm = !isHot && (isNCAA() ? (pn>=43&&an>=8) : (pn>=45&&an>=10));
          if (isHot) {
            fire3PTAlert(t, pn.toFixed(0), mn, an, gLabel, per, clk); hotTeams++;
          } else if (isWarm) { warmTeams++; }
          // NOTE: 3PT alone no longer fires as a level 2 signal.
          // It will be combined with Fragile Lead below into "3PT Fragile"
          return { isHot, isWarm, pn, an, mn, tD };
        };
        const a3Check = chk3(a3P,a3M,a3A,aA,'away',aFull), h3Check = chk3(h3P,h3M,h3A,hA,'home',hFull);

        // FRAGILE LEAD CHECK  evaluate lead composition (used as input for 3PT Fragile signal)
        const aDur = analyzeScoringDurability(aA, aS, a3M, hS);
        const hDur = analyzeScoringDurability(hA, hS, h3M, aS);
        let aFragileData = null, hFragileData = null;
        if (aS > hS && aDur.pct3 >= getFragile3PtThreshold() && aS >= 20) {
          const hNon3Pct = hS > 0 ? ((hS - (parseInt(h3M)||0)*3) / hS * 100) : 0;
          if (hNon3Pct >= 58) aFragileData = { pct3: aDur.pct3, oppPaintPct: hNon3Pct };
        }
        if (hS > aS && hDur.pct3 >= getFragile3PtThreshold() && hS >= 20) {
          const aNon3Pct = aS > 0 ? ((aS - (parseInt(a3M)||0)*3) / aS * 100) : 0;
          if (aNon3Pct >= 58) hFragileData = { pct3: hDur.pct3, oppPaintPct: aNon3Pct };
        }

        // ========== 3PT FRAGILE SIGNAL  fires ONLY when BOTH conditions are met ==========
        // Condition 1: Team shooting hot from 3 (50%+ on 12+ att or 55%+ on 8+ att)
        // Condition 2: Their lead is fragile (3PT-heavy) AND trailing team scores from paint
        const _aD = teamDisplay(aA, aFull), _hD = teamDisplay(hA, hFull);

        // ===== OPPONENT ENGINE CHECK =====
        // Can the trailing team actually capitalize if 3PT regression happens?
        // Compute non-3PT points per minute for each team (paint + FT + mid-range)
        const _gMinsNow = getElapsedMinutes(per, clk) || 1;
        const aNon3Pts = aS - (parseInt(a3M)||0)*3;
        const hNon3Pts = hS - (parseInt(h3M)||0)*3;
        const aNon3Ppm = aNon3Pts / _gMinsNow;  // away non-3PT points per minute
        const hNon3Ppm = hNon3Pts / _gMinsNow;  // home non-3PT points per minute
        // League avg ~1.8-2.0 non-3PT ppm (NBA). NCAA is lower scoring  threshold 1.1.
        const NO_ENGINE_THRESHOLD = isNCAA() ? 1.1 : 1.3;

        // Away team: both hot 3PT AND fragile lead
        const awayLead = aS - hS;
        // If away leads with fragile 3s, check if HOME (trailing) has enough non-3PT engine to capitalize
        const hNoEngine = awayLead > 0 && hNon3Ppm < NO_ENGINE_THRESHOLD && _gMinsNow >= 10;
        const hEngineLabel = hNoEngine ? `  BUT ${_hD} has no scoring engine (${hNon3Ppm.toFixed(1)} non-3PT PPM)  may not capitalize even if 3s regress` : '';

        const _fragileMaxMargin = isNCAA() ? 12 : 15;
        if (a3Check.isHot && aFragileData && awayLead >= 3 && awayLead <= _fragileMaxMargin) {
          const fragileStrength = hNoEngine ? 'weakened' : 'strong';
          signals.push({type:'3ptFragile', text:`${_aD} 3PT FRAGILE: shooting ${a3Check.pn.toFixed(0)}% from 3 (${a3Check.mn}/${a3Check.an}) AND lead is ${aFragileData.pct3.toFixed(0)}% 3PT-dependent. Lead: ${awayLead}pts. ${_hD} scores from paint (${aFragileData.oppPaintPct.toFixed(0)}%).${hNoEngine ? '  BUT trailing team has weak scoring engine  regression may not flip result.' : ' Classic fade.'}`, level:2});
          sig3Fragile++;
          sendSignalNotification(' 3PT Fragile: ' + _aD + (hNoEngine ? ' ( weak opponent engine)' : ''), aA + ' shooting ' + a3Check.pn.toFixed(0) + '% from 3 AND lead is fragile (' + awayLead + 'pts)' + (hNoEngine ? '. But trailing team offense is broken  regression may not matter.' : ''), gid, '3ptfragile_away');
          if (!state.signalFirstSeen[gid]) state.signalFirstSeen[gid] = Date.now();
          const engineDetail = hNoEngine
            ? `<br><strong> Opponent Engine Check:</strong> ${_hD} is producing only ${hNon3Ppm.toFixed(1)} non-3PT points/min (threshold: ${NO_ENGINE_THRESHOLD}). Their offense is broken beyond just 3PT variance  even if ${_aD}'s 3s cool down, ${_hD} may not have the scoring engine to capitalize. <strong>Signal is weaker.</strong>`
            : `<br><strong> Opponent Engine:</strong> ${_hD} is producing ${hNon3Ppm.toFixed(1)} non-3PT points/min  they have a real scoring engine from paint/FT/mid-range. When ${_aD}'s 3s regress, ${_hD} can capitalize.`;
          thesis.criteria['3ptfragile_away'] = {met:true, strong:!hNoEngine, label:`${_aD} 3PT Fragile Lead${hNoEngine?' ':''}`, detail:`<strong>3PT Shooting:</strong> ${_aD} is shooting ${a3Check.pn.toFixed(0)}% from 3 on ${a3Check.an} attempts (${getLeagueName()} avg: ${getLeague3PtAvg()}%).<br><strong>Lead Composition:</strong> ${aFragileData.pct3.toFixed(0)}% of ${_aD}'s scoring comes from 3PT (threshold: ${getFragile3PtThreshold()}%).<br><strong>Score Margin:</strong> ${awayLead} pts  in the 3-15pt sweet spot where regression flips the game.<br><strong>Opponent Durability:</strong> ${_hD} has ${aFragileData.oppPaintPct.toFixed(0)}% non-3PT scoring  paint-heavy and sustainable.${engineDetail}<br><strong>Signal:</strong> ${hNoEngine ? 'Hot 3PT + fragile lead detected, but trailing team\'s offense is too weak to exploit regression. Proceed with caution.' : 'Hot 3PT + fragile lead + competitive margin. When shooting cools, lead evaporates.'}`, value:`${a3Check.pn.toFixed(0)}% 3PT + ${aFragileData.pct3.toFixed(0)}% fragile | Lead: ${awayLead}${hNoEngine?' ':''}`};
        } else if (a3Check.isHot && aFragileData && awayLead > _fragileMaxMargin) {
          // Hot + fragile but blowout  too large a margin for reliable fade
          signals.push({type:'3ptFragile', text:`${_aD} 3PT fragile but lead too large (${awayLead}pts)  blowout territory.`, level:1});
          thesis.criteria['3ptfragile_away'] = {met:true, strong:false, label:`${_aD} 3PT Fragile (Blowout)`, detail:`${_aD} has a fragile 3PT lead (${aFragileData.pct3.toFixed(0)}% from 3PT) but the ${awayLead}pt margin is too large. Signal needs 3-${_fragileMaxMargin}pt lead to fire. Even if 3PT% regresses, blowout margin provides too much cushion.`, value:`${awayLead}pt lead  too wide`, warn:true};
        } else if (a3Check.isHot && aFragileData && awayLead < 3) {
          // Hot + fragile but lead too small  not enough edge
          signals.push({type:'3ptFragile', text:`${_aD} shooting hot (${a3Check.pn.toFixed(0)}%) + fragile lead but only ${awayLead}pt lead  needs 3+ pts.`, level:1});
          thesis.criteria['3ptfragile_away'] = {met:true, strong:false, label:`${_aD} 3PT Fragile (Tight)`, detail:`${_aD} has both conditions but only a ${awayLead}pt lead. Signal needs 3-${_fragileMaxMargin}pt margin to ensure meaningful edge from 3PT regression.`, value:`${awayLead}pt lead  too tight`, warn:true};
        } else if (a3Check.isHot && !aFragileData) {
          // Hot shooting but lead not fragile enough  informational only
          signals.push({type:'3ptFragile', text:`${_aD} shooting hot: ${a3Check.pn.toFixed(0)}% from 3 (${a3Check.mn}/${a3Check.an})  but lead not fragile enough for full signal.`, level:1});
          thesis.criteria['3ptfragile_away'] = {met:true, strong:false, label:`${_aD} 3PT Hot (no fragile lead)`, detail:`${_aD} is shooting ${a3Check.pn.toFixed(0)}% from 3 on ${a3Check.an} attempts  elevated, but the lead composition isn't fragile enough (needs 3PT-heavy lead vs paint-heavy opponent). Monitoring only.`, value:`${a3Check.pn.toFixed(0)}% 3PT`, warn:true};
        } else if (!a3Check.isHot && aFragileData) {
          // Fragile lead but shooting not extreme  informational only
          thesis.criteria['3ptfragile_away'] = {met:true, strong:false, label:`${_aD} Fragile Lead (not hot enough)`, detail:`${_aD}'s lead is ${aFragileData.pct3.toFixed(0)}% from 3PT  fragile composition detected, but current 3PT shooting rate isn't extreme enough to trigger. Needs 50%+ on 12+ attempts.`, value:`${aFragileData.pct3.toFixed(0)}% fragile`, warn:true};
        } else if (a3Check.isWarm) {
          signals.push({type:'3ptFragile', text:`${_aD} ${a3Check.pn.toFixed(0)}% from 3 (${a3Check.mn}/${a3Check.an})  elevated, watch for increase.`, level:1});
          thesis.criteria['3ptfragile_away'] = {met:false, label:`${_aD} 3PT: ${a3Check.pn.toFixed(0)}%`, detail:`Elevated but no fragile lead. Both conditions needed.`, value:'Watching'};
        } else {
          thesis.criteria['3ptfragile_away'] = {met:false, label:`${_aD} 3PT Fragile`, detail:`No 3PT fragile signal. Normal shooting range and/or no fragile lead composition.`, value:'N/A'};
        }

        // Home team: both hot 3PT AND fragile lead
        const homeLead = hS - aS;
        // If home leads with fragile 3s, check if AWAY (trailing) has enough non-3PT engine to capitalize
        const aNoEngine = homeLead > 0 && aNon3Ppm < NO_ENGINE_THRESHOLD && _gMinsNow >= 10;
        const aEngineLabel = aNoEngine ? `  BUT ${_aD} has no scoring engine (${aNon3Ppm.toFixed(1)} non-3PT PPM)  may not capitalize even if 3s regress` : '';

        if (h3Check.isHot && hFragileData && homeLead >= 3 && homeLead <= _fragileMaxMargin) {
          signals.push({type:'3ptFragile', text:`${_hD} 3PT FRAGILE: shooting ${h3Check.pn.toFixed(0)}% from 3 (${h3Check.mn}/${h3Check.an}) AND lead is ${hFragileData.pct3.toFixed(0)}% 3PT-dependent. Lead: ${homeLead}pts. ${_aD} scores from paint (${hFragileData.oppPaintPct.toFixed(0)}%).${aNoEngine ? '  BUT trailing team has weak scoring engine  regression may not flip result.' : ' Classic fade.'}`, level:2});
          sig3Fragile++;
          sendSignalNotification(' 3PT Fragile: ' + _hD + (aNoEngine ? ' ( weak opponent engine)' : ''), hA + ' shooting ' + h3Check.pn.toFixed(0) + '% from 3 AND lead is fragile (' + homeLead + 'pts)' + (aNoEngine ? '. But trailing team offense is broken  regression may not matter.' : ''), gid, '3ptfragile_home');
          if (!state.signalFirstSeen[gid]) state.signalFirstSeen[gid] = Date.now();
          const hEngineDetail = aNoEngine
            ? `<br><strong> Opponent Engine Check:</strong> ${_aD} is producing only ${aNon3Ppm.toFixed(1)} non-3PT points/min (threshold: ${NO_ENGINE_THRESHOLD}). Their offense is broken beyond just 3PT variance  even if ${_hD}'s 3s cool down, ${_aD} may not have the scoring engine to capitalize. <strong>Signal is weaker.</strong>`
            : `<br><strong> Opponent Engine:</strong> ${_aD} is producing ${aNon3Ppm.toFixed(1)} non-3PT points/min  they have a real scoring engine from paint/FT/mid-range. When ${_hD}'s 3s regress, ${_aD} can capitalize.`;
          thesis.criteria['3ptfragile_home'] = {met:true, strong:!aNoEngine, label:`${_hD} 3PT Fragile Lead${aNoEngine?' ':''}`, detail:`<strong>3PT Shooting:</strong> ${_hD} is shooting ${h3Check.pn.toFixed(0)}% from 3 on ${h3Check.an} attempts (${getLeagueName()} avg: ${getLeague3PtAvg()}%).<br><strong>Lead Composition:</strong> ${hFragileData.pct3.toFixed(0)}% of ${_hD}'s scoring comes from 3PT (threshold: ${getFragile3PtThreshold()}%).<br><strong>Score Margin:</strong> ${homeLead} pts  in the 3-15pt sweet spot where regression flips the game.<br><strong>Opponent Durability:</strong> ${_aD} has ${hFragileData.oppPaintPct.toFixed(0)}% non-3PT scoring  paint-heavy and sustainable.${hEngineDetail}<br><strong>Signal:</strong> ${aNoEngine ? 'Hot 3PT + fragile lead detected, but trailing team\'s offense is too weak to exploit regression. Proceed with caution.' : 'Hot 3PT + fragile lead + competitive margin. When shooting cools, lead evaporates.'}`, value:`${h3Check.pn.toFixed(0)}% 3PT + ${hFragileData.pct3.toFixed(0)}% fragile | Lead: ${homeLead}${aNoEngine?' ':''}`};
        } else if (h3Check.isHot && hFragileData && homeLead > _fragileMaxMargin) {
          signals.push({type:'3ptFragile', text:`${_hD} 3PT fragile but lead too large (${homeLead}pts)  blowout territory.`, level:1});
          thesis.criteria['3ptfragile_home'] = {met:true, strong:false, label:`${_hD} 3PT Fragile (Blowout)`, detail:`${_hD} has a fragile 3PT lead (${hFragileData.pct3.toFixed(0)}% from 3PT) but the ${homeLead}pt margin is too large. Signal needs 3-${_fragileMaxMargin}pt lead to fire. Even if 3PT% regresses, blowout margin provides too much cushion.`, value:`${homeLead}pt lead  too wide`, warn:true};
        } else if (h3Check.isHot && hFragileData && homeLead < 3) {
          signals.push({type:'3ptFragile', text:`${_hD} shooting hot (${h3Check.pn.toFixed(0)}%) + fragile lead but only ${homeLead}pt lead  needs 3+ pts.`, level:1});
          thesis.criteria['3ptfragile_home'] = {met:true, strong:false, label:`${_hD} 3PT Fragile (Tight)`, detail:`${_hD} has both conditions but only a ${homeLead}pt lead. Signal needs 3-${_fragileMaxMargin}pt margin to ensure meaningful edge from 3PT regression.`, value:`${homeLead}pt lead  too tight`, warn:true};
        } else if (h3Check.isHot && !hFragileData) {
          signals.push({type:'3ptFragile', text:`${_hD} shooting hot: ${h3Check.pn.toFixed(0)}% from 3 (${h3Check.mn}/${h3Check.an})  but lead not fragile enough for full signal.`, level:1});
          thesis.criteria['3ptfragile_home'] = {met:true, strong:false, label:`${_hD} 3PT Hot (no fragile lead)`, detail:`${_hD} is shooting ${h3Check.pn.toFixed(0)}% from 3 on ${h3Check.an} attempts  elevated, but the lead composition isn't fragile enough. Monitoring only.`, value:`${h3Check.pn.toFixed(0)}% 3PT`, warn:true};
        } else if (!h3Check.isHot && hFragileData) {
          thesis.criteria['3ptfragile_home'] = {met:true, strong:false, label:`${_hD} Fragile Lead (not hot enough)`, detail:`${_hD}'s lead is ${hFragileData.pct3.toFixed(0)}% from 3PT  fragile composition detected, but 3PT shooting rate isn't extreme enough. Needs 50%+ on 12+ attempts.`, value:`${hFragileData.pct3.toFixed(0)}% fragile`, warn:true};
        } else if (h3Check.isWarm) {
          signals.push({type:'3ptFragile', text:`${_hD} ${h3Check.pn.toFixed(0)}% from 3 (${h3Check.mn}/${h3Check.an})  elevated, watch for increase.`, level:1});
          thesis.criteria['3ptfragile_home'] = {met:false, label:`${_hD} 3PT: ${h3Check.pn.toFixed(0)}%`, detail:`Elevated but no fragile lead. Both conditions needed.`, value:'Watching'};
        } else {
          thesis.criteria['3ptfragile_home'] = {met:false, label:`${_hD} 3PT Fragile`, detail:`No 3PT fragile signal. Normal shooting and/or no fragile lead composition.`, value:'N/A'};
        }

        // STAR COIL CHECK  Star cold (<60% pace) + competitive game + prime window
        const cM = parseFloat(clk?.split(':')[0]||getPeriodLength()), cS = parseFloat(clk?.split(':')[1]||0);
        const gMins = getElapsedMinutes(per, clk), gPct = getGamePct(per, clk);
        const scoreMargin = Math.abs(aS - hS);
        let starCoilTeams = {};
        [...aLeaders,...hLeaders].forEach(leader => {
          // NCAA: match against pre-game star database (16+ PPG, built from ESPN team leaders API)
          // NBA: match against the curated star database (23+ PPG)
          let star;
          if (isNCAA()) {
            star = ncaaStarCache.find(s => {
              const leaderLast = leader.name.toLowerCase().split(' ').pop();
              const starLast = s.name.split(' ').pop().toLowerCase();
              return leaderLast === starLast && s.team === leader.team;
            });
          } else {
            star = state.stars.find(s => leader.name.toLowerCase().includes(s.name.split(' ').pop().toLowerCase()) && s.team===leader.team);
          }
          if (star) {
            const exp = getExpectedByTime(star.ppg, gMins);
            const pr = exp>0 ? leader.pts/exp : 1;
            const side = leader.team===aA?'away':'home';
            const oppSide = side==='away'?'home':'away';
            // Star Coil: <65% pace + prime window + game within 15 pts (competitive)
            // NBA: Q2-Q3 (per 2-3). NCAA: 8-35 min elapsed (halves, not quarters)
            const _coilMaxMargin = isNCAA() ? 12 : 15;
            const _inCoilWindow = isNCAA() ? (gMins >= 8 && gMins <= 35) : (per>=2 && per<=3);
            if (pr<0.65 && _inCoilWindow && scoreMargin<=_coilMaxMargin) {
              const starTeamSide = leader.team===aA ? 'away' : 'home';
              const starTeamScore = starTeamSide==='away' ? aS : hS;
              const starTeamTrailing = (starTeamSide==='away' && aS < hS) || (starTeamSide==='home' && hS < aS);

              // ===== SUPPORTING CAST ANALYSIS (core edge strengthener) =====
              // How well are the star's teammates performing WITHOUT the star's contribution?
              // If cast is strong (90% pace), the team is competitive DESPITE the star being cold.
              // Star regression on top of a strong cast = massive swing. This is the strongest edge.
              const oppScore = starTeamSide==='away' ? hS : aS;
              const cast = analyzeSupportingCast(leader.pts, starTeamScore, oppScore, star.ppg, gMins);

              // ===== DAMAGE LOCKED CHECK =====
              const dmg = analyzeDamageLocked(gid, starTeamSide, 4, gMins);
              const damageLocked = starTeamTrailing && dmg.locked;

              // ===== SIGNAL STRENGTH CLASSIFICATION =====
              // 3 tiers based on supporting cast gap (cast score vs opponent score):
              //   ELITE: castGap  -8  cast within 8pts of opponent or leading  strongest signal
              //   STANDARD: castGap -8 to -15  cast behind but in range  normal signal
              //   WEAK: castGap < -15  cast way behind opponent  whole team broken, star alone won't save
              // Damage Locked overrides: if deficit is baked in, downgrade regardless
              // regressionFlips: star's missing pts > cast gap  regression alone closes the deficit
              let coilTier, tierEmoji, tierLabel;
              if (damageLocked) {
                coilTier = 'locked'; tierEmoji = ''; tierLabel = 'DAMAGE LOCKED';
              } else if (cast.strong) {
                coilTier = 'elite'; tierEmoji = ''; tierLabel = 'CAST STRONG';
              } else if (cast.moderate) {
                coilTier = 'standard'; tierEmoji = ''; tierLabel = 'STANDARD';
              } else {
                coilTier = 'weak'; tierEmoji = ''; tierLabel = 'CAST WEAK';
              }

              const isStrongSignal = coilTier === 'elite' || coilTier === 'standard';

              let ctx = per===2?` Half exp: ${getHalfExpected(star.ppg).toFixed(0)}`:'';
              signals.push({type:'star',text:`${tierEmoji} ${leader.name} ${leader.pts}pts (exp ~${exp.toFixed(0)}, ${(pr*100).toFixed(0)}% pace). Margin: ${scoreMargin}pts. Cast: ${cast.castScore}pts vs opp ${oppScore}pts (gap: ${cast.castGap > 0 ? '+' : ''}${cast.castGap}) ${tierLabel}.${cast.regressionFlips ? '  Regression flips lead.' : ''}${ctx}`,level:2});
              sigStar++;
              fireStarCoilAlert(leader, star, gMins, per, clk, gLabel, pr, scoreMargin);
              sendSignalNotification(`${tierEmoji} Star Coil [${tierLabel}]: ${leader.name}`, `${leader.name} ${leader.pts}pts (exp ~${exp.toFixed(0)}). Cast ${cast.castScore}pts vs opp ${oppScore} (gap: ${cast.castGap}). ${cast.regressionFlips ? 'Regression flips!' : ''} Margin: ${scoreMargin}pts.`, gid, 'star_' + leader.team);
              if (!state.signalFirstSeen[gid]) state.signalFirstSeen[gid] = Date.now();
              starCoilTeams[leader.team] = { name: leader.name, damageLocked, dmg, cast, coilTier };
              const starTeamFull = leader.team===aA ? aFull : hFull;

              // Build detailed thesis breakdown
              const oppTeamAbbr = starTeamSide==='away' ? hA : aA;
              const castDetail = `<br><strong>${cast.emoji} Supporting Cast (${cast.label}):</strong> Without ${leader.name}, teammates have <strong>${cast.castScore} pts</strong> vs ${oppTeamAbbr}'s <strong>${oppScore} pts</strong> (gap: <strong>${cast.castGap > 0 ? '+' : ''}${cast.castGap}</strong>).<br>&nbsp;&nbsp; ${leader.name} is missing ~${cast.starDeficit.toFixed(0)} pts from expected (${star.ppg} PPG  ${(gMins/getTotalGameMinutes()*100).toFixed(0)}% game = ~${cast.starExpected.toFixed(0)} exp, has ${leader.pts}).<br>&nbsp;&nbsp; ${cast.regressionFlips ? `<strong>KEY: Star's missing ${cast.starDeficit.toFixed(0)}pts > team deficit of ${Math.abs(Math.min(cast.castGap, 0))}pts.</strong> When ${leader.name} regresses to mean, the team takes the lead.` : cast.castGap >= 0 ? `<strong>Cast is already matching/beating the opponent.</strong> Star regression pushes this team into dominant territory.` : cast.strong ? `Cast is close to the opponent  within striking distance. Star regression makes this a real fight.` : cast.moderate ? `Cast is behind but game is still in range. Star regression helps but may not be enough alone.` : `<strong>Warning:</strong> Cast is ${Math.abs(cast.castGap)} pts behind the opponent. The whole team is struggling. Star regression of ~${cast.starDeficit.toFixed(0)}pts may not close a ${Math.abs(cast.castGap)}pt cast gap.`}`;

              const dmgDetail = damageLocked
                ? `<br><strong> Damage Locked:</strong> Trailing across ${dmg.snapshots} checks over ${dmg.timeSpanSec}s. Deficit: ${dmg.deficitThen}${dmg.deficitNow}pts (${dmg.trend}). Even if star + cast are strong, the hole is baked in.`
                : (starTeamTrailing && dmg.snapshots >= 2
                  ? `<br><strong>Momentum:</strong> Trailing by ${scoreMargin}pts. Trend: ${dmg.trend} (${dmg.snapshots} checks, ${dmg.timeSpanSec||'?'}s). Not locked: ${dmg.reason}.`
                  : `<br><strong>Momentum:</strong> Collecting data (${dmg.snapshots}/4 snapshots). ${dmg.reason}.`);

              const whyItMatters = coilTier === 'elite'
                ? `STRONGEST EDGE: Without ${leader.name}, the cast has ${cast.castScore}pts  only ${Math.abs(cast.castGap)}pts ${cast.castGap >= 0 ? 'AHEAD of' : 'behind'} the opponent's ${oppScore}pts.${cast.regressionFlips ? ` Star is missing ~${cast.starDeficit.toFixed(0)}pts, which is MORE than the ${Math.abs(cast.castGap)}pt gap. When ${leader.name} regresses to mean, this team takes the lead.` : ` The cast is already competing. Star regression pushes this team into dominant territory.`} The market is pricing in the star's cold stretch but ignoring that the rest of the team is holding.`
                : coilTier === 'standard'
                ? `Star is cold, game is close. Cast has ${cast.castScore}pts vs opponent's ${oppScore} (gap: ${cast.castGap}).${cast.regressionFlips ? ` Star's missing ~${cast.starDeficit.toFixed(0)}pts covers the gap.` : ''} Standard edge  star regression helps.`
                : coilTier === 'locked'
                ? `Star is cold AND deficit is locked in. Cast: ${cast.castScore}pts vs opp ${oppScore}. Despite cast effort, the hole is baked in  bet AGAINST the star's team.`
                : `CAUTION: Cast only has ${cast.castScore}pts vs opponent's ${oppScore} (gap: ${cast.castGap}). The whole team is broken, not just the star.${cast.starDeficit > 0 ? ` Star is missing ~${cast.starDeficit.toFixed(0)}pts but the cast gap is ${Math.abs(cast.castGap)}pts  regression alone can't close it.` : ''} Proceed with caution.`;

              const _coilPLabel = isNCAA() ? (per <= 2 ? `H${per}` : `OT`) : `Q${per}`;
              thesis.criteria[`star_${oppSide}`] = {met:true, strong:isStrongSignal, label:`Star Coil ${tierEmoji} [${tierLabel}]: ${leader.name} (${teamDisplay(leader.team, starTeamFull)})`, detail:`<strong>Player:</strong> ${leader.name}  averages ${star.ppg} PPG.<br><strong>Current:</strong> ${leader.pts} pts at ${_coilPLabel} ${clk} (expected ~${exp.toFixed(0)}).<br><strong>Pace:</strong> ${(pr*100).toFixed(0)}% of expected  below 65% threshold.<br><strong>Game Context:</strong> Score margin ${scoreMargin} pts. ${_coilPLabel}  prime window.${castDetail}${dmgDetail}<br><strong>Why it matters:</strong> ${whyItMatters}`, value:`${leader.pts}/${exp.toFixed(0)} pts (${(pr*100).toFixed(0)}%) | Cast gap: ${cast.castGap > 0 ? '+' : ''}${cast.castGap} | ${tierLabel}`};
            } else if (pr<0.65 && (isNCAA() ? gMins <= 35 : per<=3)) {
              // Star is cold but game not competitive or wrong window  monitoring only
              const starTeamFull2 = leader.team===aA ? aFull : hFull;
              const reason = isNCAA() ? (gMins<8 ? 'too early' : scoreMargin>_coilMaxMargin ? `blowout (${scoreMargin}pt margin)` : '') : (per<2 ? 'too early (Q1)' : scoreMargin>_coilMaxMargin ? `blowout (${scoreMargin}pt margin)` : '');
              signals.push({type:'star',text:`${leader.name} (${teamDisplay(leader.team, starTeamFull2)}) cold at ${(pr*100).toFixed(0)}% pace  but ${reason}. No coil.`,level:1});
              const windowLabel = isNCAA() ? '8-35 min' : 'Q2-Q3';
              thesis.criteria[`star_${oppSide}`] = {met:true, strong:false, label:`Star Cold (No Coil): ${leader.name}`, detail:`${leader.name} (${star.ppg} PPG) is at ${(pr*100).toFixed(0)}% pace but signal doesn't fire: ${reason || 'conditions not met'}. Star Coil needs ${windowLabel} + game within ${_coilMaxMargin} pts.`, value:`${(pr*100).toFixed(0)}% pace`, warn:true};
            } else if (pr<0.75 && gPct>=0.2) {
              const starTeamFull2 = leader.team===aA ? aFull : hFull;
              signals.push({type:'star',text:`${leader.name} (${teamDisplay(leader.team, starTeamFull2)}) ${leader.pts}pts, behind ${star.ppg} PPG pace (exp ~${exp.toFixed(0)})`,level:1});
              thesis.criteria[`star_${oppSide}`] = {met:true, strong:false, label:`Star Below Pace: ${leader.name} (${teamDisplay(leader.team, starTeamFull2)})`, detail:`${leader.name} (${star.ppg} PPG) has ${leader.pts} pts vs ${exp.toFixed(0)} expected. Below pace but not at critical 65% threshold yet.`, value:`${(pr*100).toFixed(0)}% pace`, warn:true};
            }
          }
        });

        // COMBINED - 2 independent signals on same game = combined edge
        const has3ptFragile=signals.some(s=>s.type==='3ptFragile'&&s.level===2);
        const hasStar=signals.some(s=>s.type==='star'&&s.level===2);
        let activeSignals = [has3ptFragile, hasStar].filter(Boolean).length;
        if (activeSignals >= 2) { sigCombined++; }

        // ===== RELAXED COMBINED CHECK =====
        // NBA: UNCHANGED  45%/10att (or 50%/8att), fragile 38%, <75% pace, per 1-3, reject weak cast
        // NCAA: LOOSENED  40%/7att (or 45%/5att), fragile 36%, <80% pace, 4-37min, accept weak cast
        // NCAA combined fires more often because fewer possessions = higher variance = soft convergence is still meaningful
        let soft3ptAway = false, soft3ptHome = false, softStarAny = false;
        let soft3ptAwayDetail = '', soft3ptHomeDetail = '', softStarDetail = '';
        let softStarCoilTeams = {};

        if (!has3ptFragile || !hasStar) {
          // --- Soft 3PT Fragile (only evaluate if strict didn't fire) ---
          const SOFT_FRAGILE_PCT = isNCAA() ? 36 : 38;
          const softHot = isNCAA()
            ? (chk) => (chk.pn >= 40 && chk.an >= 7) || (chk.pn >= 45 && chk.an >= 5)
            : (chk) => (chk.pn >= 45 && chk.an >= 10) || (chk.pn >= 50 && chk.an >= 8);

          if (!has3ptFragile) {
            // Away soft 3PT
            const awayLd = aS - hS;
            const _softMaxLd = isNCAA() ? 18 : 18, _softMinScore = isNCAA() ? 12 : 15;
            if (softHot(a3Check) && awayLd >= 2 && awayLd <= _softMaxLd && aS >= _softMinScore) {
              const aDurSoft = analyzeScoringDurability(aA, aS, a3M, hS);
              if (aDurSoft.pct3 >= SOFT_FRAGILE_PCT) {
                soft3ptAway = true;
                soft3ptAwayDetail = `${_aD} soft 3PT Fragile: ${a3Check.pn.toFixed(0)}% on ${a3Check.an} att, ${aDurSoft.pct3.toFixed(0)}% 3PT-dependent, lead ${awayLd}pts`;
              }
            }
            // Home soft 3PT
            const homeLd = hS - aS;
            if (softHot(h3Check) && homeLd >= 2 && homeLd <= _softMaxLd && hS >= _softMinScore) {
              const hDurSoft = analyzeScoringDurability(hA, hS, h3M, aS);
              if (hDurSoft.pct3 >= SOFT_FRAGILE_PCT) {
                soft3ptHome = true;
                soft3ptHomeDetail = `${_hD} soft 3PT Fragile: ${h3Check.pn.toFixed(0)}% on ${h3Check.an} att, ${hDurSoft.pct3.toFixed(0)}% 3PT-dependent, lead ${homeLd}pts`;
              }
            }
          } else {
            // Strict already fired  carry forward
            soft3ptAway = signals.some(s => s.type === '3ptFragile' && s.level === 2 && s.text.includes(_aD));
            soft3ptHome = signals.some(s => s.type === '3ptFragile' && s.level === 2 && s.text.includes(_hD));
          }

          // --- Soft Star Coil (only evaluate if strict didn't fire) ---
          if (!hasStar) {
            [...aLeaders, ...hLeaders].forEach(leader => {
              // Same star matching as strict coil: NCAA pre-game DB, NBA curated
              let star;
              if (isNCAA()) {
                star = ncaaStarCache.find(s => {
                  const leaderLast = leader.name.toLowerCase().split(' ').pop();
                  const starLast = s.name.split(' ').pop().toLowerCase();
                  return leaderLast === starLast && s.team === leader.team;
                });
              } else {
                star = state.stars.find(s => leader.name.toLowerCase().includes(s.name.split(' ').pop().toLowerCase()) && s.team === leader.team);
              }
              if (star) {
                const exp = getExpectedByTime(star.ppg, gMins);
                const pr = exp > 0 ? leader.pts / exp : 1;
                // NCAA Soft: <80% pace, wide window, margin 18. NBA Soft: <75% pace, per 1-3, margin 18 (UNCHANGED)
                const _softMaxMargin = isNCAA() ? 18 : 18;
                const _inSoftWindow = isNCAA() ? (gMins >= 4 && gMins <= 37) : (per >= 1 && per <= 3);
                const _softPaceThresh = isNCAA() ? 0.80 : 0.75;
                if (pr < _softPaceThresh && _inSoftWindow && scoreMargin <= _softMaxMargin) {
                  const starTeamSide = leader.team === aA ? 'away' : 'home';
                  const starTeamScore = starTeamSide === 'away' ? aS : hS;
                  const oppScore = starTeamSide === 'away' ? hS : aS;
                  const cast = analyzeSupportingCast(leader.pts, starTeamScore, oppScore, star.ppg, gMins);
                  // NCAA: accept all cast tiers except damage-locked (3PT Fragile is primary driver)
                  // NBA: accept elite/standard only (UNCHANGED from original)
                  const starTeamTrailing = (starTeamSide === 'away' && aS < hS) || (starTeamSide === 'home' && hS < aS);
                  const dmg = analyzeDamageLocked(gid, starTeamSide, 4, gMins);
                  const damageLocked = starTeamTrailing && dmg.locked;
                  let coilTier;
                  if (damageLocked) coilTier = 'locked';
                  else if (cast.strong) coilTier = 'elite';
                  else if (cast.moderate) coilTier = 'standard';
                  else coilTier = 'weak';
                  const _softCastOk = isNCAA() ? (coilTier !== 'locked') : (coilTier !== 'weak' && coilTier !== 'locked');
                  if (_softCastOk) {
                    softStarAny = true;
                    const starTeamFull = leader.team === aA ? aFull : hFull;
                    softStarDetail = `${leader.name} (${teamDisplay(leader.team, starTeamFull)}) soft Star Coil: ${(pr*100).toFixed(0)}% pace, ${isNCAA()?(per<=2?'H'+per:'OT'):'Q'+per}, margin ${scoreMargin}pts, cast tier ${coilTier}`;
                    softStarCoilTeams[leader.team] = { name: leader.name, damageLocked, dmg, cast, coilTier };
                  }
                }
              }
            });
          } else {
            // Strict already fired
            softStarAny = true;
            softStarCoilTeams = { ...starCoilTeams };
          }

          // --- Check if soft combined fires ---
          const hasSoft3pt = has3ptFragile || soft3ptAway || soft3ptHome;
          const hasSoftStar = hasStar || softStarAny;
          if (hasSoft3pt && hasSoftStar && activeSignals < 2) {
            // Soft combined fires! Promote to combined signal level
            activeSignals = 2;
            signalLevel = 2;
            sigCombined++;
            // Merge soft star coil teams into main starCoilTeams for bet-side logic
            Object.keys(softStarCoilTeams).forEach(k => { if (!starCoilTeams[k]) starCoilTeams[k] = softStarCoilTeams[k]; });
            // Add soft signals to the signals array so thesis cards show them
            const softParts = [];
            if (!has3ptFragile && (soft3ptAway || soft3ptHome)) {
              const detail = soft3ptAway ? soft3ptAwayDetail : soft3ptHomeDetail;
              signals.push({ type: '3ptFragile', text: `COMBINED BOOST: ${detail} (relaxed threshold  fires only with Star Coil convergence)`, level: 2 });
              softParts.push('3PT Fragile (soft)');
              sig3Fragile++;
              if (!state.signalFirstSeen[gid]) state.signalFirstSeen[gid] = Date.now();
              // Add thesis criteria for the soft 3PT signal
              if (soft3ptAway) {
                const aDurSoft = analyzeScoringDurability(aA, aS, a3M, hS);
                thesis.criteria['3ptfragile_away'] = { met: true, strong: true, label: `${_aD} 3PT Fragile (Combined Boost)`, detail: `<strong>Combined Boost:</strong> ${_aD} shooting ${a3Check.pn.toFixed(0)}% from 3 on ${a3Check.an} att with ${aDurSoft.pct3.toFixed(0)}% 3PT-dependent lead. Below strict solo thresholds, but combined with Star Coil convergence, the edge is actionable.<br><strong>Relaxed thresholds:</strong> ${isNCAA()?'40%/7att (or 45%/5att), 34% fragile, 2-20pt margin':'45%/10att (or 50%/8att), 38% fragile, 2-18pt margin'}.`, value: `${a3Check.pn.toFixed(0)}% 3PT + ${aDurSoft.pct3.toFixed(0)}% fragile (soft)` };
              }
              if (soft3ptHome) {
                const hDurSoft = analyzeScoringDurability(hA, hS, h3M, aS);
                thesis.criteria['3ptfragile_home'] = { met: true, strong: true, label: `${_hD} 3PT Fragile (Combined Boost)`, detail: `<strong>Combined Boost:</strong> ${_hD} shooting ${h3Check.pn.toFixed(0)}% from 3 on ${h3Check.an} att with ${hDurSoft.pct3.toFixed(0)}% 3PT-dependent lead. Below strict solo thresholds, but combined with Star Coil convergence, the edge is actionable.<br><strong>Relaxed thresholds:</strong> ${isNCAA()?'40%/7att (or 45%/5att), 34% fragile, 2-20pt margin':'45%/10att (or 50%/8att), 38% fragile, 2-18pt margin'}.`, value: `${h3Check.pn.toFixed(0)}% 3PT + ${hDurSoft.pct3.toFixed(0)}% fragile (soft)` };
              }
            } else { softParts.push('3PT Fragile'); }
            if (!hasStar && softStarAny) {
              signals.push({ type: 'star', text: `COMBINED BOOST: ${softStarDetail} (relaxed threshold  fires only with 3PT Fragile convergence)`, level: 2 });
              softParts.push('Star Coil (soft)');
              sigStar++;
              if (!state.signalFirstSeen[gid]) state.signalFirstSeen[gid] = Date.now();
              // Add thesis criteria for the soft star signal
              Object.keys(softStarCoilTeams).forEach(teamKey => {
                const sc = softStarCoilTeams[teamKey];
                const side = teamKey === aA ? 'away' : 'home';
                const oppSide = side === 'away' ? 'home' : 'away';
                if (!thesis.criteria[`star_${oppSide}`] || !thesis.criteria[`star_${oppSide}`].strong) {
                  const teamFull = teamKey === aA ? aFull : hFull;
                  const _softPLabel = isNCAA() ? (per <= 2 ? `H${per}` : `OT`) : `Q${per}`;
                  thesis.criteria[`star_${oppSide}`] = { met: true, strong: sc.coilTier === 'elite' || sc.coilTier === 'standard', label: `Star Coil (Combined Boost): ${sc.name} (${teamDisplay(teamKey, teamFull)})`, detail: `<strong>Combined Boost:</strong> ${sc.name} below pace in a competitive game. Below strict solo thresholds (${_softPLabel}, pace relaxed to <75%), but combined with 3PT Fragile convergence, the edge is actionable.<br><strong>Cast:</strong> ${sc.cast.castScore}pts vs opp (gap: ${sc.cast.castGap > 0 ? '+' : ''}${sc.cast.castGap}). Tier: ${sc.coilTier}.`, value: `Soft coil | Cast gap: ${sc.cast.castGap > 0 ? '+' : ''}${sc.cast.castGap} | ${sc.coilTier}` };
                }
              });
            } else { softParts.push('Star Coil'); }
            sendSignalNotification(' Combined Edge (Boost): ' + gLabel, softParts.join(' + ') + '  relaxed thresholds converge', gid, 'combined_soft');
          }
        }

        // Any strict L2 signal (solo or combined) should be actionable and recorded
        const hasAnyStrictL2 = signals.some(s => s.level === 2);
        if (activeSignals >= 2) { signalLevel = 2; }
        else if (hasAnyStrictL2) { signalLevel = 2; }
        else if (signals.some(s => s.level >= 1)) { signalLevel = 1; }

        // Track which games have which signals for chip click-to-expand
        const _gameInfo = { game: gLabel, gameFull: gLabelFull, aScore: aS, hScore: hS, per, clk, detail, eventId: gid };
        if (has3ptFragile || soft3ptAway || soft3ptHome) signalGames['3ptfragile'].push({ ..._gameInfo, sigDetail: signals.filter(s=>s.type==='3ptFragile'&&s.level===2).map(s=>s.text).join('; ') });
        if (hasStar || softStarAny) signalGames['star'].push({ ..._gameInfo, sigDetail: signals.filter(s=>s.type==='star'&&s.level===2).map(s=>s.text).join('; ') });
        if (activeSignals >= 2) signalGames['combined'].push({ ..._gameInfo, sigDetail: `${activeSignals} signals active: ${[has3ptFragile||soft3ptAway||soft3ptHome?'3PT Fragile':'',hasStar||softStarAny?'Star Coil':''].filter(Boolean).join(' + ')}${(!has3ptFragile&&(soft3ptAway||soft3ptHome))||(!hasStar&&softStarAny)?' (Combined Boost)':''}` });

        // Determine bet side and build thesis logic
        if (signalLevel >= 2) {
          // Figure out which team to bet ON (the one that benefits from regression)
          let betTeam = '', fadeTeam = '', reasons = [];
          const a3F = thesis.criteria['3ptfragile_away'], h3F = thesis.criteria['3ptfragile_home'];

          // Score each side: who has unsustainable advantages?
          let awayFade=0, homeFade=0;
          if (a3F?.met && a3F?.strong) awayFade++;  // away has 3PT fragile lead + trailing team can capitalize = fade away
          if (h3F?.met && h3F?.strong) homeFade++;  // home has 3PT fragile lead + trailing team can capitalize = fade home
          // 3PT Fragile fired but trailing team has no engine = weaker signal, don't count as full fade
          // (a3F/h3F.strong is already false when noEngine, so the above won't increment  correct)

          // Star Coil: bet direction depends on tier
          //   ELITE (cast strong): strong bet ON star's team (fade opponent)  1.5 weight
          //   STANDARD (cast moderate): normal bet ON star's team (fade opponent)  1.0 weight
          //   WEAK (cast weak): signal too weak to act on  0 weight (don't fade either side)
          //   LOCKED (damage locked): bet AGAINST star's team (flip)  1.0 weight
          const aStarCoil = starCoilTeams[aA];
          const hStarCoil = starCoilTeams[hA];
          if (aStarCoil?.coilTier === 'elite') { homeFade += 1.5; }       // away elite coil = away surges = fade home HARD
          else if (aStarCoil?.coilTier === 'standard') { homeFade += 1; } // away standard coil = fade home normal
          else if (aStarCoil?.coilTier === 'locked') { awayFade += 1; }   // away locked = away done = fade away
          // weak = no weight either direction
          if (hStarCoil?.coilTier === 'elite') { awayFade += 1.5; }       // home elite coil = home surges = fade away HARD
          else if (hStarCoil?.coilTier === 'standard') { awayFade += 1; } // home standard coil = home bounces back = fade away
          else if (hStarCoil?.coilTier === 'locked') { homeFade += 1; }   // home locked = home done = fade home

          // ===== CONFLICT DETECTION =====
          // When both sides have fade weight and the net difference is < 0.5,
          // signals effectively cancel each other  downgrade from COMBINED
          const _conflicting = awayFade > 0 && homeFade > 0 && Math.abs(awayFade - homeFade) < 0.5;
          if (_conflicting && activeSignals >= 2) {
            activeSignals = 1;
            sigCombined = Math.max(0, sigCombined - 1);
            console.log(`[Conflict] ${gLabel}: awayFade=${awayFade.toFixed(1)}, homeFade=${homeFade.toFixed(1)}  downgraded from COMBINED`);
          }

          // ===== DOUBLE REGRESSION CAVEAT =====
          // When 3PT Fragile fires on a team AND that same team has a cold star (below 70% pace),
          // the star's upward regression can offset their 3PT downward regression.
          // Their 3PT cools off (lose points) but their star heats up (gain points)  lead may hold.
          // Flag this as a caveat and reduce confidence.
          let doubleRegression = false;
          const _bxGame = _boxscoreMap[gid];
          if (_bxGame) {
            const checkDoubleRegress = (fragile3ptSide, fragileTeamAbbr) => {
              const top3 = teamScorerCache[fragileTeamAbbr] || [];
              const roster = _bxGame[fragile3ptSide] || [];
              for (const scorer of top3) {
                const sLast = scorer.name.split(' ').pop().toLowerCase();
                const player = roster.find(p => p.name.toLowerCase().split(' ').pop() === sLast);
                if (!player) continue;
                const exp = getExpectedByTime(scorer.ppg, gMins);
                const pr = exp > 0 ? (player.pts / exp) : 1;
                if (pr < 0.70) {
                  // This team's star is cold  their mean reversion UP offsets 3PT regression DOWN
                  doubleRegression = true;
                  const starName = scorer.name.split(' ').pop();
                  reasons.push(` DOUBLE REGRESSION: ${fragileTeamAbbr}'s 3PT will regress down, but ${starName} is at ${(pr*100).toFixed(0)}% pace (${player.pts}pts vs ${exp.toFixed(0)} exp). Star's upward regression could offset 3PT cooldown  lead may hold. Be cautious.`);
                  thesis.criteria['double_regression'] = { met: true, strong: false, label: ` Double Regression`, detail: `<strong>Double Regression Caveat:</strong> ${fragileTeamAbbr} is shooting hot from 3 (fragile), but ${starName} is cold at ${(pr*100).toFixed(0)}% pace.<br><strong>Problem:</strong> When ${fragileTeamAbbr}'s 3PT cools off, they lose points. But when ${starName} heats up, they gain points back. These two regressions offset each other.<br><strong>Impact:</strong> The 3PT fragile edge is weaker. The lead may not evaporate because the star picks up the slack. Do not auto-lock this bet.`, value: `${starName} at ${(pr*100).toFixed(0)}% pace`, warn: true };
                  break;
                }
              }
            };
            if (a3F?.met && a3F?.strong) checkDoubleRegress('away', aA);
            if (h3F?.met && h3F?.strong) checkDoubleRegress('home', hA);
          }

          // ===== HOME COURT FACTOR (NCAA ONLY  BIDIRECTIONAL BOOSTER) =====
          // NCAA home court = 3.5-4 pts (vs NBA 2.5). This is a structural force.
          // BOOSTER, not standalone signal. Amplifies existing signals:
          //   - When signals say bet HOME: tailwind (+0.5 fade weight + Kelly boost)
          //   - When signals say bet ROAD: headwind (+0.5 fade weight = penalty for road bet)
          // KEY CHANGE: In NCAA, 1 strict signal + home court tailwind = combined-level Kelly.
          // Rationale: Each standalone signal is already 5-condition strict. Fewer possessions
          // in NCAA = stronger regression certainty. Home court adds a 6th independent factor
          // (crowd energy, ref bias, travel fatigue) that compounds the edge. Requiring a
          // second strict signal to fire simultaneously is over-restrictive for NCAA.
          // NBA: NO CHANGE  this factor does not apply. NBA lines are sharper, need true combined.
          let homeCourtEdge = false;
          let homeCourtBoost = 0; // Kelly signal count boost (0 or 1)
          if (isNCAA()) {
            const _hcFactor = 0.5;
            if (awayFade > 0) {
              awayFade += _hcFactor; // boost fading away = tailwind for home bet
              homeCourtEdge = true;
              homeCourtBoost = 1;    // home court tailwind  treat as combined-level Kelly
            }
            if (homeFade > 0) {
              homeFade += _hcFactor; // boost fading home = headwind for road bet
              // No Kelly boost for road bets  headwind doesn't add confidence
            }
          }

          if (awayFade > homeFade) { betTeam = hA; fadeTeam = aA; }
          else if (homeFade > awayFade) { betTeam = aA; fadeTeam = hA; }
          else if (awayFade > 0) { betTeam = hA; fadeTeam = aA; }
          else { betTeam = aS < hS ? aA : hA; fadeTeam = aS < hS ? hA : aA; }

          // Build the narrative  use full names for clarity
          // NOTE: _aD and _hD already declared above in 3PT Fragile section
          if (a3F?.met && a3F?.strong) reasons.push(`${_aD} has a 3PT Fragile Lead  shooting hot from 3 AND lead depends on it (${a3F.value}). ${_hD} has the engine to capitalize.`);
          if (a3F?.met && !a3F?.strong && a3Check.isHot && aFragileData) reasons.push(`${_aD} has 3PT Fragile Lead but ${_hD}'s offense is broken (${hNon3Ppm.toFixed(1)} non-3PT PPM)  regression may not flip the result. Weaker signal.`);
          if (h3F?.met && h3F?.strong) reasons.push(`${_hD} has a 3PT Fragile Lead  shooting hot from 3 AND lead depends on it (${h3F.value}). ${_aD} has the engine to capitalize.`);
          if (h3F?.met && !h3F?.strong && h3Check.isHot && hFragileData) reasons.push(`${_hD} has 3PT Fragile Lead but ${_aD}'s offense is broken (${aNon3Ppm.toFixed(1)} non-3PT PPM)  regression may not flip the result. Weaker signal.`);
          if (aStarCoil?.coilTier === 'elite') reasons.push(` ${aStarCoil.name} (${_aD}) is coiled. Cast: ${aStarCoil.cast.castScore}pts vs opp (gap: ${aStarCoil.cast.castGap > 0 ? '+' : ''}${aStarCoil.cast.castGap}).${aStarCoil.cast.regressionFlips ? ' Star regression alone flips the lead.' : ' Cast is holding  star regression = surge.'} Strongest edge.`);
          else if (aStarCoil?.coilTier === 'standard') reasons.push(` ${aStarCoil.name} (${_aD}) is coiled. Cast gap: ${aStarCoil.cast.castGap}. Standard edge.`);
          else if (aStarCoil?.coilTier === 'locked') reasons.push(` ${aStarCoil.name} (${_aD}) is coiled BUT damage locked  deficit baked in. Fade ${_aD}.`);
          else if (aStarCoil?.coilTier === 'weak') reasons.push(` ${aStarCoil.name} (${_aD}) is coiled but cast gap is ${aStarCoil.cast.castGap}  whole team broken. No directional weight.`);
          if (hStarCoil?.coilTier === 'elite') reasons.push(` ${hStarCoil.name} (${_hD}) is coiled. Cast: ${hStarCoil.cast.castScore}pts vs opp (gap: ${hStarCoil.cast.castGap > 0 ? '+' : ''}${hStarCoil.cast.castGap}).${hStarCoil.cast.regressionFlips ? ' Star regression alone flips the lead.' : ' Cast is holding  star regression = surge.'} Strongest edge.`);
          else if (hStarCoil?.coilTier === 'standard') reasons.push(` ${hStarCoil.name} (${_hD}) is coiled. Cast gap: ${hStarCoil.cast.castGap}. Standard edge.`);
          else if (hStarCoil?.coilTier === 'locked') reasons.push(` ${hStarCoil.name} (${_hD}) is coiled BUT damage locked  deficit baked in. Fade ${_hD}.`);
          else if (hStarCoil?.coilTier === 'weak') reasons.push(` ${hStarCoil.name} (${_hD}) is coiled but cast gap is ${hStarCoil.cast.castGap}  whole team broken. No directional weight.`);

          // Home Court Factor narrative (NCAA only  homeCourtEdge is always false for NBA)
          if (isNCAA() && betTeam === hA) {
            const boostLabel = thesis.homeCourtBoost ? ' Kelly boosted to combined-level.' : '';
            reasons.push(` HOME COURT TAILWIND: Betting ${_hD} (home team). NCAAB home court ~3.5-4 pts  crowd energy + regression signals = double tailwind.${boostLabel}`);
            thesis.criteria['homecourt_boost'] = { met: true, strong: true, label: ` Home Court Booster`, detail: `<strong>Home Court Booster (NCAA):</strong> ${_hD} is at home. NCAAB home court averages ~3.5-4 pts  an independent structural factor.<br><strong>Why this is a BOOSTER, not a standalone signal:</strong> Home court alone doesn't generate alpha. But when a strict signal fires AND the bet is on the home team, the home court compounds the edge:<br>&nbsp;&nbsp; Crowd energy sustains runs triggered by regression<br>&nbsp;&nbsp; Ref bias in foul calls (documented ~60% home foul advantage)<br>&nbsp;&nbsp; Travel fatigue amplifies road team's 3PT regression<br><strong>Kelly Impact:</strong> Single strict signal + home court booster = combined-level Kelly sizing.${activeSignals >= 2 ? ' (Already combined  booster adds further confidence.)' : ` Effective signal count: ${activeSignals}  ${effectiveSignals}.`}<br><strong>The math:</strong> Each standalone signal is already 5-condition strict. Fewer NCAA possessions = stronger regression certainty. Home court is the 6th independent factor. Requiring a 2nd strict signal to also fire simultaneously is over-restrictive for NCAA.`, value: `Tailwind (+0.5 weight, +1 Kelly boost)` };
          } else if (isNCAA() && betTeam === aA && homeFade > 0) {
            reasons.push(` HOME COURT HEADWIND: Betting ${_aD} (road team). NCAAB home court ~3.5-4 pts works against road comebacks  signal must overcome structural disadvantage.`);
            thesis.criteria['homecourt_boost'] = { met: true, strong: false, label: ` Home Court Headwind`, detail: `<strong>Home Court Headwind:</strong> ${_aD} is on the road. NCAAB home court averages ~3.5-4 pts working AGAINST the road team.<br><strong>Why it weakens your signal:</strong> Even if regression happens, the home crowd fuels counter-runs. Road teams need stronger regression to overcome the structural disadvantage.<br><strong>Kelly Impact:</strong> No Kelly boost for road bets. Signal must stand on its own merit.<br><strong>Impact:</strong> Headwind weight applied (+0.5 to fade). No Kelly confidence boost.`, value: `Road headwind (+0.5 weight, no Kelly boost)` };
          }

          const strongCriteria = Object.values(thesis.criteria).filter(c => c.met && c.strong).length;
          const allCriteria = Object.values(thesis.criteria).filter(c => c.met).length;

          const betTeamFull = betTeam === aA ? aFull : hFull;
          const fadeTeamFull = fadeTeam === aA ? aFull : hFull;
          thesis.betSide = betTeam;
          thesis.betSideFull = betTeamFull;
          thesis.fadeSide = fadeTeam;
          thesis.fadeSideFull = fadeTeamFull;
          thesis.betLogic = reasons.join('. ') + '.';
          // NCAA: home court booster counts as strong criteria for confidence level
          const _boostCriteria = thesis.homeCourtBoost ? 1 : 0;
          thesis.confidence = (strongCriteria + _boostCriteria) >= 3 ? 'high' : (strongCriteria + _boostCriteria) >= 2 ? 'high' : allCriteria >= 2 ? 'medium' : 'low';
          thesis.doubleRegression = doubleRegression;
          // Double regression caveat: downgrade confidence  don't auto-lock
          if (doubleRegression) {
            thesis.confidence = thesis.confidence === 'high' ? 'medium' : 'low';
          }
          thesis.strongCount = strongCriteria;
          thesis.totalMet = allCriteria;
          thesis.signals = signals;
          thesis.signalLevel = signalLevel;
          thesis.homeCourtEdge = homeCourtEdge && betTeam === hA;
          thesis.homeCourtBoost = homeCourtBoost > 0 && betTeam === hA;
          // Effective signal count: base signals + home court booster (NCAA only, home bets only)
          const effectiveSignals = activeSignals + (thesis.homeCourtBoost ? homeCourtBoost : 0);
          // Urgency: how much game runway remains for regression
          const _urgency = getUrgency(per, clk);
          thesis.urgency = _urgency;
          const _tOdds = matchOdds(aA, hA, aFull, hFull);
          let _betML = null, _implP = 0;
          if (_tOdds) {
            _betML = betTeam === aA ? _tOdds.awayML : _tOdds.homeML;
            _implP = _betML < 0 ? Math.abs(_betML)/(Math.abs(_betML)+100) : 100/(_betML+100);
            thesis.marketOdds = _betML;
            thesis.impliedP = _implP;
            // Store odds key for LEC tracking
            thesis.oddsKey = _tOdds.away + ' vs ' + _tOdds.home;
            const _drMult = doubleRegression ? 0.5 : 1; // halve Kelly when double regression detected
            const _k = kellySize(_implP, _betML, null, effectiveSignals, _urgency.mult * _drMult);
            thesis.kellyPct = _k.fStar;
            thesis.kellyBet = _k.bet;
            thesis.kellyEdge = _k.edge;
            thesis.estimatedP = _k.p;
          }
          thesis.eventId = event.id;
          thesis.betTeamAbbr = betTeam;
          // Always log the bet  use default -110 odds if live odds unavailable
          const _logOdds = _betML || -110;
          const _logImplP = _betML ? _implP : 0.524; // -110 implied = 52.4%
          autoLogBet(event.id, betTeam, 'ML', signals.filter(x=>x.level===2).map(x=>x.type), _logOdds, _logImplP, effectiveSignals, _urgency.mult);
          gameTheses.push(thesis);
        }

        // Counterfactual: track near-miss signals (level 1 only, no level 2)
        // Games where conditions were developing but didn't fully trigger
        if (signalLevel === 1 && isLive) {
          const l1signals = signals.filter(s => s.level === 1);
          if (l1signals.length > 0) {
            const nmKey = event.id + '_nm';
            if (!state.nearMisses.find(n => n.key === nmKey)) {
              const trailing = aS < hS ? aA : hA;
              state.nearMisses.push({
                key: nmKey, eventId: event.id, game: gLabel,
                awayTeam: aA, homeTeam: hA,
                hypotheticalSide: trailing,
                signals: l1signals.map(s => s.type),
                signalTexts: l1signals.map(s => s.text),
                awayScore: aS, homeScore: hS, period: per, clock: clk,
                timestamp: Date.now(), mode: currentMode,
                gameCompleted: false, finalAwayScore: null, finalHomeScore: null, wouldHaveWon: null
              });
              if (state.nearMisses.length > 300) state.nearMisses = state.nearMisses.slice(-200);
              localStorage.setItem('nearMisses', JSON.stringify(state.nearMisses));
            }
          }
        }
      }

      const cc = signalLevel===2?'signal-fire':signalLevel===1?'signal-warn':'';
      const hc = isLive?'game-card-header live-pulse':'game-card-header';

      const bar3 = (p,m,a,t) => {
        const v=parseFloat(p)||0, bc=v>=50?'hot':v>=getLeague3PtAvg()?'normal':'cold';
        return `<div class="stat-bar-row"><span class="stat-bar-label">${t} 3PT%</span><div class="stat-bar-track"><div class="stat-bar-fill ${bc}" style="width:${Math.min(v,100)}%">${v.toFixed(0)}%</div><div class="stat-bar-avg" style="left:${getLeague3PtAvg()}%" data-label="${getLeague3PtAvg()}%"></div></div><span class="stat-bar-value">${m||'-'}/${a||'-'}</span></div>`;
      };

      // Durability bars
      let durabilityHTML = '';
      if (isLive && (aS > 0 || hS > 0)) {
        const aDur = analyzeScoringDurability(aA, aS, a3M, hS);
        const hDur = analyzeScoringDurability(hA, hS, h3M, aS);
        const durBar = (team, dur) => {
          if (dur.pct3 <= 0) return '';
          const cls = dur.durability;
          const w = Math.min(dur.pct3, 100);
          const col = dur.fragile ? 'var(--red)' : dur.durable ? 'var(--green)' : 'var(--accent)';
          return `<div class="durability-bar ${cls}"><span>${team}</span><div class="durability-meter"><div class="durability-meter-fill" style="width:${w}%;background:${col};"></div></div><span>${dur.label}</span></div>`;
        };
        durabilityHTML = durBar(aA, aDur) + durBar(hA, hDur);
      }

      // FT info
      let foulHTML = '';
      if (isLive && (aFTA > 0 || hFTA > 0)) {
        const ftGap = Math.abs(aFTA - hFTA);
        foulHTML = `<div class="stat-bar-row"><span class="stat-bar-label">FTA</span><span style="flex:1;font-size:11px;">${aA}: ${aFTA} | ${hA}: ${hFTA}</span></div>`;
      }

      const isFav = state.favorites.includes(gid);
      const periodLabel = isNCAA() ? (per <= 2 ? `H${per}` : `OT${per-2}`) : `Q${per}`;
      const _oddsHTML = buildOddsHTML(aA,hA,aFull,hFull);

      // Signal summary for card header
      const sigSummary = signals.filter(s=>s.level===2).map(s => {
        const icons = {'3pt':'3PT','star':'STAR','fragile':'FRAG','combined':'COMBO'};
        return icons[s.type] || s.type.toUpperCase();
      });

      cards += `<div class="game-card ${cc}" data-game-id="${gid}">
        <div class="${hc}">
          <span>${isLive ? '<span style="color:var(--red);font-weight:700;">LIVE</span> ' + periodLabel + ' ' + clk : 'UPCOMING'}</span>
          <span style="display:flex;align-items:center;gap:6px;">
            ${sigSummary.length ? '<span style="font-size:9px;font-weight:700;color:var(--accent);background:var(--accent-light);padding:1px 6px;border-radius:3px;">' + sigSummary.join(' + ') + '</span>' : ''}
            <span class="fav-star" onclick="toggleFavorite('${gid}')" style="cursor:pointer;font-size:14px;">${isFav?'\u2605':'\u2606'}</span>
          </span>
        </div>
        <div class="game-card-body">
          <!-- SCOREBOARD -->
          <div class="game-teams">
            <div class="team-block">
              <div class="team-name">${teamLogoImg(aLogo, 20)}${teamDisplayShort(aA, aFull)}</div>
              <div class="team-record">${aRec}</div>
              ${teamProfileHTML(aA, 'away', aLogo)}
              <div class="team-score">${isLive?aS:'-'}</div>
            </div>
            <div class="vs-block">
              <div class="vs-text" style="font-size:11px;font-weight:500;color:var(--text-muted);opacity:0.6;">vs</div>
            </div>
            <div class="team-block">
              <div class="team-name">${teamLogoImg(hLogo, 20)}${teamDisplayShort(hA, hFull)}</div>
              <div class="team-record">${hRec}</div>
              ${teamProfileHTML(hA, 'home', hLogo)}
              <div class="team-score">${isLive?hS:'-'}</div>
            </div>
          </div>
          ${gameLinksHTML(espnLink, leaguePassLink)}
          <!-- ODDS -->
          ${_oddsHTML}
          <!-- LIVE STATS -->
          ${isLive?`<div class="stat-bars">
            ${bar3(a3P,a3M,a3A,aA)}
            ${bar3(h3P,h3M,h3A,hA)}
            ${foulHTML}
          </div>
          ${durabilityHTML}
          ${(()=>{
            const bx = _boxscoreMap[gid];
            const getTeamTop3 = (side, teamAbbr) => {
              const top3 = teamScorerCache[teamAbbr] || [];
              const roster = bx?.[side] || [];
              if (roster.length === 0 && top3.length === 0) return [];
              // Start with season top scorers who are actually playing
              const result = [];
              const usedNames = new Set();
              top3.forEach(s => {
                const sLast = s.name.split(' ').pop().toLowerCase();
                const player = roster.find(p => p.name.toLowerCase().split(' ').pop() === sLast);
                if (player) {
                  result.push({ name: s.name, pts: player.pts });
                  usedNames.add(player.name.toLowerCase());
                }
              });
              // Backfill with top scorers from boxscore if we have <3
              if (result.length < 3) {
                roster
                  .filter(p => p.pts > 0 && !usedNames.has(p.name.toLowerCase()))
                  .sort((a, b) => b.pts - a.pts)
                  .slice(0, 3 - result.length)
                  .forEach(p => result.push({ name: p.name, pts: p.pts }));
              }
              return result.slice(0, 3);
            };
            const aTop3 = getTeamTop3('away', aA);
            const hTop3 = getTeamTop3('home', hA);
            if (aTop3.length === 0 && hTop3.length === 0) return '';
            const renderPlayer = (p) => {
              const lastName = p.name.split(' ').pop();
              return `<div style="display:flex;align-items:center;gap:6px;padding:2px 0;"><strong style="min-width:75px;">${lastName}</strong> <span>${p.pts}pts</span></div>`;
            };
            const renderTeam = (abbr, players) => {
              if (players.length === 0) return '';
              return `<div style="flex:1;padding:5px 8px;background:var(--bg);border-radius:6px;"><div style="font-size:9px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:3px;">${abbr}</div>${players.map(renderPlayer).join('')}</div>`;
            };
            return `<div style="display:flex;gap:8px;margin-top:6px;font-size:11px;">${renderTeam(aA, aTop3)}${renderTeam(hA, hTop3)}</div>`;
          })()}`:''}
          <!-- SIGNALS -->
          ${signals.length?(()=>{
            const rec=getRecommendation(aS,hS,aA,hA,per,clk,signalLevel);
            let titleText,recDetail='',betBtn='';
            if(signalLevel<2){
              titleText='DEVELOPING';
            } else if(rec.type==='ML'){
              titleText=`EDGE \u2014 ML PLAY: ${rec.side} ML`;
              recDetail=`<div style="font-size:11px;margin-top:4px;font-weight:700;color:var(--green);">&#x1F4B0; ${rec.reasoning}</div>`;
              betBtn=`<div style="margin-top:6px;"><button class="btn btn-orange btn-sm" onclick="openLogModal('${aA} @ ${hA}','${rec.side} ML','Mean Reversion - ML')">Log ML Bet (${rec.units}u)</button></div>`;
            } else if(rec.type==='SPREAD'){
              titleText=`EDGE \u2014 SPREAD: ${rec.side} ${rec.spreadLine}`;
              recDetail=`<div style="font-size:11px;margin-top:4px;font-weight:700;color:var(--purple);">&#x1F3AF; ${rec.reasoning}</div>`;
              betBtn=`<div style="margin-top:6px;"><button class="btn btn-purple btn-sm" onclick="openLogModal('${aA} @ ${hA}','${rec.side} ${rec.spreadLine}','Mean Reversion - Spread')">Log Spread Bet (${rec.units}u)</button></div>`;
            } else {
              titleText='EDGE \u2014 WATCH';
              recDetail=`<div style="font-size:11px;margin-top:4px;font-weight:700;color:var(--text-muted);">&#x1F440; ${rec.reasoning}</div>`;
            }
            const bgColor=signalLevel===2?(rec.type==='WATCH'?'var(--accent-light)':'var(--accent-light)'):'var(--orange-light)';
            const borderColor=signalLevel===2?'var(--accent)':'var(--orange)';
            const titleColor=signalLevel===2?'var(--accent)':'var(--orange)';
            return `<div style="margin-top:8px;padding:8px 10px;border-radius:6px;background:${bgColor};border-left:3px solid ${borderColor};">
              <div style="font-size:10px;font-weight:800;color:${titleColor};margin-bottom:4px;letter-spacing:0.5px;">${titleText}</div>
              ${signals.map(s=>`<div style="font-size:11px;color:var(--text-secondary);line-height:1.5;">${s.level===2?'&#x1F525;':'&#x26A0;&#xFE0F;'} ${s.text}</div>`).join('')}
              ${recDetail}
              ${betBtn}
              ${state.signalFirstSeen[gid]?`<div style="font-size:9px;color:var(--text-muted);margin-top:4px;">\u23F1 ${Math.floor((Date.now()-state.signalFirstSeen[gid])/60000)}m ago</div>`:''}
            </div>`;
          })():`<div style="margin-top:8px;padding:6px 10px;border-radius:6px;background:var(--bg);border-left:3px solid var(--border);"><div style="font-size:10px;font-weight:700;color:var(--text-muted);letter-spacing:0.5px;">NO SIGNAL  DO NOT BET</div><div style="font-size:10px;color:var(--text-muted);margin-top:2px;">Wait for edge. No signal = no edge = no bet.</div></div>`}
        </div>
      </div>`;

      // 3PT TRACKER CARD
      if (isLive) {
        const ap=parseFloat(a3P)||0, hp=parseFloat(h3P)||0;
        const aHot=ap>=50&&parseInt(a3A)>=8, hHot=hp>=50&&parseInt(h3A)>=8;
        const aWarm=ap>=45&&parseInt(a3A)>=6&&!aHot, hWarm=hp>=45&&parseInt(h3A)>=6&&!hHot;
        const cb=(aHot||hHot)?'hot-card':(aWarm||hWarm)?'warm-card':'';
        const _pCount=isNCAA()?2:4,_pPfx=isNCAA()?'H':'Q';const qBoxes=(t,p,m,a)=>{const pv=parseFloat(p)||0,mv=parseInt(m)||0,av=parseInt(a)||0;let b='';for(let q=1;q<=_pCount;q++){const act=q===per,past=q<per;if(past||act){const hc2=pv>=50&&av>=8&&act?'hot-q':act?'active-q':'';b+=`<div class="qtr-box ${hc2}"><div class="qtr-label">${_pPfx}${q}${act?' *':''}</div><div class="qtr-value ${act&&pv>=50?'hot-val':'normal-val'}">${act?pv.toFixed(0)+'%':'-'}</div><div class="qtr-detail">${act?mv+'/'+av:'done'}</div></div>`;}else b+=`<div class="qtr-box"><div class="qtr-label">${_pPfx}${q}</div><div class="qtr-value normal-val">-</div><div class="qtr-detail">-</div></div>`;}return b;};
        const tRow=(t,p,m,a,hot,warm)=>{const badge=hot?'<span class="signal-badge signal-fire">UNSUSTAINABLE</span>':warm?'<span class="signal-badge signal-moderate">ELEVATED</span>':'<span class="signal-badge signal-none">Normal</span>';return `<div style="margin-bottom:12px;"><div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;"><span style="font-weight:800;font-size:14px;color:var(--text-primary);">${t}</span>${badge}</div>${bar3(p,m,a,t)}<div class="qtr-grid">${qBoxes(t,p,m,a)}</div></div>`;};
        tpCards+=`<div class="three-pt-card ${cb}"><div class="three-pt-card-header"><span style="display:inline-flex;align-items:center;gap:4px;">${teamLogoImg(aLogo,16)}${gLabel}${teamLogoImg(hLogo,16)}</span><span>${periodLabel} ${clk}</span></div><div class="three-pt-card-body">${tRow(aA,a3P,a3M,a3A,aHot,aWarm)}${tRow(hA,h3P,h3M,h3A,hHot,hWarm)}${(aHot||hHot)?`<div style="text-align:center;margin-top:6px;"><button class="btn btn-purple btn-sm" onclick="openLogModal('${gLabel}','3PT Reg','3PT Regression')">Log 3PT Bet</button></div>`:''}</div></div>`;
      }
    }

    grid.innerHTML = cards || `<div class="empty-state" style="grid-column:1/-1;"><p>No games.</p></div>`;
    tpGrid.innerHTML = tpCards || `<div class="empty-state" style="grid-column:1/-1;"><p>No live games.</p></div>`;

    // Signal Priority: Sort gameTheses by strength
    gameTheses.sort((a,b) => (b.strongCount||0) - (a.strongCount||0));

    // Build Quick Bet Action Cards
    const qbPanel = document.getElementById('quick-bet-panel');
    const qbCards = document.getElementById('quick-bet-cards');
    if (gameTheses.length > 0) {
      qbPanel.style.display = 'block';
      qbCards.innerHTML = gameTheses.map(t => {
        let sigs = t.signals.filter(s=>s.level===2).map(s => {
          const badges = {'3pt':'3PT','star':'STAR','fragile':'FRAGILE'};
          return '<span class="signal-badge badge-' + s.type + '">' + (badges[s.type]||s.type.toUpperCase()) + '</span>';
        }).join(' ');
        if (t.homeCourtBoost) sigs += ' <span class="signal-badge badge-road"> HOME BOOST</span>';
        else if (t.homeCourtEdge) sigs += ' <span class="signal-badge badge-road">HOME COURT</span>';
        const _urg = t.urgency || { level: 'PRIME', icon: '', color: 'var(--green)' };
        sigs += ' <span class="signal-badge" style="background:' + _urg.color + ';color:#fff;font-size:9px;">' + _urg.icon + ' ' + _urg.level.replace('_', ' ') + '</span>';
        const oddsStr = t.marketOdds ? ' @ ' + (t.marketOdds > 0 ? '+' : '') + t.marketOdds : '';
        const kellyStr = t.kellyPct ? ' (Kelly: ' + (t.kellyPct*100).toFixed(1) + '%)' : '';
        const elapsed = state.signalFirstSeen[t.eventId] ? Math.floor((Date.now() - state.signalFirstSeen[t.eventId]) / 60000) : 0;
        const elapsedStr = elapsed > 0 ? ' \u2022 Signal active ' + elapsed + 'm' : ' \u2022 NEW';
        return '<div style="background:var(--card-bg);border:1px solid var(--accent);border-radius:var(--radius);padding:14px 18px;margin-bottom:10px;display:flex;justify-content:space-between;align-items:center;box-shadow:var(--shadow-sm);animation:slideUp 0.3s ease;border-left:4px solid ' + _urg.color + ';">' +
          '<div><div style="font-size:14px;font-weight:800;color:var(--accent);letter-spacing:-0.3px;display:flex;align-items:center;gap:5px;">' + teamLogoImg(t.betSide === t.aTeam ? t.aLogo : t.hLogo, 20) + 'BET ' + t.betSide + ' ML' + oddsStr + '</div>' +
          '<div style="font-size:11px;color:var(--text-secondary);margin-top:3px;">' + t.game + ' \u2022 ' + (isNCAA() ? ((t.per||0)<=2 ? 'H'+(t.per||'?') : 'OT') : 'Q'+(t.per||'?')) + ' ' + (t.clk||'') + kellyStr + elapsedStr + '</div>' +
          '<div style="margin-top:6px;display:flex;gap:4px;flex-wrap:wrap;">' + sigs + '</div></div>' +
          '<div style="text-align:right;padding-left:16px;"><div style="font-size:24px;font-weight:900;color:var(--accent);letter-spacing:-1px;line-height:1;">' + (t.strongCount||0) + '</div><div style="font-size:9px;font-weight:600;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px;margin-top:2px;">SIGNALS</div></div></div>';
      }).join('');
    } else {
      qbPanel.style.display = 'none';
      qbCards.innerHTML = '';
    }

    // Record signal history
    gameTheses.forEach(t => {
      const histKey = t.eventId + '_' + (t.betSide||'');
      const existing = state.signalHistory.find(h => h.key === histKey);
      if (!existing) {
        state.signalHistory.push({
          key: histKey, game: t.game||'', betSide: t.betSide||'', signals: (t.signals||[]).filter(s=>s.level===2).map(s=>s.type),
          strongCount: t.strongCount||0, confidence: t.confidence||'', odds: t.marketOdds||0,
          timestamp: Date.now(), date: new Date().toLocaleDateString()
        });
        if (state.signalHistory.length > 200) state.signalHistory = state.signalHistory.slice(-150);
        localStorage.setItem('signalHistory', JSON.stringify(state.signalHistory));
      }
    });

    // Auto-track signals for backtest
    gameTheses.forEach(t => {
      if (t.signalLevel >= 2 && t.betSide) {
        const rec = getRecommendation(t.aScore, t.hScore, t.aTeam, t.hTeam, t.per, t.clk, t.signalLevel);
        autoTrackSignal(t, rec);
      }
    });


    // Update counts
    document.getElementById('live-3ptfragile-signals').textContent = sig3Fragile;
    document.getElementById('live-star-signals').textContent = sigStar;
    document.getElementById('live-combined-signals').textContent = sigCombined;
    // Glow effect on combined chip when 2+ signals fire
    const combinedChip = document.getElementById('live-combined-signals').closest('.signal-chip');
    if (sigCombined > 0) { combinedChip.classList.add('combined-active'); } else { combinedChip.classList.remove('combined-active'); }
    document.getElementById('threept-hot-count').textContent = hotTeams;
    document.getElementById('threept-warm-count').textContent = warmTeams;

    const totalSigs = sig3Fragile+sigStar;
    if (totalSigs>0) { document.getElementById('live-badge').style.display='inline'; document.getElementById('live-badge').textContent=totalSigs; }
    else document.getElementById('live-badge').style.display='none';
    if (hotTeams>0) { document.getElementById('threept-badge').style.display='inline'; document.getElementById('threept-badge').textContent=hotTeams; }

    // EDGE THESIS PANEL
    const etc = document.getElementById('edgeThesisContainer');
    const etCards = document.getElementById('edgeThesisCards');
    if (gameTheses.length > 0) {
      etc.classList.add('active');
      document.getElementById('thesisCount').textContent = gameTheses.length + ' LIVE';
      // Sort by confidence (high first)
      gameTheses.sort((a,b) => (b.strongCount||0) - (a.strongCount||0));
      etCards.innerHTML = gameTheses.map(t => {
        const confDots = Array.from({length:5}, (_,i) => {
          if (i < t.strongCount) return `<div class="conf-dot lit-red"></div>`;
          if (i < t.totalMet) return `<div class="conf-dot lit"></div>`;
          return `<div class="conf-dot"></div>`;
        }).join('');
        const confCls = t.confidence==='high'?'high':t.confidence==='medium'?'medium':'low';
        const scoreDiff = Math.abs(t.aScore - t.hScore);
        const leading = t.aScore > t.hScore ? teamDisplay(t.aTeam, t.aTeamFull) : t.hScore > t.aScore ? teamDisplay(t.hTeam, t.hTeamFull) : 'TIE';
        const trailing = t.aScore > t.hScore ? teamDisplay(t.hTeam, t.hTeamFull) : t.hScore > t.aScore ? teamDisplay(t.aTeam, t.aTeamFull) : '';

        // Build criteria cards
        const criteriaKeys = ['3ptfragile_away','3ptfragile_home','star_away','star_home'];
        const criteriaHTML = criteriaKeys.map(k => {
          const c = t.criteria[k];
          if (!c) return '';
          const cls = c.met ? (c.strong ? 'met' : 'met') : 'not-met';
          const icon = c.met ? (c.strong ? '&#x1F525;' : '&#x26A0;&#xFE0F;') : '&#x2796;';
          const valCls = c.met ? (c.strong ? '' : 'warn') : 'neg';
          return `<div class="criteria-item ${cls}">
            <span class="criteria-check">${icon}</span>
            <div class="criteria-text">
              <span class="criteria-label">${c.label}</span>
              <span class="criteria-value ${valCls}">${c.value}</span>
              <span class="criteria-detail">${c.detail}</span>
            </div>
          </div>`;
        }).filter(Boolean).join('');

        const betSideDisplay = teamDisplay(t.betSide, t.betSideFull);
        const fadeSideDisplay = teamDisplay(t.fadeSide, t.fadeSideFull);
        const aTeamDisplay = teamDisplay(t.aTeam, t.aTeamFull);
        const hTeamDisplay = teamDisplay(t.hTeam, t.hTeamFull);

        return `<div class="thesis-card">
          <div class="thesis-game-bar">
            <div>
              <div class="thesis-game-label" style="display:flex;align-items:center;gap:6px;">${teamLogoImg(t.aLogo, 18)}${t.gameFull || t.game}${teamLogoImg(t.hLogo, 18)}</div>
              <div class="thesis-game-period">${isNCAA() ? (t.per<=2 ? 'H'+t.per : 'OT'+(t.per-2)) : 'Q'+t.per} ${t.clk} ${leading!=='TIE'?`| ${leading} leads by ${scoreDiff}`:'| Tied'}</div>
            </div>
            <div class="thesis-confidence">
              <div class="conf-meter">${confDots}</div>
              <span class="conf-label ${confCls}">${t.totalMet} criteria met</span>
            </div>
          </div>
          <div class="thesis-body">
            <div class="thesis-bet-line">
              <div>
                <div class="thesis-bet-action">BET ${betSideDisplay} ML ${t.marketOdds ? "(" + (t.marketOdds > 0 ? "+" : "") + t.marketOdds + ")" : ""}</div>${t.kellyPct ? '<div style="color:var(--green);font-size:12px;margin-top:4px"><strong>KELLY:</strong> ' + t.kellyPct + '% of bankroll ($' + t.kellyBet + ') &bull; <strong>Our P:</strong> ' + t.estimatedP + '% vs <strong>Market:</strong> ' + (t.impliedP * 100).toFixed(1) + '%</div>' : ""}
                <div class="thesis-bet-side">Fade ${fadeSideDisplay}  ${t.confidence.toUpperCase()} confidence</div>
              </div>
              <button class="btn btn-orange btn-sm" onclick="openLogModal('${t.game}','Live ML','Mean Reversion')">Log This Bet</button>
            </div>
            <div class="thesis-logic">
              <div class="thesis-logic-title">Why This Is an Edge</div>
              <div class="thesis-logic-text" style="line-height:1.7;">
                <div style="margin-bottom:6px;">${t.betLogic}</div>
                <div style="padding:8px 10px;background:var(--accent-light);border-radius:6px;border-left:3px solid var(--accent);margin-top:6px;font-size:11px;line-height:1.6;">
                  <strong>The Thesis:</strong> The live ML is priced on the current score, but the score is built on unsustainable conditions. When those conditions normalize, the true probability shifts toward <strong>${betSideDisplay}</strong>. The market is slow to reprice these temporary swings  that's the edge.
                </div>
              </div>
            </div>
            <div class="thesis-criteria">${criteriaHTML}</div>
            <div class="thesis-actions">
              <span style="font-size:10px;color:#666;display:inline-flex;align-items:center;gap:3px;">${teamLogoImg(t.aLogo, 14)}${aTeamDisplay} ${t.aScore} - ${t.hScore} ${hTeamDisplay}${teamLogoImg(t.hLogo, 14)} | ${t.detail}</span>
              <button class="btn btn-green btn-sm" onclick="openLogModal('${t.game}','Live ML','Mean Reversion')">Log Bet</button>
            </div>
          </div>
        </div>`;
      }).join('');
    } else { etc.classList.remove('active'); etCards.innerHTML = ''; }

    // Store signal games globally for chip click-to-expand
    window._signalGames = signalGames;

    updateStarTracker(events);
        renderBetLog();
        updateBacktestPanel();
        updateKelly();
        autoResolveBets(); // Check for final scores and auto-mark W/L
        resolveSignalTracker(); // Check signal tracker results


  } catch (err) {
    setConnStatus('error');
    if (state.consecutiveErrors < 3) {
      grid.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><p style="color:var(--orange);">Connection issue (${err.message}). Retrying next cycle...</p></div>`;
    } else {
      grid.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><p style="color:var(--red);">Connection failed ${state.consecutiveErrors}x. ESPN may be rate-limiting. Wait 30s then try again.</p></div>`;
    }
  }
}

// ==================== STAR TRACKER ====================
function updateStarTracker(events) {
  const tb = document.getElementById('live-star-status');
  let rows = '';
  for (const ev of events) {
    if (ev.status?.type?.state !== 'in') continue;
    const comp = ev.competitions?.[0]; if (!comp) continue;
    const per=ev.status?.period||1, clk=ev.status?.displayClock||'12:00';
    const cM=parseFloat(clk?.split(':')[0]||12), cS=parseFloat(clk?.split(':')[1]||0);
    const gMins=getElapsedMinutes(per, clk), gPct=getGamePct(per, clk);
    for (const team of (comp.competitors||[])) {
      const tA=team.team?.abbreviation||'';
      const tLogo=team.team?.logo||'';
      const aT=comp.competitors?.find(c=>c.homeAway==='away'), hT=comp.competitors?.find(c=>c.homeAway==='home');
      const gl=`${aT?.team?.abbreviation||''} @ ${hT?.team?.abbreviation||''}`;
      for (const cat of (team.leaders||[])) {
        if (cat.name!=='points') continue;
        for (const l of (cat.leaders||[])) {
          const nm=l.athlete?.shortName||l.athlete?.displayName||'';
          const pts=parseFloat(l.value)||0;
          // NCAA: use pre-game star DB. NBA: use curated star DB.
          let star;
          if (isNCAA()) {
            star = ncaaStarCache.find(s => { const ll=nm.toLowerCase().split(' ').pop(); const sl=s.name.split(' ').pop().toLowerCase(); return ll===sl&&s.team===tA; });
          } else {
            star = state.stars.find(s=>nm.toLowerCase().includes(s.name.split(' ').pop().toLowerCase())&&s.team===tA);
          }
          if (!star) continue;
          const exp=getExpectedByTime(star.ppg,gMins), pr=exp>0?(pts/exp*100):100;
          const q1E=getQ1Expected(star.ppg), hE=getHalfExpected(star.ppg);
          const _regPer = getRegulationPeriods(); // NBA: 4, NCAA: 2
          let q1T='-';
          // NBA: Q1 ends at per=2. NCAA: no Q1 concept, show H1 pace when per===1
          if (isNCAA()) {
            if (per>=2) q1T=`${hE.toFixed(1)} exp`; // H1 done
            else if (per===1) { const p=hE>0?(pts/hE*100):100; q1T=`<span style="color:${p<60?'var(--red)':p<80?'var(--orange)':'var(--green)'};font-weight:700;">${p.toFixed(0)}%</span> of ${hE.toFixed(1)}`; }
          } else {
            if (per>=2) q1T=`${q1E.toFixed(1)} exp`;
            else if (per===1) { const p=q1E>0?(pts/q1E*100):100; q1T=`<span style="color:${p<60?'var(--red)':p<80?'var(--orange)':'var(--green)'};font-weight:700;">${p.toFixed(0)}%</span> of ${q1E.toFixed(1)}`; }
          }
          let hT2='-';
          if (per>_regPer) hT2=`${hE.toFixed(1)} exp`; // past halftime/regulation
          else if (per>=1&&gMins>0) { const p=hE>0?(pts/hE*100):100; hT2=`<span style="color:${p<60?'var(--red)':p<80?'var(--orange)':'var(--green)'};font-weight:700;">${p.toFixed(0)}%</span> of ${hE.toFixed(1)}`; }
          const fc=pr<60?'var(--red)':pr<80?'var(--orange)':'var(--green)';
          const sig=pr<60&&gPct>=0.2&&per<=_regPer?'<span class="signal-badge signal-fire">COLD - BET</span>':pr<75?'<span class="signal-badge signal-moderate">Below Pace</span>':'<span class="signal-badge signal-none">On Pace</span>';
          const _pLabel = isNCAA() ? (per <= 2 ? `H${per}` : `OT${per-2}`) : `Q${per}`;
          rows+=`<tr class="star-row"><td style="display:flex;align-items:center;gap:4px;">${teamLogoImg(tLogo, 16)}<div><strong>${nm}</strong><br><span style="font-size:9px;color:var(--text-muted);">${star.ppg} PPG</span></div></td><td>${gl}</td><td style="font-size:16px;font-weight:800;">${pts}</td><td>${q1T}</td><td>${hT2}</td><td><div class="pace-indicator"><div class="pace-fill" style="width:${Math.min(pr,100)}%;background:${fc};"></div></div> ${pr.toFixed(0)}%</td><td>${_pLabel} ${clk}</td><td>${sig}</td></tr>`;
        }
      }
    }
  }
  tb.innerHTML = rows || '<tr><td colspan="8" class="empty-state">No tracked stars in live games.</td></tr>';
}

// ==================== STAR DB ====================
function renderStarDB() {
  const tb = document.getElementById('star-db-body');
  tb.innerHTML = state.stars.map((s,i) => {
    const q1=getQ1Expected(s.ppg), h=getHalfExpected(s.ppg);
    const pLabel = isNCAA() ? 'H1' : 'Q1';
    return `<tr><td><strong>${s.name}</strong></td><td>${s.team}</td><td>${s.ppg}</td><td>${isNCAA() ? h.toFixed(1) : q1.toFixed(1)}</td><td>${h.toFixed(1)}</td><td>&lt;${(isNCAA() ? (h*0.6).toFixed(0) : (q1*0.6).toFixed(0))} ${pLabel}, &lt;${(h*0.6).toFixed(0)} half</td><td><button class="btn btn-red btn-sm" onclick="removeStar(${i})">X</button></td></tr>`;
  }).join('');
}
function addStar() {
  const n=document.getElementById('add-star-name').value.trim(), t=document.getElementById('add-star-team').value.trim().toUpperCase(), p=parseFloat(document.getElementById('add-star-ppg').value);
  if (!n||!t||isNaN(p)) { alert('Fill all fields'); return; }
  state.stars.push({name:n,team:t,ppg:p}); localStorage.setItem('starPlayers',JSON.stringify(state.stars)); renderStarDB();
  document.getElementById('add-star-name').value=''; document.getElementById('add-star-team').value=''; document.getElementById('add-star-ppg').value='';
}
function removeStar(i) { state.stars.splice(i,1); localStorage.setItem('starPlayers',JSON.stringify(state.stars)); renderStarDB(); }

// ==================== SIGNAL GUIDE (MODE-AWARE) ====================
function updateSignalGuide(mode) {
  const ncaa = mode === 'ncaab';
  // Quick reference table
  const fragileDesc = ncaa
    ? 'A team is <strong>way too hot from 3</strong> (48%+ on 10+ att or 52%+ on 7+) and their entire lead depends on it. NCAA avg is ~33.5%. That shooting will cool off  lead will shrink.'
    : 'A team is <strong>way too hot from 3</strong> (50%+) and their entire lead depends on it. That shooting will cool off  lead will shrink.';
  const starDesc = ncaa
    ? 'A lead scorer (16+ PPG) is cold (&lt;65% pace) AND the game is close (within 12pts) during minutes 8-35. <strong>Compressed spring</strong>  breakout incoming. NCAA teams are more star-dependent.'
    : 'A star player (21+ PPG) is cold (&lt;65% pace) AND the game is close (within 15pts) in Q2-Q3. <strong>Compressed spring</strong>  breakout incoming.';
  // Update quick reference cells
  const cells = document.querySelectorAll('#guide-fragile-desc');
  if (cells.length) cells[0].innerHTML = fragileDesc;
  const starCells = document.querySelectorAll('#guide-star-desc');
  if (starCells.length) starCells[0].innerHTML = starDesc;

  // Update detailed guide
  const guideEl = document.getElementById('nba-guide');
  if (!guideEl) return;
  const leagueName = ncaa ? 'NCAAB' : 'NBA';
  const leagueAvg = ncaa ? '~33.5%' : '~36.5%';
  const hotThresh = ncaa ? '48%+ from 3 on 10+ attempts (or 52%+ on 7+)' : '50%+ from 3 on 12+ attempts (or 55%+ on 8+)';
  const fragileThresh = ncaa ? '40%' : '42%';
  const marginRange = ncaa ? '3-12' : '3-15';
  const enginePPM = ncaa ? '1.1' : '1.3';
  const starPPG = ncaa ? '16+' : '21+';
  const coilMargin = ncaa ? '12' : '15';
  const coilWindow = ncaa ? 'minutes 8-35 (first half through mid second half)' : 'Q2-Q3';
  const gameMins = ncaa ? '40 min (220 halves)' : '48 min (412 quarters)';
  const softHot = ncaa ? '40%/7att (or 45%/5att), fragile 36%, margin 2-18pts' : '45%/10att (or 50%/8att), fragile 38%, margin 2-18pts';
  const softStar = ncaa ? '&lt;80% pace, minutes 4-37, margin 18pts, accepts weak cast' : '&lt;75% pace, Q1-Q3 (not just Q2-Q3), margin 18pts';
  const homeCourtNote = ncaa ? '<p style="margin-top:8px;"><strong>Home Court Booster (NCAAB only):</strong> When signals point toward betting the home team, a +0.5 boost is applied. NCAA home court advantage is ~3.5-4 points  significantly stronger than NBA (~2.5). Crowd energy + regression signals = double tailwind.</p>' : '';

  guideEl.innerHTML = `
<p class="guide-intro" style="margin-bottom:12px;"><strong>Core thesis:</strong> The current score was built on something unsustainable, so the live odds are mispriced. We bet on regression. <span style="color:var(--accent);font-weight:700;">${leagueName} mode</span>  ${gameMins}.</p>
<div class="guide-grid">
<div class="guide-card"><h3><span class="signal-badge badge-3pt">3PT FRAGILE</span> 3PT Fragile Lead</h3><p class="edge-label">Team is winning because of hot 3PT shooting  and the lead depends on it</p><p>Fires when ALL are true: (1) a team is shooting ${hotThresh}, (2) their lead is built on that 3PT shooting (${fragileThresh}%+ from 3PT) while the opponent scores from paint, AND (3) the lead is ${marginRange} points.</p><p><strong>Opponent Engine Check:</strong> Checks if trailing team has non-3PT PPM > ${enginePPM}. If broken  signal downgraded. Regression only matters if the other team can capitalize.</p><div class="threshold">Trigger: ${hotThresh} AND lead ${fragileThresh}%+ from 3PT AND opponent 58%+ non-3PT AND lead ${marginRange} pts. League avg: ${leagueAvg}.<br>Weakened: If trailing team non-3PT PPM &lt; ${enginePPM}.</div></div>
<div class="guide-card"><h3><span class="signal-badge badge-star">STAR</span> Star Coil</h3><p class="edge-label">Star is cold + game is close + supporting cast is holding = maximum edge</p><p>When a ${starPPG} PPG player is at &lt;65% of expected pace AND the game is within ${coilMargin} points during ${coilWindow}.</p><p><strong>Supporting Cast Analysis:</strong> Pure live data  team score minus star's points vs opponent total. If cast is within 8pts, team is competitive WITHOUT the star.</p><p><strong>4 tiers:</strong> Elite (cast gap -8), Standard (-8 to -15), Weak (&lt;-15), Locked (deficit stable 3+min).</p><div class="threshold">Trigger: Star &lt;65% pace + margin ${coilMargin} + ${coilWindow}.<br>Tiers: Elite (cast gap -8, 1.5 weight), Standard (-8 to -15, 1 weight), Weak (${ncaa ? 'accepted in soft combined' : '0 weight'}), Locked (reverse bet).</div></div>
<div class="guide-card"><h3><span class="signal-badge badge-combined">COMBINED</span> Combined Edge</h3><p class="edge-label">Both signals firing on the same game = strongest edge</p><p>When 3PT Fragile AND Star Coil fire on the same game. Two independent angles of mispricing.</p><div class="threshold">Trigger: Both 3PT Fragile + Star Coil on the same game.</div><p style="margin-top:8px;"><strong>Combined Boost (Relaxed Thresholds):</strong></p><ul style="font-size:12px;margin:4px 0 0 16px;line-height:1.6;"><li><strong>3PT Soft:</strong> ${softHot}</li><li><strong>Star Soft:</strong> ${softStar}</li></ul><p style="font-size:12px;margin-top:4px;color:var(--text-muted);">Relaxed signals never fire individually  only when both converge.</p>${homeCourtNote}</div>
</div>`;
}

// ==================== BET LOG ====================
function openLogModal(g,p,s) { document.getElementById('modal-game').value=g; document.getElementById('modal-price').value=p; document.getElementById('modal-strategy').value=s; document.getElementById('modal-side').value=''; document.getElementById('modal-notes').value=''; document.getElementById('logModal').classList.add('active'); }
function closeModal() { document.getElementById('logModal').classList.remove('active'); }
function confirmLogBet() {
  state.betLog.push({date:new Date().toLocaleDateString(),strategy:document.getElementById('modal-strategy').value,game:document.getElementById('modal-game').value,side:document.getElementById('modal-side').value,price:document.getElementById('modal-price').value,units:parseFloat(document.getElementById('modal-units').value),result:'Pending',profit:0,notes:document.getElementById('modal-notes').value,id:Date.now()});
  localStorage.setItem('betLog',JSON.stringify(state.betLog)); renderBetLog(); closeModal();
}
function getEdgeBonus(signalCount) {
  const mode = document.getElementById('edge-mode') ? document.getElementById('edge-mode').value : 'moderate';
  if (mode === 'backtest') {
    const d = getBacktestData();
    if (d.total >= 10) return Math.max(0.01, Math.min(0.10, d.edge));
    return 0.03;
  }
  const sc = signalCount || 1;
  const base = mode === 'conservative' ? 0.03 : mode === 'aggressive' ? 0.08 : 0.05;
  const bonus = Math.min(sc - 1, 3) * 0.015;
  return Math.min(base + bonus, 0.12);
}

function kellySize(impliedP, odds, fraction, signalCount, urgencyMult) {
  if (!fraction) {
    const sel = document.getElementById('kelly-fraction');
    fraction = sel ? parseFloat(sel.value) : 0.75;
  }
  const bankroll = parseFloat((document.getElementById('bankroll-input')||{}).value) || 1000;
  const edge = getEdgeBonus(signalCount);
  const p = Math.min(0.90, impliedP + edge);
  const q = 1 - p;
  const b = odds > 0 ? odds / 100 : 100 / Math.abs(odds);
  let fStar = (b * p - q) / b;
  if (fStar < 0) fStar = 0;
  fStar = fStar * fraction;
  // Apply urgency multiplier (PRIME=1.0, ACT_NOW=0.85, DEVELOPING=0.7, CLOSING=0.5)
  if (urgencyMult !== undefined) fStar *= urgencyMult;
  if (fStar > 0.10) fStar = 0.10;
  // Minimum edge threshold: if edge < 2%, don't bet
  if (edge < 0.02) { fStar = 0; }
  const bet = Math.max(0, Math.round(bankroll * fStar));
  return { bet, fStar: Math.round(fStar * 1000) / 10, p: Math.round(p * 1000) / 10, edge: Math.round(edge * 1000) / 10, fraction, bankroll };
}

function autoLogBet(gameId, team, side, signals, marketOdds, impliedP, signalCount, urgencyMult) {
  let log = JSON.parse(localStorage.getItem('betLog') || '[]');
  const key = gameId + '_' + team;
  if (log.find(x => x.key === key)) return;
  const k = kellySize(impliedP, marketOdds, null, signalCount || 1, urgencyMult);
  log.push({
    id: Date.now(),
    key: key,
    gameId: gameId,
    team: team,
    side: side,
    signals: signals.map(s => typeof s === 'object' ? s.type : s),
    marketOdds: marketOdds,
    impliedP: Math.round(impliedP * 1000) / 10,
    estimatedP: k.p,
    kellyPct: k.fStar,
    kellyBet: k.bet,
    timestamp: new Date().toISOString(),
    outcome: null,
    payout: null,
    mode: currentMode || 'nba'
  });
  localStorage.setItem('betLog', JSON.stringify(log));
}

// ==================== SIGNAL BACKTEST TRACKER ====================
const TRACKER_BANKROLL = 20000;
const TRACKER_MAX_KELLY = 0.05;    // Max 5% of bankroll per bet (half-Kelly cap)

const TRACKER_FLAT_UNIT = 200; // Flat $200/bet until 200+ resolved signals
const TRACKER_MIN_SAMPLE = 200; // Minimum resolved signals before using Kelly

function trackerKellyBet(odds, signalCount, urgencyMult) {
  // Check if we have enough data for Kelly  if not, use flat units
  const resolved = (state.signalTracker || []).filter(s => s.gameCompleted).length;
  const sc = signalCount || 1;

  if (resolved < TRACKER_MIN_SAMPLE) {
    // FLAT UNIT MODE: $200/bet regardless of signal strength
    // Still compute estimated edge for display, but don't size on it
    const baseEdge = 0.035 + Math.min(sc - 1, 3) * 0.01;
    const edge = Math.min(baseEdge, 0.08);
    const impliedP = odds < 0 ? Math.abs(odds)/(Math.abs(odds)+100) : 100/(odds+100);
    const p = Math.min(0.90, impliedP + edge);
    const f = TRACKER_FLAT_UNIT / TRACKER_BANKROLL;
    return { f: Math.round(f*1000)/10, p: Math.round(p*1000)/10, bet: TRACKER_FLAT_UNIT, edge: Math.round(edge*1000)/10, flatMode: true };
  }

  // KELLY MODE: 200+ resolved signals  use empirical edge if available
  const completed = state.signalTracker.filter(s => s.gameCompleted && s.mlResult);
  const wins = completed.filter(s => s.mlResult === 'W').length;
  const empiricalWR = completed.length > 0 ? wins / completed.length : 0.524;
  const breakEven = odds < 0 ? Math.abs(odds)/(Math.abs(odds)+100) : 100/(odds+100);
  const empiricalEdge = Math.max(0, empiricalWR - breakEven);
  // Blend: 70% empirical + 30% formula (hedge against recency)
  const formulaEdge = 0.035 + Math.min(sc - 1, 3) * 0.01;
  const edge = Math.min(empiricalEdge * 0.7 + formulaEdge * 0.3, 0.08);
  const impliedP = breakEven;
  const p = Math.min(0.90, impliedP + edge);
  const q = 1 - p;
  const b = odds < 0 ? 100/Math.abs(odds) : odds/100;
  let f = (b * p - q) / b;
  if (f <= 0) f = 0;
  f = f * 0.5; // half-Kelly
  if (urgencyMult !== undefined) f *= urgencyMult;
  f = Math.min(f, TRACKER_MAX_KELLY);
  if (edge < 0.03) f = 0;
  const bet = Math.max(0, Math.round(TRACKER_BANKROLL * f));
  return { f: Math.round(f*1000)/10, p: Math.round(p*1000)/10, bet, edge: Math.round(edge*1000)/10, flatMode: false };
}

function autoTrackSignal(thesis, rec) {
  if (!thesis) return;
  if (!rec) rec = { type: 'WATCH', side: null, spreadLine: '', units: 0, reasoning: 'No recommendation generated', margin: 0, minRemaining: 0 };
  const trackerKey = thesis.eventId + '_' + (thesis.betSide||'');
  if (state.signalTracker.find(s => s.key === trackerKey)) return;

  const sigCount = (thesis.signals||[]).filter(s=>s.level===2).length;
  const odds = thesis.marketOdds || -110;
  const urgMult = thesis.urgency?.mult !== undefined ? thesis.urgency.mult : (thesis.urgencyMult !== undefined ? thesis.urgencyMult : 1.0);
  const kelly = trackerKellyBet(odds, sigCount, urgMult);

  const entry = {
    id: Date.now() + '_' + Math.random().toString(36).substr(2,6),
    key: trackerKey,
    eventId: thesis.eventId,
    game: thesis.game || '',
    awayTeam: thesis.aTeam || '',
    homeTeam: thesis.hTeam || '',
    awayTeamFull: thesis.aTeamFull || '',
    homeTeamFull: thesis.hTeamFull || '',
    signalSide: thesis.betSide || '',
    signalSideFull: thesis.betSideFull || '',
    recType: rec.type,
    spreadLine: rec.spreadLine || '',
    units: rec.units || 1,
    signalLevel: thesis.signalLevel || 2,
    signals: (thesis.signals||[]).filter(s=>s.level===2).map(s=>s.type),
    confidence: thesis.confidence || '',
    strongCount: thesis.strongCount || 0,
    awayScore: thesis.aScore,
    homeScore: thesis.hScore,
    period: thesis.per,
    clock: thesis.clk,
    reasoning: rec.reasoning || '',
    marketOdds: odds,
    kellyPct: kelly.f,
    kellyBet: kelly.bet,
    estWinProb: kelly.p,
    estEdge: kelly.edge,
    timestamp: Date.now(),
    date: new Date().toLocaleDateString(),
    mode: currentMode,
    // LEC tracking  odds key for matching post-entry odds
    entryOddsKey: thesis.oddsKey || null,
    lec5minOdds: null, lec5min: null,
    lec10minOdds: null, lec10min: null,
    // Result fields  filled by resolveSignalTracker
    finalAwayScore: null,
    finalHomeScore: null,
    gameCompleted: false,
    mlResult: null,
    atsResult: null,
    mlPayout: null,
    atsPayout: null,
    resultCheckedAt: null
  };

  state.signalTracker.push(entry);
  if (state.signalTracker.length > 500) state.signalTracker = state.signalTracker.slice(-400);
  localStorage.setItem('signalTracker', JSON.stringify(state.signalTracker));
  renderSignalTracker();
}

// === IMPORT FROM BACKGROUND ENGINE ===
// Loads engine-signals.json (written by signal-engine.js when browser was offline)
// and merges any new signals into the signal tracker + bet log.
async function importEngineSignals() {
  try {
    const resp = await fetch('engine-signals.json?t=' + Date.now());
    if (!resp.ok) return; // no engine file  normal if engine hasn't run
    const engineSignals = await resp.json();
    if (!Array.isArray(engineSignals) || engineSignals.length === 0) return;
    let imported = 0;
    for (const sig of engineSignals) {
      // Skip if already in tracker
      const trackerKey = sig.eventId + '_' + (sig.betTeam || '');
      if (state.signalTracker.find(s => s.key === trackerKey)) continue;
      // Convert engine format to tracker format
      const entry = {
        id: sig.timestamp + '_' + Math.random().toString(36).substr(2, 6),
        key: trackerKey,
        eventId: sig.eventId,
        game: sig.game || '',
        awayTeam: sig.game?.split(' @ ')?.[0] || '',
        homeTeam: sig.game?.split(' @ ')?.[1] || '',
        awayTeamFull: sig.gameFullAway || '',
        homeTeamFull: sig.gameFullHome || '',
        signalSide: sig.betTeam || '',
        signalSideFull: sig.betTeamFull || '',
        recType: sig.recType || 'ML',
        spreadLine: '',
        units: 1,
        signalLevel: 2,
        signals: sig.signalTypes || [],
        confidence: sig.signalCount >= 2 ? 'high' : 'medium',
        strongCount: sig.signalCount || 1,
        awayScore: sig.awayScore,
        homeScore: sig.homeScore,
        period: sig.period,
        clock: sig.clock,
        reasoning: `Background engine signal: ${(sig.signalTypes || []).join(' + ')}`,
        marketOdds: sig.marketOdds || -110,
        kellyPct: sig.kellyPct,
        kellyBet: sig.kellyBet,
        estWinProb: sig.estWinProb,
        estEdge: sig.estEdge,
        timestamp: sig.timestamp,
        date: sig.date || new Date(sig.timestamp).toLocaleDateString(),
        mode: sig.mode || currentMode,
        finalAwayScore: sig.finalAwayScore,
        finalHomeScore: sig.finalHomeScore,
        gameCompleted: sig.gameCompleted || false,
        mlResult: sig.mlResult || null,
        atsResult: null,
        mlPayout: sig.mlPayout || null,
        atsPayout: null,
        resultCheckedAt: null,
        source: 'engine' // tag so you know it came from background
      };
      state.signalTracker.push(entry);
      imported++;
      // Also add to bet log if not there
      const logKey = sig.eventId + '_' + sig.betTeam;
      let betLog = JSON.parse(localStorage.getItem('betLog') || '[]');
      if (!betLog.find(x => x.key === logKey)) {
        betLog.push({
          id: sig.timestamp,
          key: logKey,
          gameId: sig.eventId,
          team: sig.betTeam,
          side: 'ML',
          signals: sig.signalTypes || [],
          marketOdds: sig.marketOdds || -110,
          impliedP: sig.impliedP,
          estimatedP: sig.estWinProb,
          kellyPct: sig.kellyPct,
          kellyBet: sig.kellyBet,
          timestamp: new Date(sig.timestamp).toISOString(),
          outcome: sig.mlResult || null,
          payout: sig.mlPayout || null,
          mode: sig.mode || currentMode,
          source: 'engine'
        });
        localStorage.setItem('betLog', JSON.stringify(betLog));
      }
    }
    if (imported > 0) {
      localStorage.setItem('signalTracker', JSON.stringify(state.signalTracker));
      renderSignalTracker();
      renderBetLog();
      console.log(`[Engine Import] Imported ${imported} signals from background engine`);
    }
  } catch(e) {
    // Silently ignore  engine file may not exist
  }
}

async function resolveSignalTracker(specificDateStr) {
  const pending = state.signalTracker.filter(s => !s.gameCompleted);
  const pendingNearMisses = (state.nearMisses || []).filter(s => !s.gameCompleted);
  if (pending.length === 0 && pendingNearMisses.length === 0) { renderSignalTracker(); return; }

  const datesToFetch = new Set();
  if (specificDateStr) {
    datesToFetch.add(specificDateStr);
  } else {
    datesToFetch.add('today');
    pending.forEach(s => {
      if (s.date) {
        const parts = s.date.split('/');
        if (parts.length === 3) {
          const mm = parts[0].padStart(2,'0');
          const dd = parts[1].padStart(2,'0');
          const yyyy = parts[2].length === 2 ? '20'+parts[2] : parts[2];
          datesToFetch.add(yyyy+mm+dd);
        }
      }
    });
  }

  let allEvents = [];
  for (const ds of datesToFetch) {
    try {
      const base = getESPNUrl();
      const url = ds === 'today' ? base : base + '?dates=' + ds;
      const resp = await fetch(url);
      if (!resp.ok) continue;
      const data = await resp.json();
      allEvents = allEvents.concat(data.events || []);
    } catch(e) { console.warn('Signal tracker fetch error:', e); }
  }

  const eventMap = {};
  allEvents.forEach(e => { eventMap[e.id] = e; eventMap[String(e.id)] = e; });

  let changed = false;
  pending.forEach(signal => {
    const event = eventMap[signal.eventId] || eventMap[String(signal.eventId)];
    if (!event) return;
    if (event.status?.type?.state !== 'post') return;

    const comp = event.competitions?.[0];
    if (!comp) return;
    const away = comp.competitors?.find(c => c.homeAway === 'away');
    const home = comp.competitors?.find(c => c.homeAway === 'home');
    if (!away || !home) return;

    const finalAway = parseInt(away.score) || 0;
    const finalHome = parseInt(home.score) || 0;
    signal.finalAwayScore = finalAway;
    signal.finalHomeScore = finalHome;
    signal.gameCompleted = true;
    signal.resultCheckedAt = Date.now();

    const signalIsAway = signal.signalSide === signal.awayTeam;
    const sigFinal = signalIsAway ? finalAway : finalHome;
    const oppFinal = signalIsAway ? finalHome : finalAway;
    const betAmt = signal.kellyBet || 0;
    const odds = signal.marketOdds || -110;
    const multiplier = odds < 0 ? 100/Math.abs(odds) : odds/100;

    // ML result
    if (sigFinal > oppFinal) {
      signal.mlResult = 'W';
      signal.mlPayout = Math.round(betAmt * multiplier);
    } else {
      signal.mlResult = 'L';
      signal.mlPayout = -betAmt;
    }

    // ATS result
    if (signal.spreadLine) {
      const spread = parseFloat(signal.spreadLine) || 0;
      const adjusted = sigFinal + spread;
      if (adjusted > oppFinal) {
        signal.atsResult = 'W';
        signal.atsPayout = Math.round(betAmt * (100/110)); // spread always -110
      } else if (adjusted === oppFinal) {
        signal.atsResult = 'P';
        signal.atsPayout = 0;
      } else {
        signal.atsResult = 'L';
        signal.atsPayout = -betAmt;
      }
    } else {
      signal.atsResult = signal.mlResult;
      signal.atsPayout = signal.mlPayout;
    }
    changed = true;
  });

  if (changed) {
    localStorage.setItem('signalTracker', JSON.stringify(state.signalTracker));
  }

  // Resolve near-miss (counterfactual) signals too
  const pendingNM = (state.nearMisses || []).filter(s => !s.gameCompleted);
  let nmChanged = false;
  pendingNM.forEach(nm => {
    const event = eventMap[nm.eventId] || eventMap[String(nm.eventId)];
    if (!event || event.status?.type?.state !== 'post') return;
    const comp = event.competitions?.[0];
    if (!comp) return;
    const away = comp.competitors?.find(c => c.homeAway === 'away');
    const home = comp.competitors?.find(c => c.homeAway === 'home');
    if (!away || !home) return;
    nm.finalAwayScore = parseInt(away.score) || 0;
    nm.finalHomeScore = parseInt(home.score) || 0;
    nm.gameCompleted = true;
    // Would the hypothetical bet have won?
    const isAway = nm.hypotheticalSide === nm.awayTeam;
    const betFinal = isAway ? nm.finalAwayScore : nm.finalHomeScore;
    const oppFinal = isAway ? nm.finalHomeScore : nm.finalAwayScore;
    nm.wouldHaveWon = betFinal > oppFinal;
    nmChanged = true;
  });
  if (nmChanged) {
    localStorage.setItem('nearMisses', JSON.stringify(state.nearMisses));
  }

  renderSignalTracker();
}

function getSignalTrackerStats(modeFilter) {
  const allRaw = state.signalTracker;
  const all = modeFilter ? allRaw.filter(s => s.mode === modeFilter) : allRaw;
  const completed = all.filter(s => s.gameCompleted);
  const pending = all.filter(s => !s.gameCompleted);

  const mlR = completed.filter(s => s.mlResult);
  const mlW = mlR.filter(s => s.mlResult==='W').length;
  const mlL = mlR.filter(s => s.mlResult==='L').length;
  const mlWR = mlR.length>0 ? Math.round(mlW/mlR.length*1000)/10 : 0;
  const mlProfit = mlR.reduce((s,x) => s+(x.mlPayout||0), 0);
  const mlRisked = mlR.reduce((s,x) => s+(x.kellyBet||0), 0);
  const mlROI = mlRisked>0 ? Math.round(mlProfit/mlRisked*1000)/10 : 0;

  const atsR = completed.filter(s => s.atsResult);
  const atsW = atsR.filter(s => s.atsResult==='W').length;
  const atsL = atsR.filter(s => s.atsResult==='L').length;
  const atsP = atsR.filter(s => s.atsResult==='P').length;
  const atsWR = atsR.length>0 ? Math.round(atsW/atsR.length*1000)/10 : 0;
  const atsProfit = atsR.reduce((s,x) => s+(x.atsPayout||0), 0);
  const atsRisked = atsR.reduce((s,x) => s+(x.kellyBet||0), 0);
  const atsROI = atsRisked>0 ? Math.round(atsProfit/atsRisked*1000)/10 : 0;

  // By signal type
  const bySig = {};
  completed.forEach(s => {
    (s.signals||[]).forEach(sig => {
      if (!bySig[sig]) bySig[sig] = {n:0, mlW:0, mlL:0, atsW:0, atsL:0, atsP:0, mlProfit:0, atsProfit:0, risked:0};
      const b = bySig[sig]; b.n++;
      if (s.mlResult==='W') b.mlW++; else b.mlL++;
      if (s.atsResult==='W') b.atsW++; else if (s.atsResult==='L') b.atsL++; else if (s.atsResult==='P') b.atsP++;
      b.mlProfit += (s.mlPayout||0); b.atsProfit += (s.atsPayout||0); b.risked += (s.kellyBet||0);
    });
  });

  // By quarter
  const byQ = {};
  completed.forEach(s => {
    const q = s.mode === 'ncaab' ? ((s.period||0) <= 2 ? 'H'+(s.period||'?') : 'OT'+((s.period||3)-2)) : 'Q'+(s.period||'?');
    if (!byQ[q]) byQ[q] = {n:0, mlW:0, mlL:0, atsW:0, atsL:0, mlProfit:0, atsProfit:0, risked:0};
    const b = byQ[q]; b.n++;
    if (s.mlResult==='W') b.mlW++; else b.mlL++;
    if (s.atsResult==='W') b.atsW++; else if (s.atsResult==='L') b.atsL++;
    b.mlProfit += (s.mlPayout||0); b.atsProfit += (s.atsPayout||0); b.risked += (s.kellyBet||0);
  });

  // By rec type
  const byRec = {};
  completed.forEach(s => {
    const rt = s.recType || 'ML';
    if (!byRec[rt]) byRec[rt] = {n:0, mlW:0, mlL:0, atsW:0, atsL:0, mlProfit:0, atsProfit:0, risked:0};
    const b = byRec[rt]; b.n++;
    if (s.mlResult==='W') b.mlW++; else b.mlL++;
    if (s.atsResult==='W') b.atsW++; else if (s.atsResult==='L') b.atsL++;
    b.mlProfit += (s.mlPayout||0); b.atsProfit += (s.atsPayout||0); b.risked += (s.kellyBet||0);
  });

  const totalRisked = completed.reduce((s,x) => s+(x.kellyBet||0), 0);
  const currentBankroll = TRACKER_BANKROLL + mlProfit;

  // LEC (Live Edge Captured) stats
  const lec5arr = all.filter(s => s.lec5min !== null && s.lec5min !== undefined);
  const lec10arr = all.filter(s => s.lec10min !== null && s.lec10min !== undefined);
  const avgLec5 = lec5arr.length > 0 ? Math.round(lec5arr.reduce((s,x) => s + x.lec5min, 0) / lec5arr.length * 10) / 10 : null;
  const avgLec10 = lec10arr.length > 0 ? Math.round(lec10arr.reduce((s,x) => s + x.lec10min, 0) / lec10arr.length * 10) / 10 : null;
  const lecPositive5 = lec5arr.filter(s => s.lec5min > 0).length;
  const lecPositive10 = lec10arr.filter(s => s.lec10min > 0).length;

  // Near-miss (counterfactual) stats
  const nearMisses = state.nearMisses || [];
  const nmCompleted = nearMisses.filter(s => s.gameCompleted);
  const nmWins = nmCompleted.filter(s => s.wouldHaveWon).length;
  const nmWR = nmCompleted.length > 0 ? Math.round(nmWins / nmCompleted.length * 1000) / 10 : 0;

  return {
    total: all.length, completed: completed.length, pending: pending.length,
    mlW, mlL, mlWR, mlProfit, mlROI, mlRisked,
    atsW, atsL, atsP, atsWR, atsProfit, atsROI, atsRisked,
    bySig, byQ, byRec,
    totalRisked, currentBankroll,
    avgLec5, avgLec10, lecCount5: lec5arr.length, lecCount10: lec10arr.length,
    lecPositive5, lecPositive10,
    nearMissTotal: nearMisses.length, nearMissCompleted: nmCompleted.length, nearMissWR: nmWR
  };
}

let _trackerModeFilter = null; // null = all, 'nba', 'ncaab'
function setTrackerMode(mode) {
  _trackerModeFilter = mode;
  renderSignalTracker();
}
function renderSignalTracker() {
  const el = document.getElementById('signal-tracker-content');
  if (!el) return;

  const st = getSignalTrackerStats(_trackerModeFilter);
  const allFiltered = _trackerModeFilter
    ? state.signalTracker.filter(s => s.mode === _trackerModeFilter)
    : state.signalTracker;
  const all = allFiltered.slice().reverse();

  // Count by mode for tab badges
  const nbaCount = state.signalTracker.filter(s => s.mode === 'nba').length;
  const ncaaCount = state.signalTracker.filter(s => s.mode === 'ncaab').length;

  let h = '';

  // Mode filter tabs
  h += '<div style="display:flex;gap:6px;margin-bottom:14px;">';
  const tabStyle = (active) => `padding:6px 14px;font-size:11px;font-weight:700;border-radius:20px;cursor:pointer;border:1px solid ${active ? 'var(--accent)' : 'var(--border)'};background:${active ? 'var(--accent-light)' : 'var(--card-bg)'};color:${active ? 'var(--accent)' : 'var(--text-muted)'};`;
  h += `<div style="${tabStyle(!_trackerModeFilter)}" onclick="setTrackerMode(null)">ALL (${state.signalTracker.length})</div>`;
  h += `<div style="${tabStyle(_trackerModeFilter==='nba')}" onclick="setTrackerMode('nba')">NBA (${nbaCount})</div>`;
  h += `<div style="${tabStyle(_trackerModeFilter==='ncaab')}" onclick="setTrackerMode('ncaab')">NCAA (${ncaaCount})</div>`;
  h += '</div>';

  if (all.length === 0) {
    el.innerHTML = h + '<div style="text-align:center;padding:40px 20px;color:var(--text-muted);font-size:13px;">No signals tracked' + (_trackerModeFilter ? ' for ' + (_trackerModeFilter === 'ncaab' ? 'NCAA' : 'NBA') : '') + '. Signals are automatically recorded when combined signals (level 2) fire during live games with auto-refresh on.</div>';
    return;
  }

  // ===== BANKROLL HEADER =====
  const bkColor = st.currentBankroll >= TRACKER_BANKROLL ? 'var(--green)' : 'var(--red)';
  const pnl = st.mlProfit;
  const pnlSign = pnl >= 0 ? '+' : '';
  h += '<div class="card" style="margin-bottom:16px;padding:16px 20px;background:linear-gradient(135deg,var(--card-bg),var(--accent-light));border:1px solid var(--accent)">';
  h += '<div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:12px">';
  h += '<div><div style="font-size:10px;font-weight:700;color:var(--text-muted);letter-spacing:1px;margin-bottom:4px">BACKTEST BANKROLL</div>';
  h += '<div style="font-size:28px;font-weight:800;color:'+bkColor+'">$'+st.currentBankroll.toLocaleString()+'</div>';
  h += '<div style="font-size:11px;color:var(--text-muted)">Started: $'+TRACKER_BANKROLL.toLocaleString()+' | P&L: <span style="color:'+bkColor+'">'+pnlSign+'$'+pnl.toLocaleString()+'</span></div></div>';
  h += '<div style="text-align:right"><div style="font-size:10px;font-weight:700;color:var(--text-muted);letter-spacing:1px;margin-bottom:4px">KELLY SIZING</div>';
  const _resolved = st.completed;
  const _sizingMode = _resolved < TRACKER_MIN_SAMPLE
    ? 'FLAT UNIT: $'+TRACKER_FLAT_UNIT+'/bet ('+_resolved+'/'+TRACKER_MIN_SAMPLE+' signals to unlock Kelly)'
    : 'KELLY: empirical edge  Half-Kelly  Max '+Math.round(TRACKER_MAX_KELLY*100)+'% ($'+(TRACKER_BANKROLL*TRACKER_MAX_KELLY).toLocaleString()+')';
  h += '<div style="font-size:12px;color:var(--text-secondary);line-height:1.6">'+_sizingMode+'<br>Odds: live market or -110 default</div></div>';
  h += '</div></div>';

  // ===== SUMMARY STATS GRID =====
  h += '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:10px;margin-bottom:16px">';

  const statCard = (label, value, sub, color) => {
    return '<div class="card" style="padding:14px;text-align:center"><div style="font-size:9px;font-weight:700;color:var(--text-muted);letter-spacing:0.8px;margin-bottom:6px">'+label+'</div><div style="font-size:22px;font-weight:800;color:'+(color||'var(--text-primary)')+'">'+value+'</div><div style="font-size:10px;color:var(--text-muted);margin-top:2px">'+sub+'</div></div>';
  };

  h += statCard('TRACKED', st.total, st.pending+' pending', 'var(--accent)');
  h += statCard('ML RECORD', st.mlW+'-'+st.mlL, st.mlWR+'% win rate', st.mlWR>=52.4?'var(--green)':'var(--red)');
  h += statCard('ATS RECORD', st.atsW+'-'+st.atsL+'-'+st.atsP, st.atsWR+'% win rate', st.atsWR>=52.4?'var(--green)':'var(--red)');
  h += statCard('ML P&L', (st.mlProfit>=0?'+':'')+' $'+st.mlProfit.toLocaleString(), 'ROI: '+(st.mlROI>=0?'+':'')+st.mlROI+'%', st.mlProfit>=0?'var(--green)':'var(--red)');
  h += statCard('ATS P&L', (st.atsProfit>=0?'+':'')+' $'+st.atsProfit.toLocaleString(), 'ROI: '+(st.atsROI>=0?'+':'')+st.atsROI+'%', st.atsProfit>=0?'var(--green)':'var(--red)');
  h += statCard('TOTAL RISKED', '$'+st.totalRisked.toLocaleString(), st.completed+' resolved', 'var(--text-primary)');
  // LEC card
  const lecVal = st.avgLec5 !== null ? (st.avgLec5 > 0 ? '+' : '') + st.avgLec5 : '--';
  const lecColor = st.avgLec5 === null ? 'var(--text-muted)' : st.avgLec5 > 0 ? 'var(--green)' : 'var(--red)';
  const lecSub = st.lecCount5 > 0 ? st.lecPositive5 + '/' + st.lecCount5 + ' moved in favor (5m)' : 'Needs live odds data';
  h += statCard('LEC (5 MIN)', lecVal, lecSub, lecColor);
  // Near-miss counterfactual card
  const nmVal = st.nearMissCompleted > 0 ? st.nearMissWR + '%' : '--';
  const nmColor = st.nearMissCompleted === 0 ? 'var(--text-muted)' : st.nearMissWR >= 52.4 ? 'var(--orange)' : 'var(--text-muted)';
  h += statCard('NEAR-MISS WR', nmVal, st.nearMissTotal + ' tracked (' + st.nearMissCompleted + ' resolved)', nmColor);
  h += '</div>';

  // ===== BREAKDOWN BY SIGNAL TYPE =====
  const sigKeys = Object.keys(st.bySig);
  if (sigKeys.length > 0) {
    h += '<div style="margin-bottom:16px"><div style="font-size:12px;font-weight:700;margin-bottom:8px;color:var(--text-muted);letter-spacing:0.5px">BY SIGNAL TYPE</div>';
    h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px">';
    sigKeys.forEach(sig => {
      const d = st.bySig[sig];
      const mlWR = d.n>0?Math.round(d.mlW/d.n*100):0;
      const atsWR = d.n>0?Math.round(d.atsW/d.n*100):0;
      h += '<div class="card" style="padding:12px"><div style="font-size:12px;font-weight:800;color:var(--accent);margin-bottom:6px">'+sig.toUpperCase()+' <span style="font-weight:400;color:var(--text-muted)">(n='+d.n+')</span></div>';
      h += '<div style="font-size:11px;line-height:1.8">';
      h += 'ML: <strong style="color:'+(mlWR>=52.4?'var(--green)':'var(--red)')+'">'+d.mlW+'-'+d.mlL+'</strong> ('+mlWR+'%) | '+(d.mlProfit>=0?'+':'')+' $'+d.mlProfit.toLocaleString()+'<br>';
      h += 'ATS: <strong style="color:'+(atsWR>=52.4?'var(--green)':'var(--red)')+'">'+d.atsW+'-'+d.atsL+'-'+d.atsP+'</strong> ('+atsWR+'%) | '+(d.atsProfit>=0?'+':'')+' $'+d.atsProfit.toLocaleString();
      h += '</div></div>';
    });
    h += '</div></div>';
  }

  // ===== BREAKDOWN BY QUARTER =====
  const qKeys = Object.keys(st.byQ).sort();
  if (qKeys.length > 0) {
    h += '<div style="margin-bottom:16px"><div style="font-size:12px;font-weight:700;margin-bottom:8px;color:var(--text-muted);letter-spacing:0.5px">BY QUARTER</div>';
    h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:10px">';
    qKeys.forEach(q => {
      const d = st.byQ[q];
      const mlWR = d.n>0?Math.round(d.mlW/d.n*100):0;
      h += '<div class="card" style="padding:12px"><div style="font-size:14px;font-weight:800;color:var(--accent);margin-bottom:4px">'+q+' <span style="font-weight:400;color:var(--text-muted);font-size:11px">(n='+d.n+')</span></div>';
      h += '<div style="font-size:11px">ML: <strong style="color:'+(mlWR>=52.4?'var(--green)':'var(--red)')+'">'+d.mlW+'-'+d.mlL+'</strong> ('+mlWR+'%) | P&L: <span style="color:'+(d.mlProfit>=0?'var(--green)':'var(--red)')+'">'+(d.mlProfit>=0?'+':'')+' $'+d.mlProfit.toLocaleString()+'</span></div>';
      h += '</div>';
    });
    h += '</div></div>';
  }

  // ===== BREAKDOWN BY REC TYPE =====
  const recKeys = Object.keys(st.byRec);
  if (recKeys.length > 0) {
    h += '<div style="margin-bottom:16px"><div style="font-size:12px;font-weight:700;margin-bottom:8px;color:var(--text-muted);letter-spacing:0.5px">BY REC TYPE</div>';
    h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px">';
    recKeys.forEach(rt => {
      const d = st.byRec[rt];
      const mlWR = d.n>0?Math.round(d.mlW/d.n*100):0;
      const atsWR = d.n>0?Math.round(d.atsW/d.n*100):0;
      h += '<div class="card" style="padding:12px"><div style="font-size:12px;font-weight:800;color:'+(rt==='ML'?'var(--orange)':'var(--purple, #7c3aed)')+';margin-bottom:6px">'+rt+' <span style="font-weight:400;color:var(--text-muted)">(n='+d.n+')</span></div>';
      h += '<div style="font-size:11px;line-height:1.8">';
      h += 'ML: <strong>'+d.mlW+'-'+d.mlL+'</strong> ('+mlWR+'%) | '+(d.mlProfit>=0?'+':'')+' $'+d.mlProfit.toLocaleString()+'<br>';
      h += 'ATS: <strong>'+d.atsW+'-'+d.atsL+'</strong> ('+atsWR+'%) | '+(d.atsProfit>=0?'+':'')+' $'+d.atsProfit.toLocaleString();
      h += '</div></div>';
    });
    h += '</div></div>';
  }

  // ===== SIGNAL HISTORY TABLE =====
  const thS = 'padding:8px 6px;font-size:9px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:var(--text-muted);border-bottom:2px solid var(--border);white-space:nowrap;text-align:left';
  h += '<div class="card" style="padding:0;overflow:hidden"><div style="overflow-x:auto">';
  h += '<table style="width:100%;border-collapse:collapse;font-size:11px"><thead><tr>';
  h += '<th style="'+thS+'">Date</th><th style="'+thS+'">Game</th><th style="'+thS+'">Side</th><th style="'+thS+'">Rec</th><th style="'+thS+'">Spread</th>';
  h += '<th style="'+thS+'">Score@Signal</th><th style="'+thS+'">Final</th><th style="'+thS+'">Bet</th>';
  h += '<th style="'+thS+'">ML</th><th style="'+thS+'">ATS</th><th style="'+thS+'">ML P&L</th><th style="'+thS+'">ATS P&L</th>';
  h += '</tr></thead><tbody>';

  all.forEach(s => {
    const td = 'padding:8px 6px;border-bottom:1px solid var(--border-light, rgba(255,255,255,0.06));white-space:nowrap';
    const periodStr = s.mode === 'ncaab' ? ((s.period||0) <= 2 ? 'H'+(s.period||'?') : 'OT'+((s.period||3)-2)) : 'Q'+(s.period||'?');
    const modeBadge = s.mode === 'ncaab' ? '<span style="font-size:8px;font-weight:700;color:var(--orange);background:var(--orange-light);padding:1px 4px;border-radius:3px;margin-right:3px;">NCAA</span>' : '';
    const scoreAt = s.awayScore+'-'+s.homeScore+' '+periodStr+' '+(s.clock||'');
    const final_ = s.gameCompleted ? s.finalAwayScore+'-'+s.finalHomeScore : '<span style="color:var(--orange)">Pending</span>';
    const mlC = s.mlResult==='W'?'var(--green)':s.mlResult==='L'?'var(--red)':'var(--text-muted)';
    const atsC = s.atsResult==='W'?'var(--green)':s.atsResult==='L'?'var(--red)':s.atsResult==='P'?'var(--orange)':'var(--text-muted)';
    const mlPL = s.mlPayout!==null ? (s.mlPayout>=0?'+':'')+' $'+s.mlPayout.toLocaleString() : '-';
    const mlPLC = (s.mlPayout||0)>0?'var(--green)':(s.mlPayout||0)<0?'var(--red)':'var(--text-muted)';
    const atsPL = s.atsPayout!==null ? (s.atsPayout>=0?'+':'')+' $'+s.atsPayout.toLocaleString() : '-';
    const atsPLC = (s.atsPayout||0)>0?'var(--green)':(s.atsPayout||0)<0?'var(--red)':'var(--text-muted)';
    const sigs = (s.signals||[]).map(x => '<span style="display:inline-block;font-size:8px;padding:1px 4px;border-radius:3px;background:var(--accent-light);color:var(--accent);font-weight:600;margin-left:2px">'+x+'</span>').join('');

    h += '<tr>';
    h += '<td style="'+td+';font-size:10px;color:var(--text-muted)">'+s.date+'</td>';
    h += '<td style="'+td+';font-weight:600">'+modeBadge+s.game+'</td>';
    h += '<td style="'+td+';color:var(--accent);font-weight:700">'+s.signalSide+' '+sigs+'</td>';
    h += '<td style="'+td+';font-weight:700;color:'+(s.recType==='ML'?'var(--orange)':'var(--purple, #7c3aed)')+'">'+s.recType+'</td>';
    h += '<td style="'+td+';font-family:monospace">'+(s.spreadLine||'-')+'</td>';
    h += '<td style="'+td+';font-family:monospace;font-size:10px">'+scoreAt+'</td>';
    h += '<td style="'+td+';font-family:monospace;font-weight:700">'+final_+'</td>';
    h += '<td style="'+td+';font-family:monospace;font-size:10px">$'+(s.kellyBet||0).toLocaleString()+' <span style="color:var(--text-muted);font-size:8px">('+((s.kellyPct||0))+'%)</span></td>';
    h += '<td style="'+td+';font-weight:800;color:'+mlC+'">'+(s.mlResult||'-')+'</td>';
    h += '<td style="'+td+';font-weight:800;color:'+atsC+'">'+(s.atsResult||'-')+'</td>';
    h += '<td style="'+td+';font-family:monospace;color:'+mlPLC+'">'+mlPL+'</td>';
    h += '<td style="'+td+';font-family:monospace;color:'+atsPLC+'">'+atsPL+'</td>';
    h += '</tr>';
  });

  h += '</tbody></table></div></div>';
  el.innerHTML = h;
}

function exportSignalTracker() {
  const data = state.signalTracker;
  if (data.length === 0) { alert('No signals tracked yet'); return; }
  let csv = 'Date,Game,SignalSide,RecType,SpreadLine,Signals,MarketOdds,KellyPct,KellyBet,EstEdge,AwayScore,HomeScore,Period,Clock,FinalAway,FinalHome,ML,ATS,MLPayout,ATSPayout\n';
  data.forEach(s => {
    csv += s.date+',"'+s.game+'",'+s.signalSide+','+s.recType+','+(s.spreadLine||'')+',"'+(s.signals||[]).join(';')+'",'+(s.marketOdds||'')+','+(s.kellyPct||'')+','+(s.kellyBet||'')+','+(s.estEdge||'')+','+s.awayScore+','+s.homeScore+','+(s.period||'')+','+(s.clock||'')+','+(s.finalAwayScore!==null?s.finalAwayScore:'')+','+(s.finalHomeScore!==null?s.finalHomeScore:'')+','+(s.mlResult||'')+','+(s.atsResult||'')+','+(s.mlPayout||0)+','+(s.atsPayout||0)+'\n';
  });
  const blob = new Blob([csv], {type:'text/csv'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'signal-backtest-'+new Date().toISOString().split('T')[0]+'.csv';
  a.click();
}


// ==================== AUTO-RESOLVE BETS FROM ESPN FINAL SCORES ====================
async function autoResolveBets() {
  let log = JSON.parse(localStorage.getItem('betLog') || '[]');
  const pending = log.filter(b => !b.outcome && b.gameId);
  if (pending.length === 0) return;

  try {
    // Fetch scoreboard  it includes completed games from today
    const url = getESPNUrl();
    const resp = await fetch(url);
    if (!resp.ok) return;
    const data = await resp.json();
    const events = data.events || [];

    let changed = false;
    pending.forEach(bet => {
      // Find the matching game by gameId
      const event = events.find(e => e.id === bet.gameId || e.id === String(bet.gameId));
      if (!event) return;

      // Only resolve if game is FINAL
      const gameState = event.status?.type?.state;
      if (gameState !== 'post') return;

      const comp = event.competitions?.[0];
      if (!comp) return;
      const away = comp.competitors?.find(c => c.homeAway === 'away');
      const home = comp.competitors?.find(c => c.homeAway === 'home');
      if (!away || !home) return;

      const aScore = parseInt(away.score) || 0;
      const hScore = parseInt(home.score) || 0;
      const aAbbr = away.team?.abbreviation || '';
      const hAbbr = home.team?.abbreviation || '';

      // Determine winner abbreviation
      const winner = aScore > hScore ? aAbbr : hAbbr;

      // Check if our bet team won
      // bet.team could be abbreviation like "BOS" or display name
      const betTeamUpper = bet.team.toUpperCase();
      const betWon = betTeamUpper === winner.toUpperCase() ||
                     winner.toUpperCase().includes(betTeamUpper) ||
                     betTeamUpper.includes(winner.toUpperCase());

      bet.outcome = betWon ? 'W' : 'L';
      bet.finalScore = aAbbr + ' ' + aScore + ' - ' + hScore + ' ' + hAbbr;

      if (betWon) {
        const odds = bet.marketOdds;
        const multiplier = odds > 0 ? odds / 100 : 100 / Math.abs(odds);
        bet.payout = Math.round(bet.kellyBet * multiplier * 100) / 100;
      } else {
        bet.payout = -bet.kellyBet;
      }

      changed = true;
    });

    if (changed) {
      localStorage.setItem('betLog', JSON.stringify(log));
      renderBetLog();
      updateBacktestPanel();
    }
  } catch (e) {
    console.warn('Auto-resolve error:', e);
  }
}

function markOutcome(id, won) {
  let log = JSON.parse(localStorage.getItem('betLog') || '[]');
  const entry = log.find(x => x.id === id);
  if (!entry) return;
  entry.outcome = won ? 'W' : 'L';
  if (won) {
    const b = entry.marketOdds > 0 ? entry.marketOdds / 100 : 100 / Math.abs(entry.marketOdds);
    entry.payout = Math.round(entry.kellyBet * b * 100) / 100;
  } else {
    entry.payout = -entry.kellyBet;
  }
  localStorage.setItem('betLog', JSON.stringify(log));
  renderBetLog();
  updateBacktestPanel();
}

function getBacktestData() {
  const log = JSON.parse(localStorage.getItem('betLog') || '[]');
  const settled = log.filter(x => x.outcome);
  const total = settled.length;
  const wins = settled.filter(x => x.outcome === 'W').length;
  const winRate = total > 0 ? Math.round(wins / total * 1000) / 10 : 0;
  const totalPayout = settled.reduce((s, x) => s + (x.payout || 0), 0);
  const totalRisked = settled.reduce((s, x) => s + x.kellyBet, 0);
  const roi = totalRisked > 0 ? Math.round(totalPayout / totalRisked * 1000) / 10 : 0;
  const avgEdge = total > 0 ? Math.round(settled.reduce((s, x) => s + (x.estimatedP - x.impliedP), 0) / total * 10) / 10 : 0;
  const units = Math.round(totalPayout / 100 * 100) / 100;
  const bySignal = {};
  settled.forEach(x => {
    (x.signals || []).forEach(sig => {
      if (!bySignal[sig]) bySignal[sig] = { total: 0, wins: 0, payout: 0 };
      bySignal[sig].total++;
      if (x.outcome === 'W') bySignal[sig].wins++;
      bySignal[sig].payout += (x.payout || 0);
    });
  });
  return { total, wins, winRate, roi, edge: avgEdge / 100, units, bySignal };
}

function renderBetLog() {
  const el = document.getElementById('bet-log-entries');
  if (!el) return;
  const log = JSON.parse(localStorage.getItem('betLog') || '[]').slice().reverse();
  if (log.length === 0) {
    el.innerHTML = '<p style="color:var(--text-muted);text-align:center;padding:40px;font-size:13px">No bets logged yet. Bets are auto-logged when combined signals fire.</p>';
    return;
  }
  const thS = 'padding:10px 12px;font-size:10px;font-weight:700;text-transform:uppercase;letter-spacing:1px;color:var(--text-muted);border-bottom:2px solid var(--border)';
  let html = '<table style="width:100%;border-collapse:collapse;font-size:12px"><thead><tr>';
  html += '<th style="' + thS + ';text-align:left">TIME</th>';
  html += '<th style="' + thS + ';text-align:left">TEAM</th>';
  html += '<th style="' + thS + ';text-align:left">SIGNALS</th>';
  html += '<th style="' + thS + ';text-align:right">ODDS</th>';
  html += '<th style="' + thS + ';text-align:right">EDGE</th>';
  html += '<th style="' + thS + ';text-align:right">KELLY</th>';
  html += '<th style="' + thS + ';text-align:right">SIZE</th>';
  html += '<th style="' + thS + ';text-align:center">RESULT</th>';
  html += '<th style="' + thS + ';text-align:right">P/L</th>';
  html += '</tr></thead><tbody>';
  log.forEach(b => {
    const t = new Date(b.timestamp);
    const time = (t.getMonth()+1) + '/' + t.getDate() + ' ' + t.getHours() + ':' + String(t.getMinutes()).padStart(2,'0');
    const oddsStr = b.marketOdds > 0 ? '+' + b.marketOdds : '' + b.marketOdds;
    const edgeVal = b.estimatedP && b.impliedP ? (b.estimatedP - b.impliedP).toFixed(1) + '%' : '-';
    let resultCell;
    if (b.outcome) {
      const color = b.outcome === 'W' ? 'var(--green)' : 'var(--red)';
      const bg = b.outcome === 'W' ? 'var(--green-light)' : 'var(--red-light)';
      resultCell = '<span style="color:' + color + ';background:' + bg + ';font-weight:700;padding:2px 10px;border-radius:4px;font-size:11px">' + b.outcome + '</span>';
      if (b.finalScore) resultCell += '<div style="font-size:9px;color:var(--text-muted);margin-top:2px">' + b.finalScore + '</div>';
    } else {
      resultCell = '<span style="font-size:10px;color:var(--orange);font-weight:600">PENDING</span>';
      resultCell += '<div style="margin-top:3px"><button onclick="markOutcome(' + b.id + ',true)" style="background:var(--green-light);color:var(--green);border:none;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:10px;font-weight:700;margin-right:3px">W</button>';
      resultCell += '<button onclick="markOutcome(' + b.id + ',false)" style="background:var(--red-light);color:var(--red);border:none;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:10px;font-weight:700">L</button></div>';
    }
    const plStr = b.payout != null ? (b.payout >= 0 ? '+$' : '-$') + Math.abs(b.payout).toFixed(0) : '-';
    const plColor = b.payout > 0 ? 'var(--green)' : b.payout < 0 ? 'var(--red)' : 'var(--text-muted)';
    const sigBadges = (b.signals||[]).map(s => '<span class="signal-badge badge-' + s + '" style="font-size:9px;padding:1px 6px">' + s.toUpperCase() + '</span>').join(' ');
    html += '<tr style="border-bottom:1px solid var(--border-light)">';
    html += '<td style="padding:10px 12px;color:var(--text-muted);font-size:11px">' + time + '</td>';
    html += '<td style="padding:10px 12px;color:var(--text-primary);font-weight:700">' + b.team + ' <span style="color:var(--text-muted);font-weight:400">' + (b.side||'ML') + '</span></td>';
    html += '<td style="padding:10px 12px">' + sigBadges + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-secondary);font-family:monospace">' + oddsStr + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--accent);font-weight:600">' + edgeVal + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-secondary)">' + b.kellyPct + '%</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-primary);font-weight:700">$' + b.kellyBet + '</td>';
    html += '<td style="padding:10px 12px;text-align:center">' + resultCell + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:' + plColor + ';font-weight:700">' + plStr + '</td>';
    html += '</tr>';
  });
  html += '</tbody></table>';
  el.innerHTML = html;
}

function updateBacktestPanel() {
  const d = getBacktestData();
  const btTotal = document.getElementById('bt-total');
  if (!btTotal) return;
  btTotal.textContent = d.total;
  const wrEl = document.getElementById('bt-winrate');
  wrEl.textContent = d.total > 0 ? d.winRate + '%' : '-';
  wrEl.style.color = d.winRate >= 55 ? 'var(--green)' : d.winRate >= 45 ? 'var(--orange)' : 'var(--red)';
  const roiEl = document.getElementById('bt-roi');
  roiEl.textContent = d.total > 0 ? (d.roi >= 0 ? '+' : '') + d.roi + '%' : '-';
  roiEl.style.color = d.roi > 0 ? 'var(--green)' : d.roi < 0 ? 'var(--red)' : 'var(--text-primary)';
  document.getElementById('bt-edge').textContent = d.total > 0 ? (d.edge * 100).toFixed(1) + '%' : '-';
  const unitsEl = document.getElementById('bt-units');
  unitsEl.textContent = (d.units >= 0 ? '+' : '') + d.units.toFixed(2);
  unitsEl.style.color = d.units > 0 ? 'var(--green)' : d.units < 0 ? 'var(--red)' : 'var(--text-primary)';
  const bd = document.getElementById('signal-breakdown');
  if (!bd) return;
  const sigs = Object.keys(d.bySignal);
  if (sigs.length === 0) { bd.innerHTML = ''; return; }
  let html = '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:10px">';
  sigs.forEach(sig => {
    const sd = d.bySignal[sig];
    const wr = sd.total > 0 ? Math.round(sd.wins / sd.total * 100) : 0;
    const wrColor = wr >= 55 ? 'var(--green)' : wr >= 45 ? 'var(--orange)' : 'var(--red)';
    html += '<div class="stat-card" style="padding:12px"><div style="margin-bottom:6px"><span class="signal-badge badge-' + sig + '" style="font-size:10px">' + sig.toUpperCase() + '</span></div>';
    html += '<div style="color:' + wrColor + ';font-size:20px;font-weight:800">' + wr + '%</div>';
    html += '<div style="color:var(--text-muted);font-size:11px;margin-top:2px">' + sd.wins + 'W-' + (sd.total - sd.wins) + 'L | $' + Math.round(sd.payout) + '</div></div>';
  });
  html += '</div>';
  bd.innerHTML = html;
}

function updateKelly() {
  const el = document.getElementById('kelly-recs');
  if (!el) return;
  if (typeof gameTheses === 'undefined' || !gameTheses || gameTheses.length === 0) {
    el.innerHTML = '<p style="color:var(--text-muted);text-align:center;padding:30px;font-size:13px">Refresh games to see Kelly-sized recommendations</p>';
    return;
  }
  const recs = gameTheses.filter(t => t.marketOdds && t.kellyPct > 0);
  if (recs.length === 0) {
    el.innerHTML = '<p style="color:var(--text-muted);text-align:center;padding:30px;font-size:13px">No positive-edge bets found in current games</p>';
    return;
  }
  const thS = 'padding:10px 12px;font-size:10px;font-weight:700;text-transform:uppercase;letter-spacing:1px;color:var(--text-muted);border-bottom:2px solid var(--border)';
  let html = '<table style="width:100%;border-collapse:collapse;font-size:13px"><thead><tr>';
  html += '<th style="' + thS + ';text-align:left">GAME</th>';
  html += '<th style="' + thS + ';text-align:left">BET</th>';
  html += '<th style="' + thS + ';text-align:right">ODDS</th>';
  html += '<th style="' + thS + ';text-align:right">EDGE</th>';
  html += '<th style="' + thS + ';text-align:right">KELLY %</th>';
  html += '<th style="' + thS + ';text-align:right">BET SIZE</th>';
  html += '</tr></thead><tbody>';
  recs.forEach(t => {
    const oddsStr = t.marketOdds > 0 ? '+' + t.marketOdds : '' + t.marketOdds;
    const sigs = (t.signals||[]).filter(s=>s.level===2).map(s => '<span class="signal-badge badge-' + s.type + '" style="font-size:9px;padding:1px 6px">' + s.type.toUpperCase() + '</span>').join(' ');
    html += '<tr style="border-bottom:1px solid var(--border-light)">';
    html += '<td style="padding:10px 12px;color:var(--text-primary);font-weight:600">' + (t.game||t.betSide) + '</td>';
    html += '<td style="padding:10px 12px"><span style="color:var(--accent);font-weight:700">' + t.betSide + ' ML</span> ' + sigs + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-secondary);font-family:monospace">' + oddsStr + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--accent);font-weight:600">' + (t.kellyEdge||t.edge||'-') + '%</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-primary);font-weight:700">' + t.kellyPct + '%</td>';
    html += '<td style="padding:10px 12px;text-align:right"><span style="background:var(--accent-light);color:var(--accent);font-weight:800;padding:4px 12px;border-radius:6px;font-size:13px">$' + t.kellyBet + '</span></td>';
    html += '</tr>';
  });
  html += '</tbody></table>';
  el.innerHTML = html;
}

function saveBankrollSettings() {
  localStorage.setItem('bankrollSettings', JSON.stringify({
    bankroll: document.getElementById('bankroll-input').value,
    fraction: document.getElementById('kelly-fraction').value,
    edgeMode: document.getElementById('edge-mode').value
  }));
  updateKelly();
    renderStarDB();
}

function loadBankrollSettings() {
  const saved = JSON.parse(localStorage.getItem('bankrollSettings') || 'null');
  if (!saved) return;
  const bi = document.getElementById('bankroll-input');
  if (bi) bi.value = saved.bankroll || 1000;
  const kf = document.getElementById('kelly-fraction');
  if (kf) kf.value = saved.fraction || '0.5';
  const em = document.getElementById('edge-mode');
  if (em) em.value = saved.edgeMode || 'moderate';
}

function exportBetLog() {
  const log = JSON.parse(localStorage.getItem('betLog') || '[]');
  if (log.length === 0) { alert('No bets to export'); return; }
  let csv = 'Timestamp,Team,Side,Signals,MarketOdds,ImpliedP,EstimatedP,KellyPct,BetSize,Outcome,PL\n';
  log.forEach(b => {
    csv += b.timestamp + ',' + b.team + ',' + b.side + ',"' + (b.signals||[]).join(';') + '",' + b.marketOdds + ',' + b.impliedP + ',' + b.estimatedP + ',' + b.kellyPct + ',' + b.kellyBet + ',' + (b.outcome||'') + ',' + (b.payout||0) + '\n';
  });
  const blob = new Blob([csv], {type:'text/csv'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'bet_log_' + new Date().toISOString().slice(0,10) + '.csv';
  a.click();
}

function clearBetLog() {
  localStorage.removeItem('betLog');
  renderBetLog();
  updateBacktestPanel();
}
function resolveBet(id,r) {
  const b=state.betLog.find(x=>x.id===id); if(!b) return; b.result=r;
  if(r==='W'){const p=parseInt(b.price)||-110; b.profit=p>0?b.units*(p/100):b.units*(100/Math.abs(p));}
  else if(r==='L') b.profit=-b.units; else b.profit=0;
  localStorage.setItem('betLog',JSON.stringify(state.betLog)); renderBetLog();
}
function updateLogStats() {
  const r=state.betLog.filter(b=>b.result!=='Pending'), w=r.filter(b=>b.result==='W').length, t=r.length;
  const nu=r.reduce((s,b)=>s+b.profit,0), tr=r.reduce((s,b)=>s+b.units,0);
  document.getElementById('log-total').textContent=state.betLog.length;
  document.getElementById('log-winrate').textContent=t>0?(w/t*100).toFixed(1)+'%':'-';
  document.getElementById('log-net-units').textContent=(nu>=0?'+':'')+nu.toFixed(2);
  document.getElementById('log-net-units').className=`stat-value ${nu>=0?'green':'red'}`;
  document.getElementById('log-roi').textContent=tr>0?(nu/tr*100).toFixed(1)+'%':'-';
  let streak=0,st='';
  for(let i=r.length-1;i>=0;i--){if(i===r.length-1){st=r[i].result;streak=1;}else if(r[i].result===st)streak++;else break;}
  const se=document.getElementById('log-streak');
  if(streak>0){se.textContent=streak+st;se.className=`stat-value ${st==='W'?'green':st==='L'?'red':''}`;}else se.textContent='-';
}
function clearLog(){if(confirm('Clear ALL?')){state.betLog=[];localStorage.setItem('betLog','[]');renderBetLog();}}
function exportLog(){
  if(!state.betLog.length){alert('No bets');return;}
  const h='Date,Strategy,Game,Side,Price,Units,Result,Profit,Notes\n';
  const r=state.betLog.map(b=>`${b.date},${b.strategy},"${b.game}",${b.side},${b.price},${b.units},${b.result},${b.profit.toFixed(2)},"${b.notes}"`).join('\n');
  const a=document.createElement('a');a.href=URL.createObjectURL(new Blob([h+r],{type:'text/csv'}));a.download=`NBA_Edge_${new Date().toISOString().slice(0,10)}.csv`;a.click();
}

// ==================== BANKROLL ====================
function updateBankroll() {
  const s=parseFloat(document.getElementById('bankroll-start').value)||0, c=parseFloat(document.getElementById('bankroll-current').value)||0;
  state.bankroll={start:s,current:c}; localStorage.setItem('bankroll',JSON.stringify(state.bankroll));
  const u=c*0.01;
  document.getElementById('br-unit').textContent=u>0?'$'+u.toFixed(0):'-';
  document.getElementById('br-max').textContent=u>0?'$'+(u*2).toFixed(0):'-';
  document.getElementById('br-daily').textContent=u>0?'$'+(u*5).toFixed(0):'-';
  const pl=c-s;
  document.getElementById('br-pl').textContent=s>0?(pl>=0?'+':'')+`$${pl.toFixed(0)}`:'-';
  document.getElementById('br-pl').className=`stat-value ${pl>=0?'green':'red'}`;
  const pct=s>0?(pl/s*100):0;
  document.getElementById('br-pl-pct').textContent=s>0?(pct>=0?'+':'')+pct.toFixed(1)+'%':'-';
  document.getElementById('br-pl-pct').className=`stat-value ${pct>=0?'green':'red'}`;
}
document.getElementById('logModal').addEventListener('click',function(e){if(e.target===this)closeModal();});


// ==================== SOUND SYSTEM (Web Audio API) ====================
let audioCtx = null;
let soundEnabled = JSON.parse(localStorage.getItem('soundEnabled') || 'true');

function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playNote(ctx, freq, startTime, duration, vol, waveType) {
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = waveType || 'sine';
  osc.frequency.setValueAtTime(freq, startTime);
  gain.gain.setValueAtTime(0, startTime);
  gain.gain.linearRampToValueAtTime(vol, startTime + 0.02);
  gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start(startTime);
  osc.stop(startTime + duration);
}

function playAlertSound(type) {
  if (!soundEnabled) return;
  const ctx = initAudio();
  const t = ctx.currentTime;

  if (type === 'coil' || type === 'cold') {
    // Star Coil  gentle ascending chime (C5  E5  G5 major chord arpeggio)
    playNote(ctx, 523.25, t, 0.35, 0.15, 'sine');        // C5
    playNote(ctx, 659.25, t + 0.12, 0.35, 0.12, 'sine'); // E5
    playNote(ctx, 783.99, t + 0.24, 0.5, 0.1, 'sine');   // G5
    // Soft harmonic shimmer on top
    playNote(ctx, 1046.5, t + 0.3, 0.4, 0.04, 'sine');   // C6 (octave shimmer)
  } else if (type === 'hot3pt') {
    // 3PT Fragile  two-tone notification (D5  A5, clean and crisp)
    playNote(ctx, 587.33, t, 0.25, 0.12, 'sine');         // D5
    playNote(ctx, 880.00, t + 0.15, 0.4, 0.10, 'sine');   // A5
    playNote(ctx, 1174.66, t + 0.25, 0.3, 0.04, 'sine');  // D6 shimmer
  } else if (type === 'combined') {
    // Combined Edge  triumphant major chord (C  E  G  C, all at once then arpeggiated)
    playNote(ctx, 523.25, t, 0.6, 0.08, 'sine');          // C5
    playNote(ctx, 659.25, t + 0.08, 0.55, 0.08, 'sine');  // E5
    playNote(ctx, 783.99, t + 0.16, 0.5, 0.08, 'sine');   // G5
    playNote(ctx, 1046.5, t + 0.24, 0.6, 0.10, 'sine');   // C6
    // Sustain chord
    playNote(ctx, 523.25, t + 0.35, 0.5, 0.05, 'triangle'); // C5 pad
    playNote(ctx, 659.25, t + 0.35, 0.5, 0.05, 'triangle'); // E5 pad
    playNote(ctx, 783.99, t + 0.35, 0.5, 0.05, 'triangle'); // G5 pad
  }
}

function toggleSound() {
  soundEnabled = !soundEnabled;
  localStorage.setItem('soundEnabled', JSON.stringify(soundEnabled));
  const btn = document.getElementById('soundToggle');
  btn.classList.toggle('active', soundEnabled);
  btn.innerHTML = soundEnabled ? '&#x1F50A; Sound' : '&#x1F507; Muted';
  if (soundEnabled) playAlertSound('coil'); // test chime
}
// Favorites / Watchlist
function toggleFavorite(gameId) {
  const idx = state.favorites.indexOf(gameId);
  if (idx >= 0) state.favorites.splice(idx, 1);
  else state.favorites.push(gameId);
  localStorage.setItem('favorites', JSON.stringify(state.favorites));
  // Re-sort: move favorites to top
  const grid = document.getElementById('live-games-grid');
  const cards = [...grid.querySelectorAll('.game-card')];
  cards.sort((a,b) => {
    const aFav = state.favorites.includes(a.dataset.gameId) ? 0 : 1;
    const bFav = state.favorites.includes(b.dataset.gameId) ? 0 : 1;
    return aFav - bFav;
  });
  cards.forEach(c => grid.appendChild(c));
  // Toggle star icon
  const star = event.target;
  star.textContent = idx >= 0 ? '\u2606' : '\u2605';
}

// Signal History Dashboard
function renderSignalHistory() {
  const hist = state.signalHistory;
  if (!hist.length) return '<div style="text-align:center;padding:20px;color:var(--text-muted);">No signals recorded yet. Start auto-refresh during live games.</div>';
  const total = hist.length;
  const byType = {};
  hist.forEach(h => { (h.signals||[]).forEach(s => { byType[s] = (byType[s]||0) + 1; }); });
  const typeStats = Object.entries(byType).map(([k,v]) => `<span style="background:var(--accent-light);color:var(--accent);padding:2px 8px;border-radius:10px;font-size:11px;font-weight:600;">${k.toUpperCase()}: ${v}</span>`).join(' ');
  const recent = hist.slice(-10).reverse().map(h => 
    `<div style="display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid var(--border-light);font-size:11px;">` +
    `<span style="font-weight:600;">${h.game}</span>` +
    `<span style="color:var(--accent);font-weight:700;">BET ${h.betSide}</span>` +
    `<span>${h.signals.map(s=>s.toUpperCase()).join('+')}</span>` +
    `<span style="color:var(--text-muted);">${h.date}</span></div>`
  ).join('');
  return `<div style="margin-bottom:12px;"><div style="font-size:13px;font-weight:700;margin-bottom:6px;">Signal Summary</div><div style="font-size:22px;font-weight:800;color:var(--accent);">${total}</div><div style="font-size:10px;color:var(--text-muted);">Total signals recorded</div><div style="margin-top:8px;">${typeStats}</div></div><div style="font-size:13px;font-weight:700;margin-bottom:6px;">Recent Signals</div>${recent}`;
}

function toggleDarkMode() {
  const html = document.documentElement;
  const isDark = html.getAttribute('data-theme') === 'dark';
  html.setAttribute('data-theme', isDark ? '' : 'dark');
  localStorage.setItem('darkMode', isDark ? '' : 'dark');
  const btn = document.getElementById('darkModeToggle');
  btn.textContent = isDark ? 'Dark' : 'Light';
}
// Auto-load dark mode preference
(function() {
  const saved = localStorage.getItem('darkMode');
  if (saved === 'dark') {
    document.documentElement.setAttribute('data-theme', 'dark');
    setTimeout(() => { const btn = document.getElementById('darkModeToggle'); if(btn) btn.textContent = 'Light'; }, 100);
  }
})();

// Init sound button state
document.addEventListener('DOMContentLoaded', function() {
    // Restore saved mode (NBA or NCAAB)
    const savedMode = localStorage.getItem('alphaMode') || 'nba';
    if (savedMode !== currentMode) {
      currentMode = savedMode;
      const subtitle = document.getElementById('main-subtitle');
      if (subtitle) subtitle.innerHTML = savedMode === 'ncaab' ? 'NCAAB &bull; DATA-DRIVEN ANALYTICS' : 'NBA &bull; DATA-DRIVEN ANALYTICS';
      const modeBtn = document.getElementById('modeToggleBtn');
      if (modeBtn) modeBtn.textContent = savedMode === 'ncaab' ? 'NCAAB' : 'NBA';
      const starCol = document.getElementById('star-col-q1');
      if (starCol) starCol.textContent = savedMode === 'ncaab' ? 'H1 Pace' : 'Q1 Pace';
      const starTitle = document.getElementById('star-db-title');
      if (starTitle) starTitle.textContent = savedMode === 'ncaab' ? 'Star Player Database (16+ PPG)' : 'Star Player Database (21+ PPG)';
      const starSub = document.getElementById('star-db-subtitle');
      if (starSub) starSub.textContent = savedMode === 'ncaab' ? 'Signal: <65% pace, 8-35 min, margin 12' : 'Signal: <65% of expected pace';
      // Swap star database for NCAA
      if (savedMode === 'ncaab') {
        if (!state._nbaStars) state._nbaStars = DEFAULT_STARS;
        state.stars = ncaaStarCache.length > 0 ? ncaaStarCache.map(s => ({name:s.name,team:s.team,ppg:s.ppg})) : [];
      }
    }
    // Update signal guide for current mode
    try { updateSignalGuide(currentMode); } catch(e) {}
    // Build NCAA star database on startup if in NCAAB mode
    if (currentMode === 'ncaab') {
      buildNcaaStarDB().then(() => {
        if (ncaaStarCache.length > 0) {
          state.stars = ncaaStarCache.map(s => ({name:s.name,team:s.team,ppg:s.ppg}));
          renderStarDB();
        }
      });
    }
    // Import signals from background engine (engine-signals.json)
    importEngineSignals();
    loadBankrollSettings();
    renderBetLog();
    updateBacktestPanel();
    updateKelly();
    renderStarDB();
    renderSignalTracker();

  const btn = document.getElementById('soundToggle');
  if (btn) {
    btn.classList.toggle('active', soundEnabled);
    btn.innerHTML = soundEnabled ? '&#x1F50A; Sound' : '&#x1F507; Muted';
  }

  // Auto-start refresh so signals are detected without manual interaction
  if (!state.autoRefresh) {
    toggleAutoRefresh();
  }
});

// ==================== SCENARIO ALERT SYSTEM ====================
let activeAlerts = [];
let alertIdCounter = 0;
const ALERT_HISTORY = JSON.parse(localStorage.getItem('alertHistory') || '[]');

function showScenarioAlert(data) {
  // No popup alerts  signals show on chips and game cards only
  // Just save to history silently
  ALERT_HISTORY.unshift({ ...data, time: new Date().toISOString() });
  if (ALERT_HISTORY.length > 50) ALERT_HISTORY.length = 50;
  localStorage.setItem('alertHistory', JSON.stringify(ALERT_HISTORY));
}

function dismissAlert(id) {
  const el = document.getElementById(id);
  if (el) {
    el.style.animation = 'alertSlideIn 0.3s ease-in reverse';
    setTimeout(() => el.remove(), 300);
  }
  activeAlerts = activeAlerts.filter(a => a !== id);
}

// ==================== DEMO SIMULATION MODE ====================
// ==================== HOOK: FIRE SCENARIO ALERTS FROM LIVE DATA ====================
// Override the original signal detection to also trigger scenario alerts
const _origShowQuarterToast = showQuarterToast;
const _firedAlerts = new Set(); // prevent duplicate alerts per game refresh

function fireStarCoilAlert(leader, star, gMins, per, clk, gLabel, paceRatio, margin) {
  const alertKey = star.name + '_' + per + '_' + Math.floor(gMins);
  if (_firedAlerts.has(alertKey)) return;
  _firedAlerts.add(alertKey);
  // Clear old keys every 5 minutes
  setTimeout(() => _firedAlerts.delete(alertKey), 300000);

  const exp = getExpectedByTime(star.ppg, gMins);
  showScenarioAlert({
    player: leader.name,
    team: star.team,
    game: gLabel,
    quarter: per,
    clock: clk,
    currentPts: leader.pts,
    expectedPts: exp,
    ppg: star.ppg,
    pacePercent: paceRatio * 100,
    type: 'coil',
    signals: ['Star at ' + (paceRatio * 100).toFixed(0) + '% pace', 'Below 65% threshold', 'Game within ' + margin + ' pts', (isNCAA() ? (per <= 2 ? 'H' + per : 'OT') : 'Q' + per) + '  prime window']
  });
}

function fire3PTAlert(teamAbbr, pct, made, att, gLabel, per, clk) {
  const alertKey = teamAbbr + '_3pt_' + per;
  if (_firedAlerts.has(alertKey)) return;
  _firedAlerts.add(alertKey);
  setTimeout(() => _firedAlerts.delete(alertKey), 300000);
  
  showScenarioAlert({
    player: teamAbbr + ' Team',
    team: teamAbbr + ' shooting unsustainably hot',
    game: gLabel,
    quarter: per,
    clock: clk,
    currentPts: parseFloat(pct),
    expectedPts: getLeague3PtAvg(),
    ppg: getLeague3PtAvg(),
    pacePercent: (parseFloat(pct) / getLeague3PtAvg()) * 100,
    type: 'hot3pt',
    signals: [teamAbbr + ' at ' + pct + '% from 3 (' + made + '/' + att + ')']
  });

    // Ensure star DB renders on page load
    renderStarDB();

}

</script>
<script>try { renderStarDB(); } catch(e) {}</script>
<script>
// Sync 3PT stats from original IDs to signal strip duplicates
(function() {
  var pairs = [];
  function syncStats() {
    pairs.forEach(function(p) {
      var src = document.getElementById(p[0]);
      var dst = document.getElementById(p[1]);
      if (src && dst && dst.textContent !== src.textContent) {
        dst.textContent = src.textContent;
        // Copy color class
        dst.className = dst.className.replace(/ ?(orange|red|purple|green|teal)/g, '');
        if (src.classList.contains('orange')) dst.classList.add('orange');
        if (src.classList.contains('red')) dst.classList.add('red');
        if (src.classList.contains('purple')) dst.classList.add('purple');
        if (src.classList.contains('teal')) dst.classList.add('teal');
      }
    });
  }
  setInterval(syncStats, 2000);
  setTimeout(syncStats, 1000);
})();
</script>
<script>
// Pre-compute odds API URL for historical odds
try {
  var _s = fetchLiveOdds.toString();
  var _k = _s.match(/[a-f0-9]{32}/);
  if (_k) {
    var _sp = (typeof getOddsSport === 'function') ? getOddsSport() : 'basketball_nba';
    window.__ODDS_BASE_URL = 'https://api.the-odds-api.com/v4/sports/' + _sp + '/odds?apiK' + 'ey=' + _k[0] + '&regions=us&markets=h2h&oddsFormat=american&bookmakers=fanduel,draftkings,betmgm';
  }
} catch(e) {}
</script>
<script>
// ==================== ODDS HISTORY TRACKER (API-BASED) ====================
(function() {
  var OH_CACHE_KEY = 'oddsHistoryCache';
  var CACHE_TTL = 1800000; // 30 min cache

  // Intercept the live odds fetch to capture the base URL with API key
  var capturedBaseURL = window.__ODDS_BASE_URL || null;

    // Extract API URL from fetchLiveOdds source code
    try {
      if (typeof fetchLiveOdds === 'function') {
        var src = fetchLiveOdds.toString();
        var hexMatch = src.match(/[a-f0-9]{32}/);
        if (hexMatch) {
          var sport = (typeof getOddsSport === 'function') ? getOddsSport() : 'basketball_nba';
          capturedBaseURL = 'https://api.the-odds-api.com/v4/sports/' + sport + '/odds?apiKey=' + hexMatch[0] + '&regions=us&markets=h2h&oddsFormat=american&bookmakers=fanduel,draftkings,betmgm';
        }
      }
    } catch(e) {}

    // Also wrap fetch calls to capture URL at runtime as backup
    function _wrapFetchForCapture(orig) {
      return function(url) {
        if (typeof url === 'string' && url.indexOf('the-odds-api') > -1 && url.indexOf('v4/sports') > -1) {
          capturedBaseURL = url;
        }
        return orig.apply(this, arguments);
      };
    }
    if (window._origFetchReal) { window._origFetchReal = _wrapFetchForCapture(window._origFetchReal); }
    window.fetch = _wrapFetchForCapture(window.fetch);
    var _realFetch = window._origFetchReal || window.fetch;

    function buildHistoricalURL(dateISO) {
    if (!capturedBaseURL) return null;
    // Change /v4/sports/ to /v4/historical/sports/ and add date param
    var histURL = capturedBaseURL.replace('/v4/sports/', '/v4/historical/sports/');
    histURL += '&date=' + encodeURIComponent(dateISO);
    return histURL;
  }

  // Fetch 12h of historical odds (every hour)
  async function fetchOddsHistory(eventId, awayName, homeName) {
    var cacheKey = OH_CACHE_KEY + '_' + eventId;
    var cached = null;
    try { cached = JSON.parse(localStorage.getItem(cacheKey)); } catch(e) {}
    if (cached && (Date.now() - cached.ts) < CACHE_TTL) {
      return cached.data;
    }

    if (!capturedBaseURL) {
      // Try to trigger a fetch first
      if (typeof fetchLiveOdds === 'function') {
        try { await fetchLiveOdds(); } catch(e) {}
        await new Promise(function(r) { setTimeout(r, 2000); });
      }
      if (!capturedBaseURL) return [];
    }

    var points = [];
    var now = new Date();
    // Fetch every hour for last 12h = 12 API calls
    var intervals = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];

    for (var i = intervals.length - 1; i >= 0; i--) {
      var hrs = intervals[i];
      var d = new Date(now.getTime() - hrs * 3600000);
      var iso = d.toISOString().replace(/\.\d+Z/, 'Z');
      var url = buildHistoricalURL(iso);
      if (!url) continue;
      
      try {
        var resp = await _realFetch(url);
        if (!resp.ok) continue;
        var json = await resp.json();
        var data = json.data || json;
        if (!Array.isArray(data)) continue;
        
        // Find the matching event
        for (var j = 0; j < data.length; j++) {
          var ev = data[j];
          var matchesEvent = ev.id === eventId;
          var matchesTeam = false;
          if (!matchesEvent && ev.home_team && ev.away_team) {
            var ht = ev.home_team.toLowerCase();
            var at = ev.away_team.toLowerCase();
            matchesTeam = ht.includes(homeName.toLowerCase().substring(0,4)) ||
                          at.includes(awayName.toLowerCase().substring(0,4));
          }
          if (matchesEvent || matchesTeam) {
            var bk = ev.bookmakers && ev.bookmakers[0];
            if (bk && bk.markets) {
              var mkt = bk.markets.find(function(m) { return m.key === 'h2h'; });
              if (mkt && mkt.outcomes) {
                var awayOdds = null, homeOdds = null;
                mkt.outcomes.forEach(function(o) {
                  if (o.name === ev.away_team) awayOdds = o.price;
                  if (o.name === ev.home_team) homeOdds = o.price;
                });
                points.push({
                  t: d.getTime(),
                  a: awayOdds,
                  h: homeOdds,
                  src: bk.title || bk.key
                });
              }
            }
            break;
          }
        }
      } catch(e) {
        console.log('[Alpha Hunter] Historical fetch error for -' + hrs + 'h:', e.message);
      }
    }

    // Add current odds from oddsCache if available
    if (typeof oddsCache !== 'undefined') {
      var keys = Object.keys(oddsCache);
      for (var k = 0; k < keys.length; k++) {
        var ck = keys[k];
        if (ck.toLowerCase().includes(homeName.toLowerCase().substring(0,4)) ||
            ck.toLowerCase().includes(awayName.toLowerCase().substring(0,4))) {
          var co = oddsCache[ck];
          if (co && co.h2h) {
            points.push({ t: now.getTime(), a: co.h2h.away, h: co.h2h.home, src: 'Live' });
          }
          break;
        }
      }
    }

    // Sort by time
    points.sort(function(a, b) { return a.t - b.t; });

    // Cache
    try {
      if (points.length > 0) localStorage.setItem(cacheKey, JSON.stringify({ ts: Date.now(), data: points }));
    } catch(e) {}

    return points;
  }

  // Format ML odds
  function fmtML(val) {
    if (val === undefined || val === null) return '-';
    var n = parseFloat(val);
    return n > 0 ? '+' + n : '' + n;
  }

  function fmtTime(ts) {
    var d = new Date(ts);
    var h = d.getHours();
    var ampm = h >= 12 ? 'p' : 'a';
    h = h % 12 || 12;
    return h + ampm;
  }

  function buildOddsHistoryHTML(points, awayName, homeName) {
    if (!points || points.length === 0) {
      return '<div style="padding:16px;color:var(--text-muted);font-size:13px;text-align:center;">No historical data available. Click Refresh first to load games.</div>';
    }

    var rows = '';
    var prevA = null, prevH = null;
    points.forEach(function(p) {
      var timeStr = fmtTime(p.t);
      var awayML = fmtML(p.a);
      var homeML = fmtML(p.h);

      // Arrow indicators for movement
      var aDelta = prevA !== null && p.a !== null ? (p.a > prevA ? ' \u2191' : p.a < prevA ? ' \u2193' : '') : '';
      var hDelta = prevH !== null && p.h !== null ? (p.h > prevH ? ' \u2191' : p.h < prevH ? ' \u2193' : '') : '';
      var aColor = p.a > 0 ? 'var(--red)' : 'var(--green)';
      var hColor = p.h > 0 ? 'var(--red)' : 'var(--green)';

      rows += '<tr style="border-bottom:1px solid var(--border-light);">' +
        '<td style="padding:5px 10px;font-size:11px;color:var(--text-secondary);white-space:nowrap;">' + timeStr + '</td>' +
        '<td style="padding:5px 10px;font-size:13px;font-weight:700;color:' + aColor + ';text-align:right;font-variant-numeric:tabular-nums;">' + awayML + '<span style="font-size:10px;">' + aDelta + '</span></td>' +
        '<td style="padding:5px 10px;font-size:13px;font-weight:700;color:' + hColor + ';text-align:right;font-variant-numeric:tabular-nums;">' + homeML + '<span style="font-size:10px;">' + hDelta + '</span></td>' +
        '<td style="padding:5px 10px;font-size:10px;color:var(--text-muted);">' + (p.src || '') + '</td></tr>';

      prevA = p.a; prevH = p.h;
    });

    // Show movement summary
    var first = points[0], last = points[points.length - 1];
    var aMoved = first.a && last.a ? (last.a - first.a) : 0;
    var hMoved = first.h && last.h ? (last.h - first.h) : 0;
    var summary = '<div style="display:flex;gap:16px;padding:8px 12px;background:var(--bg);font-size:11px;color:var(--text-secondary);">' +
      '<span><b>' + (awayName || 'Away') + '</b> moved ' + (aMoved > 0 ? '+' : '') + aMoved + '</span>' +
      '<span><b>' + (homeName || 'Home') + '</b> moved ' + (hMoved > 0 ? '+' : '') + hMoved + '</span>' +
      '<span style="margin-left:auto;color:var(--text-muted);">' + points.length + ' snapshots</span></div>';

    return summary +
      '<div style="max-height:260px;overflow-y:auto;">' +
      '<table style="width:100%;border-collapse:collapse;font-family:Inter,sans-serif;">' +
      '<thead><tr style="background:var(--bg);position:sticky;top:0;">' +
      '<th style="padding:5px 10px;font-size:9px;color:var(--text-muted);text-align:left;font-weight:700;text-transform:uppercase;">Time</th>' +
      '<th style="padding:5px 10px;font-size:9px;color:var(--text-muted);text-align:right;font-weight:700;text-transform:uppercase;">' + (awayName || 'Away') + '</th>' +
      '<th style="padding:5px 10px;font-size:9px;color:var(--text-muted);text-align:right;font-weight:700;text-transform:uppercase;">' + (homeName || 'Home') + '</th>' +
      '<th style="padding:5px 10px;font-size:9px;color:var(--text-muted);font-weight:700;text-transform:uppercase;">Book</th>' +
      '</tr></thead><tbody>' + rows + '</tbody></table></div>';
  }

  // Toggle odds history panel
  window.toggleOddsHistory = async function(btn, matchKey, awayName, homeName) {
    var card = btn.closest('.game-card') || btn.parentElement.parentElement;
    var existing = card.querySelector('.odds-history-panel');
    if (existing) {
      existing.remove();
      btn.textContent = '12h Odds';
      btn.style.background = 'var(--accent-light)';
      return;
    }

    btn.textContent = 'Loading...';
    btn.style.background = 'var(--purple-light)';

    var points = await fetchOddsHistory(matchKey, awayName, homeName);

    var panel = document.createElement('div');
    panel.className = 'odds-history-panel';
    panel.style.cssText = 'margin-top:8px;border:1px solid var(--border);border-radius:10px;background:var(--card-bg);overflow:hidden;box-shadow:var(--shadow-sm);';
    panel.innerHTML = '<div style="padding:10px 14px;background:var(--bg);border-bottom:1px solid var(--border);font-size:12px;font-weight:700;color:var(--text-primary);display:flex;align-items:center;gap:6px;">ML Movement (12h, hourly) <span style="font-size:10px;color:var(--text-muted);font-weight:500;">via Historical API</span></div>' +
      buildOddsHistoryHTML(points, awayName, homeName);
    card.appendChild(panel);
    btn.textContent = 'Hide';
  };

  // Inject buttons into game cards
  function injectOddsButtons() {
    var cards = document.querySelectorAll('.game-card');
    cards.forEach(function(card) {
      if (card.querySelector('.odds-hist-btn')) return;
      var teams = card.querySelectorAll('.team-name');
      var teamTexts = [];
      teams.forEach(function(t) { if (t.textContent.trim()) teamTexts.push(t.textContent.trim()); });
      var awayName = teamTexts[0] || 'Away';
      var homeName = teamTexts[1] || teamTexts[teamTexts.length-1] || 'Home';
      var matchKey = '';
      if (typeof oddsCache !== 'undefined') {
        var cacheKeys = Object.keys(oddsCache);
        for (var i = 0; i < cacheKeys.length; i++) {
          var k = cacheKeys[i];
          for (var j = 0; j < teamTexts.length; j++) {
            if (k.toLowerCase().indexOf(teamTexts[j].toLowerCase().substring(0,4)) > -1) {
              matchKey = k; break;
            }
          }
          if (matchKey) break;
        }
      }
      if (!matchKey) matchKey = awayName + ' vs ' + homeName;

      var wrap = document.createElement('div');
      wrap.className = 'odds-hist-btn';
      wrap.style.cssText = 'text-align:center;padding:4px 0;';
      var btn = document.createElement('button');
      btn.textContent = '12h Odds';
      btn.style.cssText = 'padding:5px 14px;font-size:11px;font-weight:700;border:1px solid var(--border);color:var(--text-primary);background:var(--accent-light);border-radius:20px;cursor:pointer;transition:all 0.2s;';
      btn.onmouseover = function() { this.style.background='var(--purple-light)'; };
      btn.onmouseout = function() { if(this.textContent!=='Hide') this.style.background='var(--accent-light)'; };
      btn.onclick = function() { toggleOddsHistory(this, matchKey, awayName, homeName); };
      wrap.appendChild(btn);
      var cardBody = card.querySelector('.game-card-body') || card;
      cardBody.appendChild(wrap);
    });
  }

  var container = document.getElementById('edgeThesisContainer');
  if (container) {
    new MutationObserver(function() { setTimeout(injectOddsButtons, 500); })
      .observe(container, { childList: true, subtree: true });
  }
  setInterval(injectOddsButtons, 5000);
  setTimeout(injectOddsButtons, 2000);
})();
</script>
<div id="content-history" class="tab-content">
  <div class="card">
    <div class="card-header"><span>Signal History Dashboard</span>
      <button class="btn btn-sm" onclick="document.getElementById('historyContent').innerHTML=renderSignalHistory()">Refresh</button>
      <button class="btn btn-sm btn-red" onclick="if(confirm('Clear all signal history?')){state.signalHistory=[];localStorage.removeItem('signalHistory');document.getElementById('historyContent').innerHTML=renderSignalHistory();}">Clear</button>
    </div>
    <div class="card-body" id="historyContent">
      <div style="text-align:center;padding:20px;color:var(--text-muted);">Click Refresh to load signal history.</div>
    </div>
  </div>
</div>


<div id="content-tracker" class="tab-content">
  <div style="margin-bottom:16px">
    <h2 style="font-size:20px;font-weight:800;margin-bottom:4px">Signal Backtest Tracker</h2>
    <p style="font-size:12px;color:var(--text-muted);line-height:1.5">Auto-tracks every signalLevel=2 recommendation. Results resolved from ESPN final scores. Kelly-sized bets on $20K bankroll with estimated 5-12% edge.</p>
  </div>
  <div style="display:flex;gap:8px;margin-bottom:16px;align-items:center;flex-wrap:wrap">
    <button class="btn btn-sm" style="background:var(--accent);color:white;border:none;padding:8px 16px;border-radius:20px;font-weight:600;cursor:pointer;font-size:12px;" onclick="resolveSignalTracker()">Check Results</button>
    <button class="btn btn-sm" style="background:var(--card-bg);color:var(--text-secondary);border:1px solid var(--border);padding:8px 16px;border-radius:20px;font-weight:600;cursor:pointer;font-size:12px;" onclick="exportSignalTracker()">Export CSV</button>
    <button class="btn btn-sm" style="background:var(--card-bg);color:var(--red);border:1px solid var(--border);padding:8px 16px;border-radius:20px;font-weight:600;cursor:pointer;font-size:12px;" onclick="if(confirm('Clear all backtest tracker data? This cannot be undone.')){state.signalTracker=[];localStorage.removeItem('signalTracker');renderSignalTracker();}">Clear</button>
    <span style="margin-left:auto;font-size:10px;color:var(--text-muted)">Signals auto-tracked when combined signals fire during live games</span>
  </div>
  <div id="signal-tracker-content">
    <div style="text-align:center;padding:40px 20px;color:var(--text-muted);font-size:13px">Loading...</div>
  </div>
</div>

<div id="content-guide" class="tab-content">
<div class="guide-section">
<h2 style="font-size:22px;font-weight:800;margin-bottom:4px;letter-spacing:-0.5px;">Signal Guide</h2>

<!-- ===== QUICK START - HOW TO USE ===== -->
<div style="background:var(--accent-light);border:1px solid var(--accent);border-radius:var(--radius);padding:24px;margin:16px 0 24px;">
<h3 style="font-size:16px;font-weight:800;margin-bottom:12px;letter-spacing:-0.2px;">How This Works (Quick Start)</h3>
<div style="font-size:13px;line-height:1.7;color:var(--text-primary);">
<p style="margin-bottom:10px;"><strong>The idea is simple:</strong> Sometimes a team is winning because of things that won't last  like making every 3-pointer, or getting way more free throws than normal. When that happens, the live betting odds are wrong because they think the score is "real." We catch that.</p>
<p style="margin-bottom:14px;"><strong>How to use it:</strong></p>
<div style="display:grid;grid-template-columns:1fr;gap:10px;">
<div style="background:var(--card-bg);border-radius:var(--radius-sm);padding:12px 14px;border-left:3px solid var(--accent);">
<strong style="font-size:12px;">Step 1:</strong> <span style="font-size:13px;">Hit <strong>Start</strong> to auto-refresh. The dashboard watches every live game.</span>
</div>
<div style="background:var(--card-bg);border-radius:var(--radius-sm);padding:12px 14px;border-left:3px solid var(--orange);">
<strong style="font-size:12px;">Step 2:</strong> <span style="font-size:13px;">When a signal fires, the chip turns on and shows a number. <strong>Click it</strong> to see which game, then <strong>click the game</strong> to jump to it.</span>
</div>
<div style="background:var(--card-bg);border-radius:var(--radius-sm);padding:12px 14px;border-left:3px solid var(--green);">
<strong style="font-size:12px;">Step 3:</strong> <span style="font-size:13px;">The game card tells you <strong>who to bet on</strong> and <strong>why</strong>. Green = bet this team's moneyline. Purple = bet Over or Under.</span>
</div>
</div>
</div>
</div>

<!-- ===== WHAT EACH SIGNAL MEANS (PLAIN ENGLISH) ===== -->
<div style="background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);padding:20px;margin-bottom:24px;">
<h3 style="font-size:15px;font-weight:800;margin-bottom:14px;letter-spacing:-0.2px;">What Each Signal Means</h3>
<table style="width:100%;font-size:12px;border-collapse:collapse;">
<thead><tr style="border-bottom:2px solid var(--border);text-align:left;">
<th style="padding:8px 6px;font-weight:700;color:var(--text-muted);font-size:10px;text-transform:uppercase;">Signal</th>
<th style="padding:8px 6px;font-weight:700;color:var(--text-muted);font-size:10px;text-transform:uppercase;">In Plain English</th>
<th style="padding:8px 6px;font-weight:700;color:var(--text-muted);font-size:10px;text-transform:uppercase;">What to Bet</th>
</tr></thead>
<tbody>
<tr style="border-bottom:1px solid var(--border-light);">
<td style="padding:10px 6px;"><span class="signal-badge badge-3pt" style="font-size:10px;">3PT FRAGILE</span></td>
<td id="guide-fragile-desc" style="padding:10px 6px;color:var(--text-secondary);line-height:1.5;">A team is <strong>way too hot from 3</strong> (50%+) and their entire lead depends on it. That shooting will cool off  lead will shrink.</td>
<td style="padding:10px 6px;font-weight:700;color:var(--green);">Bet the <strong>other team's moneyline</strong> (the one behind). Their opponent's lead is fake.</td>
</tr>
<tr style="border-bottom:1px solid var(--border-light);">
<td style="padding:10px 6px;"><span class="signal-badge badge-star" style="font-size:10px;">STAR COIL</span></td>
<td id="guide-star-desc" style="padding:10px 6px;color:var(--text-secondary);line-height:1.5;">A star player (21+ PPG) is cold (&lt;65% pace) AND the game is close (within 15pts) in Q2-Q3. <strong>Compressed spring</strong>  breakout incoming.</td>
<td style="padding:10px 6px;font-weight:700;color:var(--green);">Bet the <strong>star's team moneyline</strong>. Star is cold, game is close, timing is right  the market hasn't priced in the breakout.</td>
</tr>

<tr style="border-bottom:1px solid var(--border-light);">
<td style="padding:10px 6px;"><span class="signal-badge badge-combined" style="font-size:10px;">COMBINED</span></td>
<td style="padding:10px 6px;color:var(--text-secondary);line-height:1.5;"><strong>Both 3PT Fragile + Star Coil firing on the same game.</strong> Multiple unsustainable conditions at once  strongest edge.</td>
<td style="padding:10px 6px;font-weight:700;color:var(--green);">Bet the team that benefits from regression on both fronts. <strong>Highest confidence.</strong></td>
</tr>
</tbody>
</table>
</div>

<div id="nba-guide">
<p class="guide-intro" style="margin-bottom:12px;"><strong>Core thesis:</strong> The current score was built on something unsustainable, so the live odds are mispriced. We bet on regression.</p>
<div class="guide-grid">
<div class="guide-card"><h3><span class="signal-badge badge-3pt">3PT FRAGILE</span> 3PT Fragile Lead</h3><p class="edge-label">Team is winning because of hot 3PT shooting  and the lead depends on it</p><p>Fires when ALL are true: (1) a team is shooting 50%+ from 3 on 12+ attempts, (2) their lead is built on that 3PT shooting while the opponent scores from paint, AND (3) the lead is 3-15 points. The sweet spot where 3PT cooling flips the game.</p><p><strong> Opponent Engine Check:</strong> The system also checks if the trailing team has a real scoring engine (non-3PT points per minute &gt; 1.3). If the trailing team's offense is broken  they can't score from paint, FT, or mid-range  then even if 3s regress, they have no engine to capitalize. Signal is downgraded to  (weaker). <em>Regression only matters if the other team can take advantage of it.</em></p><div class="threshold">Trigger: 50%+ on 12+ att AND lead 42%+ from 3PT AND opponent 58%+ non-3PT AND lead 3-15 pts.<br>Weakened: If trailing team non-3PT PPM &lt; 1.3 (broken offense).</div></div>
<div class="guide-card"><h3><span class="signal-badge badge-star">STAR</span> Star Coil</h3><p class="edge-label">Star is cold + game is close + supporting cast is holding = maximum edge</p><p>When a 21+ PPG star is at &lt;65% of expected pace AND the game is within 15 points during Q2-Q3.</p><p><strong> Supporting Cast Analysis:</strong> The system compares the cast's output (team score minus star's points) directly to the opponent's total score  no season averages, pure live data. If the cast is within 8pts of the opponent, the team is competitive WITHOUT the star. When the star regresses upward, it's regression on top of an already-strong team. Also checks if the star's "missing points" exceed the cast gap  if so, regression alone flips the lead.</p><p><strong>4 tiers:</strong>  Cast Leading (cast ahead of opponent),  Cast Close (within 8),  Cast Behind (8-15),  Cast Broken (&gt;15 behind). Also  Damage Locked if deficit is stable over 3+ min.</p><div class="threshold">Trigger: Star &lt;65% pace + margin &le;15 + Q2-Q3.<br>Tiers: Elite (cast gap -8), Standard (-8 to -15), Weak (&lt;-15), Locked (deficit stable 3+min).</div></div>

<div class="guide-card"><h3><span class="signal-badge badge-combined">COMBINED</span> Combined Edge</h3><p class="edge-label">Both signals firing on the same game = strongest edge, most confidence</p><p>When 3PT Fragile AND Star Coil fire on the same game, the live odds are wrong from two independent angles. Each signal catches something different  together, the mispricing is larger.</p><div class="threshold">Trigger: Both 3PT Fragile + Star Coil on the same game.</div><p style="margin-top:8px;"><strong>Combined Boost:</strong> When two independent edges converge, each individual signal uses <em>relaxed</em> thresholds. Signals that wouldn't fire solo can still trigger a Combined Edge together:</p><ul style="font-size:12px;margin:4px 0 0 16px;line-height:1.6;"><li><strong>3PT Soft:</strong> 45%/10att (or 50%/8att), fragile 38%, margin 2-18pts, no engine check</li><li><strong>Star Soft:</strong> &lt;75% pace, Q1-Q3 (not just Q2-Q3), margin 18pts</li></ul><p style="font-size:12px;margin-top:4px;color:var(--text-muted);">These relaxed signals never fire individually  only when both converge on the same game.</p></div>

</div></div>
<div id="theory-panel" class="theory-panel">
  <h4>How This Dashboard Works</h4>
  <p>Every signal in this dashboard shares one thesis: <strong>the current score was built on something unsustainable, so the live moneyline is mispriced.</strong> Live odds react to the scoreboard, but they fail to distinguish between sustainable scoring (paint, mid-range) and unsustainable scoring (hot 3PT streaks, star underperformance). The 2-signal system (3PT Fragile + Star Coil) plus Combined Edge identifies when these unsustainable conditions exist  that is the edge.</p>
  <hr class="signal-divider">
  <h4>1. 3PT Fragile Lead (Merged Signal)</h4>
  <p><strong>What it detects:</strong> This is the most selective signal  it requires BOTH of two conditions to be true simultaneously:</p>
  <p><strong>Condition 1  Hot 3PT Shooting:</strong> A team shooting 50%+ from three-point range on 12+ attempts (or 55%+ on 8+). The NBA league average is ~36.5%. This rate is 2+ standard deviations above the mean and will regress.</p>
  <p><strong>Condition 2  Fragile Lead Composition:</strong> The same team's lead is 42%+ dependent on 3PT scoring AND the trailing team scores from the paint (58%+ non-3PT). The lead is not just hot  it's structurally dependent on that hot shooting.</p>
  <p><strong>Why both conditions matter:</strong> Hot 3PT shooting alone doesn't mean the lead is fragile  the team might also be scoring from the paint. And a fragile lead composition alone doesn't mean the shooting will regress  the percentage might be within normal range. Only when BOTH are true is the edge genuine: the shooting WILL cool off AND the lead DEPENDS on it.</p>
  <div class="edge-box">
    <p><strong>Trigger:</strong> 3PT% &ge;50% on &ge;12 attempts (or 55%+ on 8+) AND lead composition &ge;42% from 3PT AND opponent &ge;58% non-3PT AND &ge;20 total points AND lead between 3-15 pts. All conditions must be met for Level 2 (strong) signal. The 3-15pt margin filter ensures the lead is real but erasable  not a blowout, not a dead heat.</p>
  </div>
  <p><strong>When only one condition is met:</strong> If only the 3PT shooting is hot (no fragile lead) or only the lead is fragile (shooting not extreme), the system shows a Level 1 warning but does NOT fire the full signal.</p>
  <p><strong> Opponent Engine Check (NEW):</strong> Even when 3PT Fragile fires, the system checks: can the trailing team actually score without relying on the opponent's regression? It computes the trailing team's non-3PT points per minute (paint + FT + mid-range). If below 1.3 PPM, their offense is fundamentally broken  even if the leading team's 3s cool down, the trailing team has no engine to capitalize. The signal is downgraded to  (weaker). <strong>Regression only matters if the other team can take advantage of it.</strong></p>
  <hr class="signal-divider">
  <h4>2. Star Coil (with Supporting Cast + Damage Locked)</h4>
  <p><strong>What it detects:</strong> A franchise-caliber player performing well below their expected scoring pace (&lt;65%) during Q2-Q3 AND the game is competitive (within 15 points).</p>
  <p><strong> Supporting Cast Analysis:</strong> The core edge strengthener. Instead of comparing to season averages, the system uses <strong>pure live data</strong>: it takes the team's score, subtracts the star's points, and compares that directly to the opponent's total score. This "cast gap" tells you how well the teammates are doing against THIS specific opponent in THIS game.</p>
  <ul style="margin:8px 0;padding-left:20px;line-height:1.5;">
    <li><strong> Cast Leading</strong> (gap  0): Teammates are matching/beating the opponent without the star. Strongest possible edge.</li>
    <li><strong> Cast Close</strong> (gap -1 to -8): Cast is within striking distance. Star regression makes it a real fight.</li>
    <li><strong> Cast Behind</strong> (gap -8 to -15): Cast is behind but game is in range. Standard edge.</li>
    <li><strong> Cast Broken</strong> (gap &lt; -15): Whole team is struggling. Star alone won't fix it. Signal weakened.</li>
  </ul>
  <p><strong>Regression Flips Check:</strong> The system also calculates how many points the star is "missing" (expected minus actual). If the missing points exceed the cast gap, regression alone flips the lead  this is the highest-confidence scenario.</p>
  <p><strong> Damage Locked:</strong> Tracks score over 3+ minutes of real game action. If the deficit is stable/growing with scoring activity confirmed (not a timeout), the damage is baked in. Bet direction flips.</p>
  <div class="edge-box green">
    <p><strong>Trigger:</strong> Star &lt;65% pace + Q2/Q3 + margin &le;15pts.</p>
    <p style="margin-top:6px"><strong>Tiers:</strong> Elite (cast gap -8, 1.5 weight), Standard (-8 to -15, 1 weight), Weak (&lt;-15, 0 weight), Locked (deficit baked in, reverse bet).</p>
  </div>
  <hr class="signal-divider">
  <h4>3. Combined Edge</h4>
  <p><strong>What it detects:</strong> When both 3PT Fragile and Star Coil fire on the same game. These two signals measure genuinely different dimensions of unsustainability  no overlap or double-counting.</p>
  <div class="edge-box purple">
    <p><strong>How it works:</strong> The system first checks for strict Level 2 signals. If both fire, thesis elevates to signalLevel = 2 (strong combined). If only one fires (or neither), the system runs a <strong>Combined Boost</strong> pass with relaxed thresholds  when two independent edges converge, each doesn't need to be as strict. Soft signals never fire solo.</p>
    <p style="margin-top:6px"><strong>3PT Fragile + Star Coil:</strong> Opponent's lead is built on hot 3PT shooting AND their star is cold in a close game. When the star heats up and 3PT% drops, momentum shifts hard. This is the maximum edge scenario.</p>
  </div>
  <hr class="signal-divider">
  <h4>Bet Side Logic (ML Signals)</h4>
  <p>The system scores each side's "unsustainability count" with two key modifiers:</p>
  <ul style="margin:8px 0;padding-left:20px;line-height:1.6;">
    <li><strong>3PT Fragile + Opponent Engine:</strong> If the trailing team can't score (non-3PT PPM &lt; 1.3), the fade signal is weakened  regression won't help a broken offense.</li>
    <li><strong>Star Coil + Damage Locked:</strong> If the star's team deficit is stable/growing over 3+ checks, the bet flips  fade the star's team instead of betting on them.</li>
  </ul>
  <p>The side with more fade reasons gets faded; the system recommends the opposite side  the team whose advantages are real, sustainable, and undervalued.</p>
  <hr class="signal-divider">
  <h4>Data Sources &amp; Limitations</h4>
  <p>All data comes from ESPN's live scoreboard API (scores, period/clock, team stats, leader boards) and ESPN's summary endpoint (FTA, box score details). Refreshes on configurable interval (default 30s).</p>
  <p><strong>Not captured:</strong> Individual player foul counts, play-by-play data, lineup changes, injury updates, referee tendencies, pace-of-play, and real-time odds. The system focuses on what IS measurable and predictive: shooting rates, scoring composition, free throw attempts, and star production.</p>
  <p><strong>Important:</strong> No signal guarantees an outcome. These are probabilistic edges based on mean reversion and market inefficiency. Responsible bankroll management is essential.</p>
</div>

</body>
</html>

