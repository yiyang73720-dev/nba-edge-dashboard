<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Alpha Hunter</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 40'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2300d4aa'/%3E%3Cstop offset='100%25' stop-color='%237c3aed'/%3E%3C/linearGradient%3E%3C/defs%3E%3Ccircle cx='20' cy='20' r='14' fill='none' stroke='url(%23g)' stroke-width='2.5'/%3E%3Ccircle cx='20' cy='20' r='3' fill='%2300d4aa'/%3E%3Cline x1='20' y1='2' x2='20' y2='10' stroke='url(%23g)' stroke-width='2' stroke-linecap='round'/%3E%3Cline x1='20' y1='30' x2='20' y2='38' stroke='url(%23g)' stroke-width='2' stroke-linecap='round'/%3E%3Cline x1='2' y1='20' x2='10' y2='20' stroke='url(%23g)' stroke-width='2' stroke-linecap='round'/%3E%3Cline x1='30' y1='20' x2='38' y2='20' stroke='url(%23g)' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E">
<style>

    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap');

    /* ===== PREMIUM WHITE THEME ===== */
    :root {
      --white: #ffffff;
      --bg: #f8f9fb;
      --card-bg: #ffffff;
      --border: #e5e7eb;
      --border-light: #f1f3f5;
      --text-primary: #1a1a2e;
      --text-secondary: #6b7280;
      --text-muted: #9ca3af;
      --accent: #00d4aa;
      --accent-light: #ecfdf8;
      --accent-hover: #00b896;
      --green: #10b981;
      --green-light: #ecfdf5;
      --red: #ef4444;
      --red-light: #fef2f2;
      --orange: #f59e0b;
      --orange-light: #fffbeb;
      --purple: #7c3aed;
      --purple-light: #f5f3ff;
      --shadow-xs: 0 1px 2px rgba(0,0,0,0.03);
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.04), 0 1px 2px rgba(0,0,0,0.02);
      --shadow-md: 0 4px 12px rgba(0,0,0,0.05), 0 1px 3px rgba(0,0,0,0.03);
      --shadow-lg: 0 8px 30px rgba(0,0,0,0.07), 0 2px 8px rgba(0,0,0,0.04);
      --radius: 12px;
      --radius-sm: 8px;
      --radius-lg: 16px;
      --radius-xl: 20px;
    }

    /* ===== DARK MODE ===== */
    [data-theme="dark"] {
      --white: #1a1a2e; --bg: #0f0f1a; --card-bg: #1a1a2e; --border: #2d2d44; --border-light: #252540;
      --text-primary: #e2e8f0; --text-secondary: #94a3b8; --text-muted: #64748b;
      --accent: #00d4aa; --accent-light: #0d3d33; --accent-hover: #00e8bb;
      --green: #10b981; --green-light: #0d3d33;
      --red: #ef4444; --red-light: #3b1111;
      --orange: #f59e0b; --orange-light: #3b2e0a;
      --purple: #8b5cf6; --purple-light: #2e1f5e;
      --shadow-xs: 0 1px 2px rgba(0,0,0,0.2);
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.3); --shadow-md: 0 4px 12px rgba(0,0,0,0.35); --shadow-lg: 0 8px 30px rgba(0,0,0,0.45);
    }
    [data-theme="dark"] .header { background: #1a1a2e; border-bottom-color: #2d2d44; }
    [data-theme="dark"] .game-card-header { background: #151525; }
    [data-theme="dark"] .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
    [data-theme="dark"] input, [data-theme="dark"] select, [data-theme="dark"] textarea { background: #252540; color: #e2e8f0; border-color: #2d2d44; }
    [data-theme="dark"] .modal { background: #1a1a2e; }
    [data-theme="dark"] .edge-box { background: #151525; border-color: #2d2d44; }
    [data-theme="dark"] .signal-strip { background: #1a1a2e; border-color: #2d2d44; }
    [data-theme="dark"] .tab-bar { background: #1a1a2e; border-bottom-color: #2d2d44; }
    [data-theme="dark"] .odds-row { background: linear-gradient(135deg,#1a1a2e,#16213e); }
    [data-theme="dark"] .header-controls { background: rgba(255,255,255,0.04); border-color: #2d2d44; }
    [data-theme="dark"] .stat-card { border-color: #2d2d44; }
    [data-theme="dark"] .stat-card:hover { border-color: var(--accent); }

    /* ===== RESET & BASE ===== */
    .team-3pt-avg { font-size: 9px; font-weight: 600; color: var(--accent); opacity: 0.8; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text-primary);
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      letter-spacing: -0.01em;
    }

    /* ===== HEADER ===== */
    .header {
      background: var(--white);
      border-bottom: 1px solid var(--border);
      padding: 16px 32px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 200;
      min-height: 64px;
    }
    .header h1, .header .title { font-size: 18px; font-weight: 800; color: var(--accent); letter-spacing: -0.3px; }
    .header .subtitle, .header p, .header small { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
    .logo-wrap { display: flex; align-items: center; gap: 14px; }
    .logo-icon { width: 36px; height: 36px; flex-shrink: 0; filter: drop-shadow(0 0 8px rgba(0,212,170,0.3)); }
    .logo-icon .scope-ring { fill: none; stroke: url(#logoGrad); stroke-width: 2; }
    .logo-icon .scope-cross { stroke: url(#logoGrad); stroke-width: 1.5; stroke-linecap: round; }
    .logo-icon .scope-dot { fill: var(--accent); }
    .logo-icon .scope-pulse { fill: var(--accent); opacity: 0; animation: logoPulse 2.5s ease-in-out infinite; }
    @keyframes logoPulse { 0%,100%{ opacity:0; r:2; } 50%{ opacity:0.4; r:7; } }
    .logo-text { display: flex; flex-direction: column; line-height: 1.15; }
    .logo-text .logo-main { font-size: 19px; font-weight: 900; letter-spacing: 2px; background: linear-gradient(135deg, #00d4aa 0%, #00b4d8 50%, #7c3aed 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .logo-text .logo-sub { font-size: 9px; font-weight: 600; letter-spacing: 3.5px; color: var(--text-muted); text-transform: uppercase; margin-top: 2px; }
    [data-theme="dark"] .logo-icon { filter: drop-shadow(0 0 10px rgba(0,212,170,0.5)); }
    [data-theme="dark"] .logo-text .logo-main { background: linear-gradient(135deg, #00ffc8 0%, #00d4ff 50%, #a78bfa 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }

    /* Header controls group */
    .header-right, .header-actions, .header .actions { display: flex; gap: 8px; align-items: center; }
    .header-controls {
      display: flex;
      gap: 6px;
      align-items: center;
      background: var(--bg);
      border: 1px solid var(--border-light);
      border-radius: 28px;
      padding: 4px 6px;
    }

    /* ===== BUTTONS ===== */
    button, .btn {
      font-family: 'Inter', sans-serif;
      font-size: 13px;
      font-weight: 600;
      border: none;
      border-radius: var(--radius-sm);
      padding: 8px 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      letter-spacing: -0.01em;
    }
    button:hover { transform: translateY(-1px); box-shadow: var(--shadow-md); }
    button:active { transform: translateY(0); }
    .btn-primary, button[style*="background: #00d4aa"], button[style*="background:#00d4aa"] { background: var(--accent) !important; color: white !important; }
    .btn-danger, button[style*="background: #ef4444"] { background: var(--red) !important; color: white !important; }
    .espn-btn, button[onclick*="espn"] { background: var(--white); color: var(--text-secondary); border: 1px solid var(--border); font-size: 12px; padding: 6px 14px; border-radius: var(--radius-sm); }
    .espn-btn:hover, button[onclick*="espn"]:hover { background: var(--bg); border-color: var(--accent); color: var(--accent); }
    #soundToggle { background: var(--accent) !important; color: white !important; border-radius: 24px !important; padding: 6px 14px !important; font-size: 11px !important; font-weight: 600 !important; }
    #demoToggle { background: var(--accent) !important; color: white !important; border-radius: 24px !important; padding: 6px 14px !important; font-size: 11px !important; font-weight: 600 !important; }
    #modeToggleBtn { border-radius: 24px !important; font-size: 12px !important; font-weight: 700 !important; padding: 7px 18px !important; letter-spacing: 0.5px !important; }
    #darkModeToggle { background: var(--bg) !important; color: var(--text-secondary) !important; border: 1px solid var(--border) !important; border-radius: 24px !important; padding: 6px 14px !important; font-size: 11px !important; font-weight: 600 !important; }
    #darkModeToggle:hover { background: var(--border-light) !important; color: var(--text-primary) !important; }

    /* Status indicators */
    .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
    .status-dot.green, .status-dot.live { background: var(--green); box-shadow: 0 0 6px rgba(16,185,129,0.4); }
    .status-dot.red, .status-dot.off { background: var(--red); }

    /* ===== TAB BAR ===== */
    .tab-bar {
      display: flex;
      background: var(--white);
      border-bottom: 1px solid var(--border);
      padding: 0 32px;
      position: sticky;
      top: 64px;
      z-index: 100;
      gap: 0;
      overflow-x: auto;
      scrollbar-width: none;
    }
    .tab-bar::-webkit-scrollbar { display: none; }
    .tab {
      padding: 14px 22px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      color: var(--text-muted);
      border-bottom: 2px solid transparent;
      transition: all 0.2s ease;
      white-space: nowrap;
      position: relative;
    }
    .tab:hover { color: var(--text-primary); }
    .tab.active {
      color: var(--accent);
      font-weight: 700;
      border-bottom: 2.5px solid var(--accent);
      margin-bottom: -1px;
    }
    .tab .badge {
      font-size: 10px;
      padding: 1px 7px;
      border-radius: 10px;
      margin-left: 4px;
      vertical-align: middle;
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* ===== CONTENT AREA ===== */
    .content, .main-content, .tab-content { padding: 28px 32px; max-width: 1440px; margin: 0 auto; }

    /* ===== TYPOGRAPHY ===== */
    h2, .section-title { font-size: 20px; font-weight: 800; color: var(--text-primary); letter-spacing: -0.4px; margin-bottom: 4px; }
    h3, h4 { font-size: 15px; font-weight: 700; color: var(--text-primary); letter-spacing: -0.2px; }

    /* ===== STATS ROW (KPI TILES) ===== */
    .stats-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px; margin-bottom: 28px; }
    .stat-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px 18px;
      text-align: center;
      box-shadow: var(--shadow-xs);
      transition: all 0.25s ease;
      position: relative;
      overflow: hidden;
    }
    .stat-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--accent);
      opacity: 0;
      transition: opacity 0.25s ease;
    }
    .stat-card:hover { box-shadow: var(--shadow-md); transform: translateY(-2px); border-color: var(--accent); }
    .stat-card:hover::before { opacity: 1; }
    .stat-label {
      font-size: 10px;
      font-weight: 700;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 1.2px;
      margin-bottom: 8px;
    }
    .stat-value { font-size: 30px; font-weight: 800; color: var(--text-primary); letter-spacing: -1.5px; line-height: 1.1; }
    .stat-value.red { color: var(--red); }
    .stat-value.orange { color: var(--orange); }
    .stat-value.green { color: var(--green); }
    .stat-value.purple { color: var(--purple); }

    /* ===== SIGNAL STRIP ===== */
    .signal-strip {
      display: flex;
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: visible;
      background: var(--card-bg);
      box-shadow: var(--shadow-xs);
      margin-bottom: 24px;
    }
    .signal-chip {
      flex: 1;
      padding: 14px 8px;
      text-align: center;
      border-right: 1px solid var(--border-light);
      transition: all 0.2s ease;
      cursor: default;
      position: relative;
    }
    .signal-chip:last-child { border-right: none; }
    .signal-chip:hover { background: var(--bg); }
    .signal-chip .chip-value { font-size: 22px; font-weight: 800; color: var(--text-primary); letter-spacing: -0.5px; line-height: 1.2; }
    .signal-chip .chip-label { font-size: 9px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-top: 4px; }
    .signal-chip .chip-value.orange { color: var(--orange); }
    .signal-chip .chip-value.teal { color: var(--green); }
    .signal-chip .chip-value.red { color: var(--red); }
    .signal-chip .chip-value.purple { color: var(--purple); }
    .signal-chip .chip-value.green { color: var(--green); }
    .signal-chip .chip-label.orange { color: var(--orange); }
    .signal-chip .chip-label.teal { color: var(--green); }
    .signal-chip .chip-label.red { color: var(--red); }
    .signal-chip .chip-label.purple { color: var(--purple); }
    .signal-chip .chip-label.green { color: var(--green); }
    .signal-chip .chip-desc { display:none; position:absolute; bottom:100%; left:50%; transform:translateX(-50%); background:#1e293b; color:#fff; font-size:10px; padding:6px 10px; border-radius:6px; white-space:nowrap; z-index:100; pointer-events:none; margin-bottom:6px; box-shadow:0 4px 12px rgba(0,0,0,.15); }
    .signal-chip:hover .chip-desc { display:block; }
    .signal-chip-clickable { cursor: pointer; transition: all 0.2s ease; border-radius: 0; }
    .signal-chip-clickable:hover { background: var(--accent-light); }
    .signal-chip-clickable:active { transform: scale(0.98); }

    /* Chip detail dropdown */
    .chip-detail-panel { display:none; position:absolute; top:100%; left:50%; transform:translateX(-50%); background:var(--card-bg); border:1px solid var(--border); border-radius:var(--radius); box-shadow:var(--shadow-lg); z-index:150; min-width:300px; max-width:380px; padding:0; margin-top:8px; text-align:left; overflow:hidden; animation:slideUp 0.2s ease; }
    .chip-detail-panel.active { display:block; }
    .chip-detail-panel::before { content:''; position:absolute; top:-6px; left:50%; transform:translateX(-50%); border-left:6px solid transparent; border-right:6px solid transparent; border-bottom:6px solid var(--border); }
    .chip-detail-panel::after { content:''; position:absolute; top:-5px; left:50%; transform:translateX(-50%); border-left:5px solid transparent; border-right:5px solid transparent; border-bottom:5px solid var(--card-bg); }
    .chip-detail-header { padding:10px 14px; background:var(--bg); border-bottom:1px solid var(--border-light); font-size:11px; font-weight:700; color:var(--text-muted); text-transform:uppercase; letter-spacing:0.5px; }
    .chip-detail-item { padding:10px 14px; border-bottom:1px solid var(--border-light); font-size:12px; }
    .chip-detail-item:last-child { border-bottom:none; }
    .chip-detail-clickable { cursor:pointer; transition:background 0.15s ease; }
    .chip-detail-clickable:hover { background:var(--accent-light); }
    .chip-detail-game { font-weight:700; color:var(--text-primary); font-size:12px; }
    .chip-detail-score { font-size:11px; color:var(--text-muted); margin-top:2px; }
    .chip-detail-sig { font-size:11px; color:var(--text-secondary); margin-top:4px; line-height:1.5; }
    .chip-detail-empty { padding:16px; text-align:center; font-size:11px; color:var(--text-muted); }

    @keyframes signalFlash { 0%{box-shadow:0 0 0 0 rgba(0,212,170,0.5);} 30%{box-shadow:0 0 16px 4px rgba(0,212,170,0.3);} 100%{box-shadow:var(--shadow-sm);} }
    .signal-highlight-flash { animation:signalFlash 2.5s ease; border-color:var(--accent) !important; }

    /* ===== DIVIDERS ===== */
    .section-divider { height: 1px; background: var(--border-light); margin: 20px 0; }

    /* ===== EDGE THESIS ===== */
    .edge-thesis-header { display: flex; align-items: center; gap: 12px; margin-bottom: 8px; }
    .edge-thesis-header h2 { font-size: 13px; font-weight: 700; color: var(--text-primary); letter-spacing: 1px; text-transform: uppercase; margin: 0; }
    .edge-count-badge, .thesis-count { background: var(--accent); color: white; font-size: 11px; font-weight: 700; padding: 3px 12px; border-radius: 20px; min-width: 24px; text-align: center; }

    /* ===== AUTO REFRESH BAR ===== */
    .auto-refresh-bar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 0;
      font-size: 12px;
      color: var(--text-secondary);
      flex-wrap: wrap;
    }
    .refresh-pill { padding: 5px 14px; font-size: 11px; font-weight: 700; border-radius: 20px; border: 1px solid var(--accent); color: var(--accent); background: transparent; cursor: pointer; transition: all 0.2s; }
    .refresh-pill:hover { background: var(--accent); color: white; }
    .countdown-bar { flex: 0 0 120px; height: 3px; background: var(--border-light); border-radius: 2px; overflow: hidden; }
    .countdown-fill { height: 100%; background: var(--accent); border-radius: 2px; transition: width 1s linear; }

    /* ===== CARDS ===== */
    .card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 22px;
      box-shadow: var(--shadow-xs);
      margin-bottom: 20px;
      transition: all 0.25s ease;
    }
    .card:hover { box-shadow: var(--shadow-sm); }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 14px;
      font-weight: 700;
      font-size: 15px;
      color: var(--text-primary);
      letter-spacing: -0.2px;
    }
    .card-body { font-size: 13px; color: var(--text-secondary); line-height: 1.7; }

    /* ===== GAME CARDS ===== */
    .games-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 16px; }
    .game-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      transition: all 0.25s ease;
    }
    .game-card:hover { box-shadow: var(--shadow-md); border-color: #d1d5db; }
    .game-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 16px;
      background: var(--bg);
      border-bottom: 1px solid var(--border-light);
      font-size: 11px;
      color: var(--text-muted);
      font-weight: 600;
      letter-spacing: .3px;
    }
    .game-card-body { padding: 14px 16px; }
    .game-teams { display: flex; align-items: center; justify-content: space-between; gap: 4px; }
    .team-block { text-align: center; flex: 1; min-width: 0; }
    .team-block strong, .team-block b { display: block; font-size: 15px; font-weight: 700; color: var(--text-primary); margin-bottom: 1px; }
    .team-block small { font-size: 11px; color: var(--text-muted); }
    .team-name { font-size: 15px; font-weight: 800; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 160px; margin: 0 auto; letter-spacing: -0.3px; display: flex; align-items: center; justify-content: center; gap: 5px; }
    .team-name img { flex-shrink: 0; }
    .watch-link { display: inline-flex; align-items: center; gap: 3px; font-size: 9px; font-weight: 600; color: var(--accent); background: var(--accent-light); padding: 2px 7px; border-radius: 3px; text-decoration: none; letter-spacing: 0.3px; transition: opacity 0.15s; }
    .watch-link:hover { opacity: 0.7; }
    .game-links { display: flex; justify-content: center; gap: 6px; flex-wrap: wrap; margin-top: 4px; }
    .tp-inline { cursor: pointer; }
    .tp-inline:hover { text-decoration: underline; }
    .tp-modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,.35); z-index: 1000; justify-content: center; align-items: center; }
    .tp-modal-overlay.active { display: flex; }
    .tp-modal { background: var(--card-bg); border: 1px solid var(--border); border-radius: 12px; padding: 20px 24px; box-shadow: 0 12px 40px rgba(0,0,0,.2); min-width: 280px; max-width: 340px; animation: slideUp 0.2s ease; }
    .tp-modal-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
    .tp-modal-header h3 { font-size: 16px; font-weight: 800; margin: 0; display: flex; align-items: center; gap: 8px; }
    .tp-modal-close { background: none; border: none; font-size: 18px; cursor: pointer; color: var(--text-muted); padding: 4px 8px; border-radius: 4px; }
    .tp-modal-close:hover { background: var(--bg); }
    .tp-section { margin-bottom: 10px; }
    .tp-section-title { font-size: 9px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; padding-bottom: 4px; border-bottom: 1px solid var(--border-light); margin-bottom: 4px; }
    .tp-row { display: flex; justify-content: space-between; padding: 2px 0; font-size: 12px; }
    .tp-row .tp-label { color: var(--text-muted); }
    .tp-row .tp-val { font-weight: 700; color: var(--text-primary); }
    .team-score { font-size: 28px; font-weight: 900; color: var(--text-primary); margin-top: 4px; letter-spacing: -1px; line-height: 1; }
    .team-record { font-size: 10px; color: var(--text-muted); margin-top: 2px; }
    .team-3pt-avg { font-size: 10px; color: var(--text-muted); }
    .vs-block { padding: 0 10px; color: var(--border); font-size: 14px; font-weight: 300; display: flex; flex-direction: column; align-items: center; gap: 4px; }
    .sound-toggle { display: none!important; }
    .scenario-alert-panel { position: fixed; bottom: 0; left: 0; right: 0; z-index: 500; background: var(--white); border-top: 1px solid var(--border); box-shadow: 0 -4px 20px rgba(0,0,0,.06); padding: 14px 28px; max-height: 160px; overflow-y: auto; }

    /* ===== EMPTY STATES ===== */
    .empty-state {
      text-align: center;
      padding: 60px 24px;
      color: var(--text-muted);
      font-size: 14px;
    }
    .empty-state .icon {
      font-size: 40px;
      margin-bottom: 12px;
      opacity: 0.3;
      filter: grayscale(1);
    }
    .empty-state p { max-width: 320px; margin: 0 auto; line-height: 1.6; }

    /* ===== FORMS ===== */
    .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 16px; }

    /* ===== BADGES ===== */
    .signal-badge, .badge {
      display: inline-block;
      padding: 3px 10px;
      border-radius: 20px;
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.4px;
    }
    .signal-badge.hot, .badge.hot, .badge-hot { background: var(--red-light); color: var(--red); }
    .signal-badge.cold, .badge.cold, .badge-cold { background: var(--accent-light); color: var(--accent); }
    .signal-badge.warm, .badge.warm { background: var(--orange-light); color: var(--orange); }

    /* ===== PANELS ===== */
    .panel, .section {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 22px;
      margin-bottom: 20px;
      box-shadow: var(--shadow-xs);
    }
    .panel-header, .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding-bottom: 14px; border-bottom: 1px solid var(--border-light); }
    .grid-section-label { grid-column: 1/-1; padding: 12px 0 4px; border-top: 1px solid var(--border); margin-top: 8px; }
    .grid-section-label span { font-size: 11px; font-weight: 700; letter-spacing: 1px; text-transform: uppercase; }
    .grid-section-label:first-child { border-top: none; margin-top: 0; }

    /* ===== TABLES ===== */
    table { width: 100%; border-collapse: separate; border-spacing: 0; font-size: 13px; }
    thead th {
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      text-align: left;
      background: var(--bg);
    }
    tbody td { padding: 12px 14px; border-bottom: 1px solid var(--border-light); color: var(--text-primary); font-weight: 500; }
    tbody tr { transition: background 0.15s ease; }
    tbody tr:hover { background: var(--bg); }
    tbody tr:last-child td { border-bottom: none; }
    tbody tr:nth-child(even) { background: rgba(0,0,0,0.008); }
    [data-theme="dark"] tbody tr:nth-child(even) { background: rgba(255,255,255,0.015); }

    /* ===== 3PT & TRACKER CARDS ===== */
    .three-pt-card, .tracker-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow-xs);
    }
    .quarter-box, .qtr-box { display: inline-flex; align-items: center; justify-content: center; min-width: 36px; height: 28px; padding: 2px 8px; border-radius: var(--radius-sm); font-size: 12px; font-weight: 700; background: var(--bg); color: var(--text-secondary); border: 1px solid var(--border-light); }
    .quarter-box.hot, .qtr-box.hot { background: var(--red-light); color: var(--red); border-color: transparent; }

    /* ===== THESIS / EDGE CARDS ===== */
    .thesis-card, .edge-card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: var(--shadow-xs);
      margin-bottom: 16px;
      transition: all 0.25s ease;
    }
    .thesis-card:hover { box-shadow: var(--shadow-sm); }
    .criteria-item { display: flex; gap: 12px; padding: 12px 0; border-bottom: 1px solid var(--border-light); }
    .criteria-item:last-child { border-bottom: none; }
    .criteria-item.met { background: transparent; }
    .criteria-item.not-met { opacity: 0.4; }
    .criteria-check { font-size: 16px; flex-shrink: 0; margin-top: 2px; }
    .criteria-text { flex: 1; }
    .criteria-label { font-size: 13px; font-weight: 700; color: var(--text-primary); display: block; margin-bottom: 4px; letter-spacing: -0.1px; }
    .criteria-value {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent);
      display: inline-block;
      padding: 2px 10px;
      background: var(--accent-light);
      border-radius: 20px;
      margin-bottom: 6px;
    }
    .criteria-value.warn { color: var(--orange); background: var(--orange-light); }
    .criteria-value.neg { color: var(--text-muted); background: var(--bg); }
    .criteria-detail { font-size: 12px; color: var(--text-secondary); line-height: 1.7; display: block; }
    .criteria-detail strong { color: var(--text-primary); font-weight: 700; }
    .thesis-game-bar { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 14px; padding-bottom: 12px; border-bottom: 1px solid var(--border-light); }
    .thesis-game-label { font-size: 16px; font-weight: 800; color: var(--text-primary); letter-spacing: -0.3px; }
    .thesis-game-period { font-size: 12px; color: var(--text-muted); margin-top: 3px; }
    .thesis-bet-line {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 14px;
      border: 1px solid var(--border-light);
    }
    .thesis-bet-action { font-size: 17px; font-weight: 800; color: var(--accent); letter-spacing: -0.3px; }
    .thesis-bet-side { font-size: 12px; color: var(--text-muted); margin-top: 4px; }
    .thesis-logic { margin-bottom: 14px; }
    .thesis-logic-title { font-size: 11px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
    .thesis-logic-text { font-size: 13px; color: var(--text-secondary); line-height: 1.7; }
    .thesis-criteria { margin-bottom: 14px; }
    .thesis-actions { display: flex; justify-content: space-between; align-items: center; padding-top: 12px; border-top: 1px solid var(--border-light); }
    .thesis-confidence { text-align: right; }
    .conf-meter { display: flex; gap: 4px; justify-content: flex-end; margin-bottom: 6px; }
    .conf-dot { width: 10px; height: 10px; border-radius: 50%; background: var(--border-light); border: 1px solid var(--border); transition: all 0.2s; }
    .conf-dot.lit { background: var(--accent); border-color: var(--accent); box-shadow: 0 0 4px rgba(0,212,170,0.3); }
    .conf-dot.lit-red { background: var(--red); border-color: var(--red); box-shadow: 0 0 4px rgba(239,68,68,0.3); }
    .conf-label { font-size: 11px; font-weight: 600; }
    .conf-label.high { color: var(--green); }
    .conf-label.medium { color: var(--orange); }
    .conf-label.low { color: var(--text-muted); }

    /* ===== MODALS ===== */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.25);
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      align-items: center;
      justify-content: center;
      z-index: 1000;
      animation: fadeIn 0.2s ease;
    }
    .modal-overlay.active { display: flex; }
    .modal {
      background: var(--white);
      border-radius: var(--radius-lg);
      padding: 32px;
      width: 90%;
      max-width: 520px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.12), 0 4px 16px rgba(0,0,0,0.06);
      animation: slideUp 0.25s ease;
      border: 1px solid var(--border);
    }
    .modal h2, .modal h3 { font-size: 18px; font-weight: 800; margin-bottom: 24px; color: var(--text-primary); letter-spacing: -0.3px; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

    /* ===== FORM CONTROLS ===== */
    input, select, textarea {
      font-family: 'Inter', sans-serif;
      font-size: 13px;
      padding: 10px 14px;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--white);
      color: var(--text-primary);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
      width: 100%;
    }
    input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px rgba(0,212,170,0.12); }
    select { appearance: none; background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%236b7280' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 12px center; padding-right: 32px; }

    /* ===== SCROLLBAR ===== */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }

    /* ===== BANKROLL ===== */
    .bankroll-section, .bankroll-settings { background: var(--card-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 22px; box-shadow: var(--shadow-xs); margin-bottom: 20px; }
    .bankroll-section label, label { font-size: 12px; font-weight: 600; color: var(--text-secondary); display: block; margin-bottom: 6px; }
    .stop-loss, .rules-box, [style*="border-left: 3px solid"] { background: var(--orange-light) !important; border: 1px solid #fde68a !important; border-left: 3px solid var(--orange) !important; border-radius: var(--radius-sm) !important; padding: 12px 16px !important; color: #92400e !important; font-size: 13px !important; }
    .notification-toast, .toast { position: fixed; top: 20px; right: 20px; background: var(--white); border: 1px solid var(--border); border-radius: var(--radius); padding: 16px 22px; box-shadow: var(--shadow-lg); z-index: 2000; font-size: 13px; font-weight: 500; animation: slideIn 0.3s ease; max-width: 360px; }
    @keyframes slideIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
    .auto-refresh-controls, .refresh-controls { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; margin-bottom: 16px; font-size: 13px; color: var(--text-secondary); }
    .auto-refresh-controls select, .refresh-controls select { width: auto; min-width: 80px; }
    .game-score, .score { font-size: 20px; font-weight: 800; color: var(--text-primary); }
    .game-teams, .matchup, .teams { font-weight: 600; color: var(--text-primary); font-size: 14px; }
    .game-status, .status { font-size: 12px; color: var(--text-muted); font-weight: 500; }
    .signal-list, .signals { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
    a { color: var(--accent); text-decoration: none; transition: color 0.15s; }
    a:hover { color: var(--accent-hover); text-decoration: underline; }
    strong, b { font-weight: 700; }

    /* ===== REMOVE BUTTONS ===== */
    .remove-btn, button.remove, [onclick*="remove"] { background: var(--red-light) !important; color: var(--red) !important; border: none !important; border-radius: var(--radius-sm) !important; width: 32px !important; height: 32px !important; display: inline-flex !important; align-items: center !important; justify-content: center !important; font-weight: 700 !important; font-size: 14px !important; padding: 0 !important; cursor: pointer; }
    .remove-btn:hover, button.remove:hover, [onclick*="remove"]:hover { background: var(--red) !important; color: white !important; }

    /* ===== TOOLTIPS ===== */
    .tooltip-wrap{position:relative;display:inline-block;cursor:help}
    .tooltip-wrap .info-dot{display:inline-flex;align-items:center;justify-content:center;width:14px;height:14px;border-radius:50%;background:var(--border);color:var(--text-muted);font-size:9px;font-weight:700;margin-left:4px;vertical-align:middle}
    .tooltip-wrap .tip{visibility:hidden;opacity:0;position:absolute;bottom:calc(100% + 8px);left:50%;transform:translateX(-50%);background:#1e293b;color:#e0e0e0;padding:10px 14px;border-radius:var(--radius-sm);font-size:11px;line-height:1.5;white-space:normal;width:240px;z-index:100;box-shadow:0 8px 24px rgba(0,0,0,.2);pointer-events:none;transition:opacity .2s,visibility .2s}
    .tooltip-wrap:hover .tip{visibility:visible;opacity:1}
    .tooltip-wrap .tip::after{content:'';position:absolute;top:100%;left:50%;transform:translateX(-50%);border:6px solid transparent;border-top-color:#1e293b}

    /* ===== EDGE GLOW ===== */
    @keyframes edgeGlow{0%,100%{box-shadow:0 0 6px rgba(0,212,170,0.2),0 0 16px rgba(0,212,170,0.1);}50%{box-shadow:0 0 12px rgba(0,212,170,0.4),0 0 32px rgba(0,212,170,0.2);}}
    .signal-chip.combined-active{animation:edgeGlow 2.5s ease-in-out infinite;background:var(--accent-light);border-radius:0;}
    .signal-chip.combined-active:first-child { border-radius: var(--radius) 0 0 var(--radius); }
    .signal-chip.combined-active:last-child { border-radius: 0 var(--radius) var(--radius) 0; }

    /* ===== GUIDE ===== */
    .guide-section{padding:24px 0}
    .guide-intro{color:var(--text-secondary);font-size:13px;margin-bottom:20px;line-height:1.7}
    .guide-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:18px}
    .guide-card{background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);padding:20px;transition:all .25s}
    .guide-card:hover{border-color:var(--accent);box-shadow:var(--shadow-sm)}
    .guide-card h3{font-size:15px;margin-bottom:10px;display:flex;align-items:center;gap:8px}
    .guide-card .edge-label{font-size:12px;color:var(--accent);font-weight:600;margin-bottom:8px}
    .guide-card p{font-size:12px;color:var(--text-secondary);line-height:1.6;margin-bottom:10px}
    .guide-card .threshold{font-size:11px;color:var(--text-secondary);background:var(--bg);padding:10px 14px;border-radius:var(--radius-sm);border-left:3px solid var(--accent);line-height:1.6}

    /* ===== SIGNAL BADGES ===== */
    .signal-badge{display:inline-block;padding:3px 10px;border-radius:20px;font-size:10px;font-weight:700;letter-spacing:.4px;color:#fff}
    .signal-badge.badge-3pt{background:#3b82f6}
    .signal-badge.badge-star{background:#f59e0b}
    .signal-badge.badge-fragile{background:#ef4444}
    .signal-badge.badge-paint{background:#10b981}
    .signal-badge.badge-foul{background:#8b5cf6}
    .signal-badge.badge-hustle{background:#f59e0b}
    .signal-badge.badge-road{background:#06b6d4}
    .signal-badge.badge-combined{background:#00d4aa}
    .signal-badge.badge-hot{background:#ef4444}
    .signal-badge.badge-warm{background:#f97316}
    .signal-badge.badge-qtr{background:#eab308}
    .signal-badge.badge-3ptFragile{background:#3b82f6}

    /* ===== THEORY PANEL ===== */
    .theory-toggle{background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);padding:12px 18px;margin:16px auto;max-width:1200px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;transition:all .2s}
    .theory-toggle:hover{border-color:var(--orange);background:var(--orange-light)}
    .theory-toggle h3{margin:0;font-size:14px;color:var(--text-primary)}.theory-toggle .arrow{transition:transform .3s;font-size:16px;color:var(--text-muted)}
    .theory-toggle.open .arrow{transform:rotate(180deg)}
    .theory-panel{max-width:1200px;margin:0 auto 20px;background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);padding:0;max-height:0;overflow:hidden;transition:max-height .4s ease,padding .3s ease}
    .theory-panel.open{max-height:8000px;padding:24px 28px}
    .theory-panel h4{color:var(--orange);font-size:15px;margin:20px 0 10px;font-weight:700}.theory-panel h4:first-child{margin-top:0}
    .theory-panel p{color:var(--text-secondary);font-size:13px;line-height:1.8;margin:0 0 12px}
    .theory-panel .edge-box{background:var(--orange-light);border-left:3px solid var(--orange);padding:12px 16px;border-radius:0 var(--radius-sm) var(--radius-sm) 0;margin:14px 0}
    .theory-panel .edge-box p{margin:0;font-size:12px;line-height:1.6}
    .theory-panel .edge-box.green{background:var(--green-light);border-left-color:var(--green)}
    .theory-panel .edge-box.blue{background:rgba(37,99,235,.06);border-left-color:var(--accent)}
    .theory-panel .edge-box.red{background:var(--red-light);border-left-color:var(--red)}
    .theory-panel .edge-box.purple{background:var(--purple-light);border-left-color:var(--purple)}
    .theory-panel .thresh-grid{display:grid;grid-template-columns:1fr 1fr;gap:14px;margin:14px 0}
    .theory-panel .thresh-card{background:var(--bg);border:1px solid var(--border);border-radius:var(--radius-sm);padding:12px 16px}
    .theory-panel .thresh-card h5{margin:0 0 6px;font-size:13px;color:var(--green)}
    .theory-panel .thresh-card p{font-size:12px;margin:2px 0}
    .theory-panel .tag{display:inline-block;padding:2px 8px;border-radius:20px;font-size:11px;font-weight:600;margin:2px 4px 2px 0}
    .theory-panel .tag.l2{background:var(--red-light);color:var(--red)}.theory-panel .tag.l1{background:var(--orange-light);color:var(--orange)}
    .theory-panel .tag.diff{background:var(--purple-light);color:var(--purple)}
    .theory-panel .signal-divider{border:none;border-top:1px solid var(--border-light);margin:28px 0}
    @media(max-width:600px){.theory-panel .thresh-grid{grid-template-columns:1fr}}

    /* ===== ODDS ROW ===== */
    .odds-row{display:flex;justify-content:space-between;align-items:center;padding:6px 10px;margin:6px 0;background:var(--bg);border:1px solid var(--border-light);border-radius:var(--radius-sm);font-size:11px;color:var(--text-secondary);}
    .odds-row .odds-label{color:var(--text-muted);font-weight:600;font-size:10px;text-transform:uppercase;letter-spacing:0.5px;}
    .odds-row .odds-val{font-weight:700;font-size:13px;font-family:'Inter',monospace;color:var(--text-primary);}
    .odds-row .odds-val.fav{color:var(--green);}
    .odds-row .odds-val.dog{color:var(--red);}
    .odds-row .odds-val.even{color:var(--orange);}
    .odds-row .odds-src{color:var(--text-muted);font-size:9px;}
    .odds-row .odds-implied{color:var(--text-muted);font-size:10px;}
    .odds-stale{opacity:0.5;}
    #odds-status{font-size:10px;color:var(--text-muted);margin-left:8px;}
    [data-theme="dark"] .odds-row { background: linear-gradient(135deg,#1a1a2e,#16213e); border-color: #2d2d44; color: #e0e0e0; }
    [data-theme="dark"] .odds-row .odds-label { color: #8892b0; }
    [data-theme="dark"] .odds-row .odds-val { color: #e0e0e0; }
    [data-theme="dark"] .odds-row .odds-val.fav { color: #00e676; }
    [data-theme="dark"] .odds-row .odds-val.dog { color: #ff5252; }
    [data-theme="dark"] .odds-row .odds-val.even { color: #ffd740; }
    [data-theme="dark"] .odds-row .odds-src { color: #546e7a; }
    [data-theme="dark"] .odds-row .odds-implied { color: #78909c; }

    /* ===== LIVE INDICATOR ===== */
    .live-indicator { display: inline-flex; align-items: center; gap: 6px; font-size: 11px; font-weight: 700; color: var(--green); letter-spacing: 0.5px; }
    .live-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--green); animation: livePulse 1.5s ease-in-out infinite; }
    @keyframes livePulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.4; transform: scale(0.8); } }

    /* ===== SIGNAL FIRE / WARN GAME CARDS ===== */
    .game-card.signal-fire { border: 2px solid var(--accent); box-shadow: 0 0 0 1px var(--accent-light), var(--shadow-sm); }
    .game-card.signal-fire:hover { box-shadow: 0 0 0 1px var(--accent-light), var(--shadow-md); }
    .game-card.signal-warn { border: 1px solid var(--orange); }

    /* ===== STAT BARS (game card inline stats) ===== */
    .stat-bars { margin-top: 10px; }
    .stat-bar-row { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; font-size: 11px; }
    .stat-bar-label { font-size: 10px; font-weight: 700; color: var(--text-muted); min-width: 52px; text-transform: uppercase; letter-spacing: 0.3px; }
    .stat-bar-track { flex: 1; height: 6px; background: var(--border-light); border-radius: 3px; position: relative; overflow: visible; }
    .stat-bar-fill { height: 100%; border-radius: 3px; font-size: 0; line-height: 0; transition: width 0.5s ease; }
    .stat-bar-fill.hot { background: var(--red); }
    .stat-bar-fill.normal { background: var(--accent); }
    .stat-bar-fill.cold { background: var(--text-muted); }
    .stat-bar-avg { position: absolute; top: -3px; width: 1px; height: 12px; background: var(--text-muted); opacity: 0.4; }
    .stat-bar-value { font-size: 10px; font-weight: 600; color: var(--text-secondary); min-width: 36px; text-align: right; font-variant-numeric: tabular-nums; }

    /* Durability bars */
    .durability-bar { display: flex; align-items: center; gap: 6px; font-size: 10px; color: var(--text-muted); margin-top: 4px; }
    .durability-meter { flex: 1; height: 4px; background: var(--border-light); border-radius: 2px; overflow: hidden; }
    .durability-meter-fill { height: 100%; border-radius: 2px; transition: width 0.5s ease; }

    /* Pace indicator */
    .pace-indicator { display: inline-block; width: 60px; height: 5px; background: var(--border-light); border-radius: 3px; overflow: hidden; vertical-align: middle; margin-right: 4px; }
    .pace-fill { height: 100%; border-radius: 3px; transition: width 0.5s ease; }

    /* 3PT tracker cards */
    .three-pt-card-header { display: flex; justify-content: space-between; align-items: center; padding: 10px 16px; background: var(--bg); border-bottom: 1px solid var(--border-light); font-size: 12px; font-weight: 600; color: var(--text-secondary); border-radius: var(--radius) var(--radius) 0 0; }
    .three-pt-card-body { padding: 14px 16px; }
    .hot-card { border-color: var(--red) !important; }
    .warm-card { border-color: var(--orange) !important; }
    .qtr-grid { display: flex; gap: 6px; margin-top: 6px; }

    /* Signal badge variants in game cards */
    .signal-fire { font-weight: 700; }
    .signal-moderate { background: var(--orange-light); color: var(--orange); }
    .signal-none { background: var(--bg); color: var(--text-muted); }

    /* Fav star */
    .fav-star { opacity: 0.4; transition: opacity 0.2s; }
    .fav-star:hover { opacity: 1; }

    /* Edge thesis container */
    .edge-thesis-container { margin-bottom: 20px; }
    .edge-thesis-container:not(.active) { display: none; }
    .edge-thesis-container.active { display: block; }

    /* Connection status */
    .conn-status { font-size: 10px; padding: 2px 8px; border-radius: 20px; font-weight: 600; }
    .conn-ok { color: var(--green); }
    .conn-err { color: var(--red); }
    .conn-loading { color: var(--orange); }

    /* Live pulse header */
    .live-pulse { background: linear-gradient(135deg, var(--accent-light), var(--bg)) !important; }

    /* Btn variants */
    .btn-sm { font-size: 12px; padding: 6px 14px; }
    .btn-green { background: var(--accent); color: white; }
    .btn-green:hover { background: var(--accent-hover); }
    .btn-red { background: var(--red); color: white; }
    .btn-purple { background: var(--purple); color: white; }
    .btn-orange { background: var(--orange); color: white; }
    .btn-outline { background: var(--card-bg); color: var(--text-secondary); border: 1px solid var(--border); }
    .btn-outline:hover { border-color: var(--accent); color: var(--accent); }

    /* Odds history button */
    .odds-hist-btn { margin: 8px 10px !important; padding: 5px 14px !important; font-size: 11px !important; font-weight: 600 !important; border: 1px solid var(--border) !important; color: var(--text-secondary) !important; background: var(--bg) !important; border-radius: 20px !important; cursor: pointer !important; transition: all 0.2s !important; }
    .odds-hist-btn:hover { background: var(--accent-light) !important; border-color: var(--accent) !important; color: var(--accent) !important; }

    /* ===== MOBILE RESPONSIVE ===== */
    @media (max-width: 768px) {
      .header { padding: 12px 16px; flex-wrap: wrap; gap: 8px; min-height: auto; }
      .header h1 { font-size: 15px; }
      .header .subtitle { font-size: 10px; }
      .logo-icon { width: 30px; height: 30px; }
      .logo-text .logo-main { font-size: 16px; letter-spacing: 1px; }
      .logo-text .logo-sub { font-size: 8px; letter-spacing: 2px; }
      .logo-wrap { gap: 8px; }
      .header-right { gap: 4px; }
      .header-right button { font-size: 10px; padding: 4px 8px; }
      .tab-bar { padding: 0 16px; top: auto; }
      .tabs { overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
      .tabs::-webkit-scrollbar { display: none; }
      .tab { padding: 10px 14px; font-size: 12px; }
      .signal-strip { flex-wrap: wrap; }
      .signal-chip { flex: 1 1 30%; min-width: 90px; padding: 10px 6px; }
      .signal-chip .chip-value { font-size: 20px; }
      .signal-chip .chip-label { font-size: 10px; }
      .signal-chip .chip-desc { display: none; }
      .game-card-body { padding: 10px 12px; }
      .game-card { margin-bottom: 12px; }
      .modal { width: 95%; padding: 20px; }
      .container { padding: 12px; }
      .content, .main-content, .tab-content { padding: 16px; }
      #live-games, #tab-3pt, #tab-star, #tab-betlog, #tab-bankroll, #tab-guide { padding: 12px; }
      .edge-panel { padding: 12px; }
      .guide-card { padding: 14px; }
      .games-grid { grid-template-columns: 1fr; }
      .stats-row { grid-template-columns: repeat(2, 1fr); }
    }
    @media (max-width: 480px) {
      .header h1 { font-size: 13px; }
      .signal-chip { flex: 1 1 45%; }
      .tab { padding: 8px 10px; font-size: 11px; }
      .logo-icon { width: 24px; height: 24px; }
      .logo-text .logo-main { font-size: 14px; }
      .logo-text .logo-sub { display: none; }
      .logo-wrap { gap: 6px; }
      .stats-row { grid-template-columns: repeat(2, 1fr); gap: 10px; }
      .stat-card { padding: 14px 10px; }
      .stat-value { font-size: 24px; }
    }

</style>
</head>
<body>

<div class="header">
  <div class="logo-wrap">
    <svg class="logo-icon" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="logoGrad" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" stop-color="#00d4aa"/>
          <stop offset="50%" stop-color="#00b4d8"/>
          <stop offset="100%" stop-color="#7c3aed"/>
        </linearGradient>
        <radialGradient id="glowGrad" cx="50%" cy="50%" r="50%">
          <stop offset="0%" stop-color="#00d4aa" stop-opacity="0.3"/>
          <stop offset="100%" stop-color="#00d4aa" stop-opacity="0"/>
        </radialGradient>
      </defs>
      <circle class="scope-pulse" cx="20" cy="20" r="2"/>
      <circle class="scope-ring" cx="20" cy="20" r="14"/>
      <circle class="scope-ring" cx="20" cy="20" r="8" stroke-dasharray="3 3"/>
      <line class="scope-cross" x1="20" y1="2" x2="20" y2="10"/>
      <line class="scope-cross" x1="20" y1="30" x2="20" y2="38"/>
      <line class="scope-cross" x1="2" y1="20" x2="10" y2="20"/>
      <line class="scope-cross" x1="30" y1="20" x2="38" y2="20"/>
      <circle class="scope-dot" cx="20" cy="20" r="2.5"/>
      <path d="M14 11 L20 5 L26 11" fill="none" stroke="url(#logoGrad)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.6"/>
    </svg>
    <div class="logo-text">
      <span class="logo-main" id="main-title">ALPHA HUNTER</span>
      <span class="logo-sub" id="main-subtitle">NBA &bull; DATA-DRIVEN ANALYTICS</span>
    </div>
  </div>
  <div class="header-right">
    <span class="conn-status conn-ok" id="connStatus" style="display:none;font-size:10px;color:var(--text-muted);">Connected</span>
    <div style="display:flex;align-items:center;gap:6px;">
      <span class="status-dot off" id="statusDot"></span>
      <span id="statusText" style="font-size:11px;color:var(--text-muted);">ESPN Feed</span>
    </div>
    <span id="ncaa-star-status" style="font-size:10px;color:var(--accent);font-weight:600;"></span>
    <div class="header-controls">
      <button id="modeToggleBtn" onclick="switchMode(currentMode==='nba'?'ncaab':'nba')" title="Switch NBA/NCAAB" style="background:var(--purple)!important;color:white!important;">NBA</button>
      <button id="darkModeToggle" onclick="toggleDarkMode()" title="Toggle dark mode">Dark</button>
      <button class="sound-toggle" id="soundToggle" onclick="toggleSound()" title="Toggle alert sounds">&#x1F50A; Sound</button>
    </div>
  </div>
</div>

<div class="tab-bar" id="tabBar">
  <div class="tab active" onclick="switchTab('live')" id="tab-live">Live Games <span class="badge" id="live-badge" style="display:none;">0</span></div>
  <div class="tab" onclick="switchTab('threept')" id="tab-threept">3PT Tracker <span class="badge badge-purple" id="threept-badge" style="display:none;">0</span></div>
  <div class="tab" onclick="switchTab('stars')" id="tab-stars">Star Tracker</div>
  <div class="tab" onclick="switchTab('log')" id="tab-log">Bet Log</div>
  <div class="tab" onclick="switchTab('bankroll')" id="tab-bankroll">Bankroll</div>
  <div class="tab" onclick="switchTab('history')" id="tab-history">History</div>
  <div class="tab" onclick="switchTab('tracker')" id="tab-tracker">Backtest</div>
  <div class="tab" onclick="switchTab('edge')" id="tab-edge">Quality Edge <span class="badge badge-green" id="edge-badge" style="display:none;">0</span></div>
  <div class="tab" onclick="switchTab('guide')" id="tab-guide">Signal Guide</div>
</div>

<div class="container">
  <div id="quarter-alerts"></div>

  <!-- ==================== LIVE GAMES TAB ==================== -->
  <div class="tab-content active" id="content-live">
    <!-- EDGE THESIS PANEL -->
    <div class="edge-thesis-container" id="edgeThesisContainer">
      <div class="edge-thesis-header">
        <h2>LIVE EDGE OPPORTUNITIES</h2>
        <span class="thesis-count" id="thesisCount">0</span>
      </div>
      <div id="edgeThesisCards"></div>
    </div>

    <div class="auto-refresh-bar" style="background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);padding:10px 16px;margin-bottom:16px;">
      <span class="dot" id="autoRefreshDot" style="width:6px;height:6px;border-radius:50%;background:var(--text-muted);flex-shrink:0;"></span>
      <span style="font-weight:500;">Auto-refresh: <strong id="autoRefreshLabel" style="color:var(--text-primary);">OFF</strong></span>
      <button class="btn btn-sm btn-green" id="autoRefreshBtn" onclick="toggleAutoRefresh()" style="background:var(--accent);color:white;border:none;padding:6px 16px;border-radius:20px;font-size:11px;font-weight:700;">Start</button>
      <span style="color:var(--text-muted);font-size:11px;">Every:</span>
      <select id="refreshInterval" style="padding:4px 8px;font-size:11px;border-radius:6px;border:1px solid var(--border);width:auto;min-width:60px;" onchange="updateRefreshInterval()">
        <option value="30" selected>30s</option>
        <option value="60">60s</option>
        <option value="120">2min</option>
      </select>
      <div class="countdown-bar"><div class="countdown-fill" id="countdownFill" style="width:100%;"></div></div>
      <span class="live-indicator" id="liveIndicator" style="display:none"><span class="live-dot"></span>LIVE</span>
      <span style="margin-left:auto;color:var(--text-muted);font-size:10px;">Last: <span id="live-last-update">-</span> | Errors: <span id="errorCount">0</span> <span id="odds-status"></span></span>
    </div>

    <div class="signal-strip">
      <div class="signal-chip">
        <div class="chip-value" id="live-games-count">-</div>
        <div class="chip-label">Games</div>
        <div class="chip-desc">Total live games tracked</div>
      </div>
      <div class="signal-chip signal-chip-clickable" onclick="toggleSignalDetail('star')">
        <div class="chip-value" id="live-star-signals">0</div>
        <div class="chip-label">Star Coil</div>
        <div class="chip-desc">Star cold + game close + Q2-Q3 (58.6% verified)</div>
        <div class="chip-detail-panel" id="chip-detail-star"></div>
      </div>
      <div class="signal-chip signal-chip-clickable" onclick="toggleSignalDetail('starcoilplus')">
        <div class="chip-value" id="live-starcoilplus-signals">0</div>
        <div class="chip-label">Star Coil+</div>
        <div class="chip-desc">Star cold + opponent shooting cold (57% verified)</div>
        <div class="chip-detail-panel" id="chip-detail-starcoilplus"></div>
      </div>
      <div class="signal-chip signal-chip-clickable" onclick="switchTab('edge')">
        <div class="chip-value green" id="qe-count">&mdash;</div>
        <div class="chip-label green">QUALITY EDGE</div>
        <div class="chip-desc">Strong team trailing 1-10, live spread still negative (72% cover)</div>
      </div>
    </div>

<!-- QUICK BET ACTION CARDS -->
<div id="quick-bet-panel" style="display:none; margin-bottom: 20px;">
  <div style="font-size: 11px; font-weight: 700; color: var(--accent); text-transform: uppercase; letter-spacing: 1.2px; margin-bottom: 10px; display:flex; align-items:center; gap:8px;">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>
    ACTION REQUIRED
  </div>
  <div id="quick-bet-cards"></div>
</div>

    <div class="card">
      <div class="card-header"><span>Live Game Monitor</span>
        <button class="btn btn-green btn-sm" onclick="fetchESPNScoreboard()">Refresh Now</button>
      </div>
      <div class="card-body">
        <div class="games-grid" id="live-games-grid">
          <div class="empty-state" style="grid-column:1/-1;">
            <div style="width:56px;height:56px;margin:0 auto 16px;background:var(--bg);border:2px solid var(--border);border-radius:50%;display:flex;align-items:center;justify-content:center;">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
            </div>
            <p style="font-weight:600;color:var(--text-secondary);margin-bottom:4px;">Waiting for games</p>
            <p style="font-size:12px;">Click "Refresh Now" or start auto-refresh to load live games.</p>
          </div>
        </div>
      </div>
    </div>

    </div>
  </div>

  <!-- ==================== 3PT TRACKER TAB ==================== -->
  <div class="tab-content" id="content-threept">
    <div class="stats-row">
      <div class="stat-card"><div class="stat-label">Teams 50%+ 3PT</div><div class="stat-value red" id="threept-hot-count">0</div></div>
      <div class="stat-card"><div class="stat-label">Teams 45-50%</div><div class="stat-value orange" id="threept-warm-count">0</div></div>
      <div class="stat-card"><div class="stat-label">Qtr Alerts</div><div class="stat-value purple" id="threept-qtr-alerts">0</div></div>
      </div>
    <div class="card">
      <div class="card-header"><span>3-Point Shooting Tracker - Live</span><span style="font-size:10px;color:var(--text-muted);">Alert: 50%+ on 8+ att</span></div>
      <div class="card-body"><div class="games-grid" id="threept-grid"><div class="empty-state" style="grid-column:1/-1;"><p>3PT tracking populates when live games run.</p></div></div></div>
    </div>
    <div class="card">
      <div class="card-header"><span>Quarter-End Alerts</span><button class="btn btn-sm btn-outline" onclick="clearQtrAlerts()">Clear</button></div>
      <div class="card-body">
        <table><thead><tr><th>Time</th><th>Team</th><th>Qtr</th><th>3PT%</th><th>Made/Att</th><th>Game</th><th>Action</th></tr></thead>
        <tbody id="qtr-alerts-body"><tr><td colspan="7" class="empty-state">No quarter-end alerts yet.</td></tr></tbody></table>
      </div>
    </div>
  </div>

  <!-- ==================== STAR TRACKER TAB ==================== -->
  <div class="tab-content" id="content-stars">
    <div class="card">
      <div class="card-header"><span id="star-db-title">Star Player Database (21+ PPG)</span><span id="star-db-subtitle" style="font-size:10px;color:var(--text-muted);">Signal: &lt;65% of expected pace</span></div>
      <div class="card-body" style="font-size:12px;">
        <p style="margin-bottom:10px;color:var(--text-muted);">Players tracked automatically in live games. Signal fires when scoring falls below 60% of expected pace. Tracks Q1 and halftime pace separately.</p>
        <table>
          <thead><tr><th>Player</th><th>Team</th><th>PPG</th><th>Q1 Exp</th><th>Half Exp</th><th>Signal (&lt;60%)</th><th></th></tr></thead>
          <tbody id="star-db-body"></tbody>
        </table>
        <div style="margin-top:10px;">
          <div class="form-grid" style="max-width:700px;">
            <div class="form-group"><label>Player Name</label><input type="text" id="add-star-name" placeholder="e.g., LeBron James" /></div>
            <div class="form-group"><label>Team</label><input type="text" id="add-star-team" placeholder="e.g., LAL" /></div>
            <div class="form-group"><label>PPG</label><input type="number" id="add-star-ppg" placeholder="e.g., 28.5" step="0.1" /></div>
            <div class="form-group" style="justify-content:flex-end;"><button class="btn btn-green" onclick="addStar()">Add</button></div>
          </div>
        </div>
      </div>
    </div>
    <div class="card">
      <div class="card-header">Live Star Status</div>
      <div class="card-body">
        <table><thead><tr><th>Player</th><th>Game</th><th>Pts</th><th id="star-col-q1">Q1 Pace</th><th>Half Pace</th><th>Overall %</th><th>Period</th><th>Signal</th></tr></thead>
        <tbody id="live-star-status"><tr><td colspan="8" class="empty-state">Star stats populate when live games are running.</td></tr></tbody></table>
      </div>
    </div>
  </div>

  <!-- ==================== BET LOG TAB ==================== -->
  <div class="tab-content" id="content-log">
    <div style="margin-bottom:20px">
      <h2 style="font-size:18px;font-weight:800;margin-bottom:4px">Bet Tracker</h2>
      <p style="font-size:12px;color:var(--text-muted)">Auto-logged when signals fire. Results auto-resolved from ESPN final scores.</p>
    </div>
    <div id="backtest-panel" style="display:grid;grid-template-columns:repeat(5,1fr);gap:12px;margin-bottom:20px">
      <div class="stat-card"><div class="stat-label">TOTAL BETS</div><div class="stat-value" id="bt-total" style="font-size:24px">0</div></div>
      <div class="stat-card"><div class="stat-label">WIN RATE</div><div class="stat-value" id="bt-winrate" style="font-size:24px;color:var(--green)">-</div></div>
      <div class="stat-card"><div class="stat-label">ROI</div><div class="stat-value" id="bt-roi" style="font-size:24px">-</div></div>
      <div class="stat-card"><div class="stat-label">AVG EDGE</div><div class="stat-value" id="bt-edge" style="font-size:24px;color:var(--accent)">-</div></div>
      <div class="stat-card"><div class="stat-label">UNITS P/L</div><div class="stat-value" id="bt-units" style="font-size:24px">0.00</div></div>
    </div>
    <div id="signal-breakdown" style="margin-bottom:20px"></div>
    <div style="display:flex;gap:10px;margin-bottom:16px;align-items:center">
      <button style="background:var(--accent);color:white;border:none;padding:8px 16px;border-radius:20px;font-size:12px;font-weight:600;cursor:pointer" onclick="exportBetLog()">Export CSV</button>
      <button style="background:var(--card-bg);color:var(--text-muted);border:1px solid var(--border);padding:8px 16px;border-radius:20px;font-size:12px;font-weight:600;cursor:pointer" onclick="if(confirm('Clear all bet log data?'))clearBetLog()">Clear Log</button>
      <span style="margin-left:auto;font-size:11px;color:var(--text-muted)">Bets auto-log when combined signals fire</span>
    </div>
    <div class="card" style="padding:0;overflow:hidden">
      <div id="bet-log-entries" style="overflow-x:auto"></div>
    </div>
  </div>

  <!-- ==================== BANKROLL TAB ==================== -->
  <div class="tab-content" id="content-bankroll">
    <div style="margin-bottom:20px">
      <h2 style="font-size:18px;font-weight:800;margin-bottom:4px">Position Sizing</h2>
      <p style="font-size:12px;color:var(--text-muted)">Kelly criterion-based bet sizing. Conservative by default - capped at 5% max per bet.</p>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:24px">
      <div class="card" style="padding:20px">
        <h3 style="font-size:14px;font-weight:700;color:var(--accent);margin-bottom:16px">Settings</h3>
        <div style="margin-bottom:14px">
          <label style="font-size:11px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px">Bankroll</label>
          <input type="number" id="bankroll-input" value="1000" min="1" style="margin-top:4px;font-size:16px;font-weight:700" onchange="saveBankrollSettings()">
        </div>
        <div style="margin-bottom:14px">
          <label style="font-size:11px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px">Kelly Fraction</label>
          <select id="kelly-fraction" style="margin-top:4px" onchange="saveBankrollSettings()">
            <option value="0.25">Quarter Kelly (25%) - Safest</option>
            <option value="0.5" selected>Half Kelly (50%) - Recommended</option>
            <option value="0.75">Three-Quarter Kelly (75%)</option>
            <option value="1">Full Kelly (100%) - Max Risk</option>
          </select>
        </div>
        <div style="margin-bottom:14px">
          <label style="font-size:11px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px">Edge Estimate</label>
          <select id="edge-mode" style="margin-top:4px" onchange="saveBankrollSettings()">
            <option value="conservative">Conservative (2-5%)</option>
            <option value="moderate" selected>Moderate (3.5-6.5%)</option>
            <option value="aggressive">Aggressive (6-9%)</option>
            <option value="backtest">From Your Bet History</option>
          </select>
        </div>
        <div style="background:var(--bg);border-radius:8px;padding:12px;margin-top:12px">
          <div style="font-size:10px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px">Sizing Rules</div>
          <div style="font-size:11px;color:var(--text-secondary);line-height:1.6">
            Max bet: 5% of bankroll<br>
            Min bet: 0.5% (if edge exists)<br>
            Edge scales with signal count<br>
            Probability capped at 90%
          </div>
        </div>
      </div>
      <div class="card" style="padding:20px">
        <h3 style="font-size:14px;font-weight:700;color:var(--accent);margin-bottom:16px">Kelly Formula</h3>
        <div style="background:var(--bg);border-radius:8px;padding:16px;font-family:'Courier New',monospace;font-size:13px;color:var(--text-secondary);line-height:2">
          f* = (b x p - q) / b<br>
          <span style="color:var(--text-muted);font-size:11px">b = decimal odds - 1</span><br>
          <span style="color:var(--text-muted);font-size:11px">p = market prob + estimated edge</span><br>
          <span style="color:var(--text-muted);font-size:11px">q = 1 - p</span><br><br>
          <span style="color:var(--accent);font-weight:bold">Bet = Bankroll x f* x Fraction</span>
        </div>
        <div style="margin-top:16px;padding:12px;background:var(--accent-light);border-radius:8px;border-left:3px solid var(--accent)">
          <div style="font-size:11px;color:var(--accent);font-weight:600">How edge is estimated</div>
          <div style="font-size:11px;color:var(--text-secondary);margin-top:4px;line-height:1.5">
            Base edge depends on your mode setting. Each additional signal on the same game adds +1% edge (up to +3%). More signals = higher confidence = larger position.
          </div>
        </div>
      </div>
    </div>
    <div class="card" style="padding:20px">
      <h3 style="font-size:14px;font-weight:700;color:var(--accent);margin-bottom:16px">Active Recommendations</h3>
      <div id="kelly-recs"><p style="color:var(--text-muted);text-align:center;padding:30px;font-size:13px">Refresh games to see Kelly-sized recommendations</p></div>
    </div>
  </div>
</div>



<!-- LOG BET MODAL -->
<div class="modal-overlay" id="logModal">
  <div class="modal">
    <h3>Log This Bet</h3>
    <div class="form-grid">
      <div class="form-group"><label>Game</label><input type="text" id="modal-game" /></div>
      <div class="form-group"><label>Side</label><input type="text" id="modal-side" /></div>
      <div class="form-group"><label>Strategy</label><select id="modal-strategy"><option>Mean Reversion</option><option>Star Coil</option><option>Star Coil+</option><option>Quality Edge</option></select></div>
      <div class="form-group"><label>Line / Price</label><input type="text" id="modal-price" /></div>
      <div class="form-group"><label>Units</label><input type="number" id="modal-units" value="1" step="0.5" min="0.5" max="2" /></div>
      <div class="form-group"><label>Notes</label><input type="text" id="modal-notes" /></div>
    </div>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
      <button class="btn btn-outline" onclick="closeModal()">Cancel</button>
      <button class="btn btn-green" onclick="confirmLogBet()">Log Bet</button>
    </div>
  </div>
</div>


  <div id="scenario-alert-panel" class="scenario-alert-panel" style="display:none;"></div>

  <!-- No toast container  signals show on chips and game cards only -->

<script>
const TEAM_3PT_AVG = {
  // NBA (2025-26)
  BOS:38.1, CLE:37.9, OKC:38.9, HOU:36.2, GSW:37.8, DEN:36.5, DAL:37.6, MIL:36.8,
  MIN:36.3, NYK:37.8, PHI:36.9, PHX:38.2, LAC:36.5, MEM:35.9, SAC:37.5, MIA:36.8,
  IND:36.7, ORL:35.4, ATL:37.2, CHI:34.2, BKN:35.4, CHA:34.8, TOR:36.1, POR:35.6,
  SAS:35.3, DET:35.7, LAL:36.3, WAS:34.5, UTA:37.0, NOP:35.1, NY:37.8, GS:37.8,
  SA:35.3, NO:35.1
};
function getTeam3PtAvg(abbr) {
  if (isNCAA()) return ncaaTeam3ptCache[abbr] || 33.5; // per-team NCAA avg, fallback to league avg
  return TEAM_3PT_AVG[abbr] || null; // NBA: hardcoded per-team
}

// ==================== SUPPORTING CAST ANALYSIS ====================
// Pure live-data approach: no season averages, no assumptions.
// Compares the star's teammates' output directly to the opponent's total output.
//
// castScore = teamScore - starPts (what teammates produced)
// castGap = castScore - opponentScore (how close cast alone is to matching the opponent)
//
// If castGap  0: Cast is MATCHING or BEATING the opponent without the star. Star regression = dominant.
// If castGap > -8: Cast is close. Star regression likely flips the game. Strong edge.
// If castGap -8 to -15: Cast is behind but game is still in range. Standard edge.
// If castGap < -15: Cast is way behind. Whole team broken. Star alone won't save it. Weak edge.
//
// Also computes starDeficit = star's expected pts - star's actual pts (the "missing" points).
// If starDeficit > |castGap|, star regression alone closes the gap. This is the key insight:
//   the star has MORE missing points than the team is behind = regression flips the lead.
//
function analyzeSupportingCast(starPts, teamScore, opponentScore, starPPG, elapsedMinutes) {
  const castScore = teamScore - starPts;
  const castGap = castScore - opponentScore;
  const starExpected = starPPG * (elapsedMinutes / getTotalGameMinutes());
  const starDeficit = starExpected - starPts;  // how many points the star is "missing"
  const regressionFlips = starDeficit > 0 && starDeficit > Math.abs(Math.min(castGap, 0));

  if (elapsedMinutes < 8) return { castScore, castGap, starDeficit, regressionFlips, strong: false, moderate: false, weak: true, label: 'N/A', emoji: '', reason: 'too early' };

  // Classify based on cast gap
  const strong = castGap >= -8;     // cast within 8 of opponent or ahead
  const moderate = castGap >= -15 && castGap < -8;
  const weak = castGap < -15;

  let label, emoji;
  if (castGap >= 0) { label = 'CAST LEADING'; emoji = ''; }
  else if (strong) { label = 'CAST CLOSE'; emoji = ''; }
  else if (moderate) { label = 'CAST BEHIND'; emoji = ''; }
  else { label = 'CAST BROKEN'; emoji = ''; }

  return {
    castScore, castGap, starDeficit: Math.round(starDeficit * 10) / 10,
    starExpected: Math.round(starExpected * 10) / 10,
    regressionFlips,
    strong, moderate, weak, label, emoji,
    reason: `Cast ${castScore}pts vs opp ${opponentScore}pts (gap: ${castGap > 0 ? '+' : ''}${castGap}). Star missing ~${starDeficit.toFixed(0)}pts.${regressionFlips ? ' Regression flips the lead.' : ''}`
  };
}

let currentMode='nba';

// NCAA Star Database  built PRE-GAME from ESPN team leaders API (real season PPG)
let ncaaStarCache = JSON.parse(localStorage.getItem('ncaaStarCache') || '[]');
let ncaaStarCacheTime = parseInt(localStorage.getItem('ncaaStarCacheTime') || '0');
const NCAA_STAR_CACHE_TTL = 86400000; // 24h cache
let ncaaStarBuildInProgress = false;

function isNCAA() { return currentMode === 'ncaab'; }

// NCAA team 3PT season averages  per-team (not flat league average)
let ncaaTeam3ptCache = JSON.parse(localStorage.getItem('ncaaTeam3ptCache') || '{}');

// Build NCAA star database + team 3PT averages from ESPN Core API
// Fetches ALL 362 D-I teams (not just today's games)
// Pipeline: teams endpoint  team leaders (PPG)  resolve names for 16+ PPG + team 3PT stats
async function buildNcaaStarDB(forceRefresh) {
  if (ncaaStarBuildInProgress) return;
  if (!forceRefresh && ncaaStarCache.length > 0 && (Date.now() - ncaaStarCacheTime) < NCAA_STAR_CACHE_TTL) {
    console.log('[NCAA] Using cached DB:', ncaaStarCache.length, 'stars,', Object.keys(ncaaTeam3ptCache).length, 'team 3PT avgs');
    return;
  }
  ncaaStarBuildInProgress = true;
  const statusEl = document.getElementById('ncaa-star-status');
  if (statusEl) statusEl.textContent = 'Building full NCAA database...';
  console.log('[NCAA] Building full database (all D-I teams)...');

  try {
    // Step 1: Get ALL D-I teams from ESPN teams endpoint
    const teamsResp = await fetch('https://site.api.espn.com/apis/site/v2/sports/basketball/mens-college-basketball/teams?limit=500');
    if (!teamsResp.ok) throw new Error('Teams endpoint failed');
    const teamsData = await teamsResp.json();
    const allTeams = [];
    const leagueTeams = teamsData.sports?.[0]?.leagues?.[0]?.teams || [];
    for (const t of leagueTeams) {
      const team = t.team || {};
      if (team.id && team.abbreviation) {
        allTeams.push({ id: team.id, abbr: team.abbreviation, name: team.displayName || '' });
      }
    }
    if (statusEl) statusEl.textContent = `Scanning ${allTeams.length} teams...`;
    console.log('[NCAA] Found', allTeams.length, 'D-I teams');

    // Step 2: Fetch team leaders (PPG) + team 3PT stats  8 at a time
    const candidates = [];
    const team3pt = {};
    const batchSize = 8;

    for (let i = 0; i < allTeams.length; i += batchSize) {
      const batch = allTeams.slice(i, i + batchSize);
      if (i > 0 && i % 80 === 0) {
        if (statusEl) statusEl.textContent = `${i}/${allTeams.length} teams... (${candidates.length} stars)`;
      }

      const results = await Promise.allSettled(batch.map(async (team) => {
        const teamResult = { stars: [], abbr: team.abbr, fg3Pct: null };

        // Fetch team leaders (PPG)
        try {
          const url = `https://sports.core.api.espn.com/v2/sports/basketball/leagues/mens-college-basketball/seasons/2026/types/2/teams/${team.id}/leaders`;
          const resp = await fetch(url);
          if (resp.ok) {
            const d = await resp.json();
            for (const cat of (d.categories || [])) {
              if (cat.name === 'pointsPerGame' || cat.name === 'points' || cat.displayName === 'Points Per Game') {
                for (const l of (cat.leaders || [])) {
                  const ppg = l.value || 0;
                  if (ppg >= 16) {
                    const ref = l.athlete?.$ref || '';
                    teamResult.stars.push({ ppg: Math.round(ppg * 10) / 10, ref, team: team.abbr, teamId: team.id });
                  }
                }
                break;
              }
            }
          }
        } catch(e) { /* skip */ }

        // Fetch team statistics for 3PT season average
        try {
          const sUrl = `https://sports.core.api.espn.com/v2/sports/basketball/leagues/mens-college-basketball/seasons/2026/types/2/teams/${team.id}/statistics`;
          const sResp = await fetch(sUrl);
          if (sResp.ok) {
            const sData = await sResp.json();
            for (const cat of (sData.splits?.categories || [])) {
              for (const stat of (cat.stats || [])) {
                if (stat.name === 'threePointFieldGoalPct') {
                  teamResult.fg3Pct = parseFloat(stat.value) || null;
                }
              }
            }
          }
        } catch(e) { /* skip */ }

        return teamResult;
      }));

      for (const r of results) {
        if (r.status !== 'fulfilled' || !r.value) continue;
        candidates.push(...r.value.stars);
        if (r.value.fg3Pct !== null) {
          team3pt[r.value.abbr] = Math.round(r.value.fg3Pct * 10) / 10;
        }
      }
    }

    if (statusEl) statusEl.textContent = `Resolving ${candidates.length} star names...`;

    // Step 3: Resolve athlete names
    const stars = [];
    for (let i = 0; i < candidates.length; i += batchSize) {
      const batch = candidates.slice(i, i + batchSize);
      const promises = batch.map(async (cand) => {
        try {
          if (!cand.ref) return cand;
          const resp = await fetch(cand.ref);
          if (!resp.ok) return cand;
          const ath = await resp.json();
          cand.name = ath.displayName || '?';
          cand.id = ath.id || '';
          return cand;
        } catch { return cand; }
      });
      const resolved = await Promise.all(promises);
      stars.push(...resolved.filter(s => s.name));
    }

    // Save stars
    ncaaStarCache = stars;
    ncaaStarCacheTime = Date.now();
    localStorage.setItem('ncaaStarCache', JSON.stringify(stars));
    localStorage.setItem('ncaaStarCacheTime', String(ncaaStarCacheTime));
    // Save team 3PT averages
    ncaaTeam3ptCache = team3pt;
    localStorage.setItem('ncaaTeam3ptCache', JSON.stringify(team3pt));
    console.log('[NCAA] Full DB built:', stars.length, 'stars,', Object.keys(team3pt).length, 'team 3PT avgs');
    if (statusEl) statusEl.textContent = `${stars.length} stars, ${Object.keys(team3pt).length} team 3PT avgs`;
    setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 5000);
  } catch (e) {
    console.warn('[NCAA] Build error:', e);
    if (statusEl) statusEl.textContent = 'DB error  using fallback';
  } finally {
    ncaaStarBuildInProgress = false;
  }
}

function switchMode(mode) {
  currentMode = mode;
  localStorage.setItem('alphaMode', mode);
  // Update UI labels
  const subtitle = document.getElementById('main-subtitle');
  if (subtitle) subtitle.innerHTML = mode === 'ncaab' ? 'NCAAB &bull; DATA-DRIVEN ANALYTICS' : 'NBA &bull; DATA-DRIVEN ANALYTICS';
  const modeBtn = document.getElementById('modeToggleBtn');
  if (modeBtn) modeBtn.textContent = mode === 'ncaab' ? 'NCAAB' : 'NBA';
  const starCol = document.getElementById('star-col-q1');
  if (starCol) starCol.textContent = mode === 'ncaab' ? 'H1 Pace' : 'Q1 Pace';
  const starTitle = document.getElementById('star-db-title');
  if (starTitle) starTitle.textContent = mode === 'ncaab' ? 'Star Player Database (16+ PPG)' : 'Star Player Database (21+ PPG)';
  const starSub = document.getElementById('star-db-subtitle');
  if (starSub) starSub.textContent = mode === 'ncaab' ? 'Signal: <65% pace, 8-35 min, margin 12' : 'Signal: <65% of expected pace';
  // Swap star database
  if (mode === 'ncaab') {
    // Save current NBA stars if switching away
    if (!state._nbaStars) state._nbaStars = DEFAULT_STARS;
    // Load NCAA stars from cache or empty
    state.stars = ncaaStarCache.length > 0 ? ncaaStarCache.map(s => ({name:s.name,team:s.team,ppg:s.ppg})) : [];
  } else {
    // Restore NBA stars
    state.stars = state._nbaStars || DEFAULT_STARS;
  }
  renderStarDB();
  // Update Signal Guide for current mode
  updateSignalGuide(mode);
  // Reset caches for fresh data
  teamScorerCache = {}; teamScorerLastFetch = 0;
  oddsCache = {}; oddsCacheTime = 0;
  state.scoreHistory = {};
  state.lastKnownPeriods = {};
  state.prevTeamData = {};
  // Build NCAA star database BEFORE fetching games
  if (mode === 'ncaab') {
    buildNcaaStarDB().then(() => {
      // Update stars after build completes
      if (ncaaStarCache.length > 0) {
        state.stars = ncaaStarCache.map(s => ({name:s.name,team:s.team,ppg:s.ppg}));
        renderStarDB();
      }
      fetchESPNScoreboard();
    });
  } else {
    fetchESPNScoreboard();
  }
}

// === LIVE ODDS (The Odds API) ===
let oddsCache={};let oddsCacheTime=0;const ODDS_CACHE_TTL=120000;
let oddsRequestCount=parseInt(localStorage.getItem('oddsReqCount')||'0');
let oddsReqMonth=localStorage.getItem('oddsReqMonth')||'';
function getOddsSport(){return isNCAA() ? 'basketball_ncaab' : 'basketball_nba';}
function impliedProb(am){const n=parseInt(am);if(n<0)return(Math.abs(n)/(Math.abs(n)+100)*100).toFixed(1);return(100/(n+100)*100).toFixed(1);}
function oddsClass(am){const n=parseInt(am);if(n<=-150)return'fav';if(n>=150)return'dog';return'even';}
async function fetchLiveOdds(){
  const now=Date.now();
  if(now-oddsCacheTime<ODDS_CACHE_TTL&&Object.keys(oddsCache).length>0)return oddsCache;
  const curMonth=new Date().toISOString().slice(0,7);
  if(oddsReqMonth!==curMonth){oddsRequestCount=0;oddsReqMonth=curMonth;}
  if(oddsRequestCount>=480){console.warn('Odds API near limit');return oddsCache;}
  try{
    const sport=getOddsSport();
    const oddsUrl='https://api.the-odds-api.com/v4/sports/'+sport+'/odds/?apiK'+'ey=4ca2c6a2ed9e162809eb03722e2dc734&regions=us&markets=h2h,spreads&oddsFormat=american&bookmakers=fanduel,draftkings,betmgm';
    const _ost=document.getElementById('odds-status');
    if(_ost)_ost.textContent='| Odds: loading...';
    const resp=await fetch(oddsUrl);
    if(!resp.ok){console.warn('Odds API:',resp.status);if(_ost)_ost.textContent='| Odds: HTTP '+resp.status;return oddsCache;}
    const data=await resp.json();
    oddsRequestCount++;
    localStorage.setItem('oddsReqCount',oddsRequestCount.toString());
    localStorage.setItem('oddsReqMonth',curMonth);
    const remaining=resp.headers.get('x-requests-remaining');
    if(!Array.isArray(data)||data.length===0){
      console.warn('[Odds] API returned',Array.isArray(data)?'empty array':typeof data);
      if(_ost)_ost.textContent='| Odds: 0 games';
      return oddsCache;
    }
    if(_ost)_ost.textContent='| Odds: '+data.length+' games';
    const nc={};
    for(const g of data){
      // Find h2h from any bookmaker
      let homeML=null,awayML=null,bookName='';
      for(const bk of (g.bookmakers||[])){
        const mk=bk.markets?.find(m=>m.key==='h2h');
        if(mk){
          const ho=mk.outcomes?.find(o=>o.name===g.home_team);
          const ao=mk.outcomes?.find(o=>o.name===g.away_team);
          if(ho&&ao){homeML=ho.price;awayML=ao.price;bookName=bk.title;break;}
        }
      }
      if(homeML===null||awayML===null)continue;
      // Find spreads from ANY bookmaker
      let homeSpread=null,awaySpread=null,homeSpreadPrice=null,awaySpreadPrice=null;
      for(const bk of (g.bookmakers||[])){
        const spMkt=bk.markets?.find(m=>m.key==='spreads');
        if(spMkt){
          const hO=spMkt.outcomes?.find(o=>o.name===g.home_team);
          const aO=spMkt.outcomes?.find(o=>o.name===g.away_team);
          if(hO&&aO){homeSpread=hO.point;homeSpreadPrice=hO.price;awaySpread=aO.point;awaySpreadPrice=aO.price;break;}
        }
      }
      nc[g.away_team+' vs '+g.home_team]={home:g.home_team,away:g.away_team,homeML,awayML,book:bookName,homeSpread,awaySpread,homeSpreadPrice,awaySpreadPrice};
    }
    oddsCache=nc;oddsCacheTime=now;
    console.log('[Odds] Loaded',Object.keys(nc).length,'games. Keys:',Object.keys(nc).join(', '));
    // Record odds history for LEC (Live Edge Captured) tracking
    const ts = Date.now();
    for (const k of Object.keys(nc)) {
      if (!state.oddsHistory[k]) state.oddsHistory[k] = [];
      const hist = state.oddsHistory[k];
      // Only record if odds changed or >60s since last snapshot
      if (hist.length === 0 || ts - hist[hist.length-1].ts > 60000) {
        hist.push({ ts, homeML: nc[k].homeML, awayML: nc[k].awayML });
        if (hist.length > 50) hist.splice(0, hist.length - 50); // keep last 50 snapshots
      }
    }
    // Prune stale game keys (>24h old)
    for (const k of Object.keys(state.oddsHistory)) {
      const h = state.oddsHistory[k];
      if (h.length > 0 && ts - h[h.length-1].ts > 86400000) delete state.oddsHistory[k];
    }
    localStorage.setItem('oddsHistory', JSON.stringify(state.oddsHistory));
    // Update LEC on any active signals
    updateLEC();
    return nc;
  }catch(e){
    console.warn('Odds error:',e);
    const el=document.getElementById('odds-status');
    if(el)el.textContent='| Odds: ERR '+e.message;
    return oddsCache;
  }
}
// === LIVE EDGE CAPTURED (LEC) ===
// Tracks whether the line moved in your favor after signal entry.
// LEC > 0 = you captured edge (line moved your way). LEC < 0 = you paid a premium.
function updateLEC() {
  const now = Date.now();
  let changed = false;
  for (const sig of state.signalTracker) {
    if (sig.gameCompleted) continue;
    if (!sig.entryOddsKey) continue; // no odds key recorded
    const hist = state.oddsHistory[sig.entryOddsKey];
    if (!hist || hist.length === 0) continue;
    const entryTs = sig.timestamp;
    const sigIsAway = sig.signalSide === sig.awayTeam;
    const entryML = sig.marketOdds;
    // Find odds ~5 min after entry
    if (!sig.lec5minOdds && (now - entryTs) >= 300000) {
      const snap5 = hist.find(h => h.ts >= entryTs + 240000 && h.ts <= entryTs + 420000);
      if (snap5) {
        const postML = sigIsAway ? snap5.awayML : snap5.homeML;
        sig.lec5minOdds = postML;
        sig.lec5min = entryML - postML; // positive = line moved in your favor (you got better odds)
        changed = true;
      }
    }
    // Find odds ~10 min after entry
    if (!sig.lec10minOdds && (now - entryTs) >= 600000) {
      const snap10 = hist.find(h => h.ts >= entryTs + 540000 && h.ts <= entryTs + 720000);
      if (snap10) {
        const postML = sigIsAway ? snap10.awayML : snap10.homeML;
        sig.lec10minOdds = postML;
        sig.lec10min = entryML - postML;
        changed = true;
      }
    }
  }
  if (changed) {
    localStorage.setItem('signalTracker', JSON.stringify(state.signalTracker));
  }
}

function matchOdds(aAbbr,hAbbr,aFull,hFull){
  if(Object.keys(oddsCache).length===0){console.log('[Odds] Cache empty when matching',aFull,'@',hFull);return null;}
  // Strategy 1: Exact full-name match (most reliable)
  for(const k of Object.keys(oddsCache)){
    const g=oddsCache[k];
    if(!g.home||!g.away)continue;
    if(g.home.toUpperCase()===hFull.toUpperCase()&&g.away.toUpperCase()===aFull.toUpperCase())return g;
  }
  // Strategy 2: Abbreviation match via TEAM_MAP (handles LA Clippers vs Los Angeles Clippers etc.)
  for(const k of Object.keys(oddsCache)){
    const g=oddsCache[k];
    if(!g.home||!g.away)continue;
    const gHA=(TEAM_MAP[g.home]||'').toUpperCase(), gAA=(TEAM_MAP[g.away]||'').toUpperCase();
    if(gHA&&gAA&&gHA===hAbbr.toUpperCase()&&gAA===aAbbr.toUpperCase())return g;
  }
  // Strategy 3: Full name contains (one direction)  require BOTH teams match
  for(const k of Object.keys(oddsCache)){
    const g=oddsCache[k];
    if(!g.home||!g.away)continue;
    const gH=g.home.toUpperCase(),gA=g.away.toUpperCase();
    const hUp=hFull.toUpperCase(),aUp=aFull.toUpperCase();
    const hM=gH.includes(hUp)||hUp.includes(gH);
    const aM=gA.includes(aUp)||aUp.includes(gA);
    if(hM&&aM)return g;
  }
  // Strategy 4: Match on BOTH first word AND last word (prevents Alabama vs Alabama A&M)
  for(const k of Object.keys(oddsCache)){
    const g=oddsCache[k];
    if(!g.home||!g.away)continue;
    const gHW=g.home.toUpperCase().split(' '),gAW=g.away.toUpperCase().split(' ');
    const hW=hFull.toUpperCase().split(' '),aW=aFull.toUpperCase().split(' ');
    const hFirst=hW[0],hLast=hW[hW.length-1],aFirst=aW[0],aLast=aW[aW.length-1];
    const gHFirst=gHW[0],gHLast=gHW[gHW.length-1],gAFirst=gAW[0],gALast=gAW[gAW.length-1];
    const hM=(gHFirst===hFirst&&gHLast===hLast)||(gHW.includes(hAbbr));
    const aM=(gAFirst===aFirst&&gALast===aLast)||(gAW.includes(aAbbr));
    if(hM&&aM)return g;
  }
  console.log('[Odds] No match for',aFull,'@',hFull,'| cache has',Object.keys(oddsCache).length,'games');
  return null;
}
function buildOddsHTML(aAbbr,hAbbr,aFull,hFull,espnOdds){
  // Try the-odds-api first, then fall back to ESPN's built-in odds
  let o=matchOdds(aAbbr,hAbbr,aFull,hFull);
  let src='';
  if(!o&&espnOdds){
    // Build odds object from ESPN's moneyline/pointSpread data
    const ml=espnOdds.moneyline||{};
    const ps=espnOdds.pointSpread||{};
    const hMLv=ml.home?.close?.odds, aMLv=ml.away?.close?.odds;
    if(hMLv&&aMLv){
      const prov=espnOdds.provider?.name||'ESPN';
      o={homeML:parseInt(hMLv),awayML:parseInt(aMLv),book:prov,
         homeSpread:ps.home?.close?.line?parseFloat(ps.home.close.line):null,
         awaySpread:ps.away?.close?.line?parseFloat(ps.away.close.line):null,
         homeSpreadPrice:ps.home?.close?.odds?parseInt(ps.home.close.odds):null,
         awaySpreadPrice:ps.away?.close?.odds?parseInt(ps.away.close.odds):null};
      src=' espn-fallback';
    }
  }
  if(!o)return '';
  const aML=(o.awayML>0?'+':'')+o.awayML;const hML=(o.homeML>0?'+':'')+o.homeML;
  const aIP=impliedProb(aML),hIP=impliedProb(hML);
  let html='<div class="odds-row"><span><span class="odds-label">'+aAbbr+' ML</span> <span class="odds-val '+oddsClass(aML)+'">'+aML+'</span> <span class="odds-implied">('+aIP+'%)</span></span><span class="odds-src">'+o.book+src+'</span><span><span class="odds-implied">('+hIP+'%)</span> <span class="odds-val '+oddsClass(hML)+'">'+hML+'</span> <span class="odds-label">'+hAbbr+' ML</span></span></div>';
  // Spread row
  if(o.awaySpread!==null&&o.awaySpread!==undefined){
    const aSp=o.awaySpread,hSp=o.homeSpread;
    const aSpStr=(aSp>0?'+':'')+aSp,hSpStr=(hSp>0?'+':'')+hSp;
    const aSpP=o.awaySpreadPrice,hSpP=o.homeSpreadPrice;
    const aPrice=aSpP?' ('+(aSpP>0?'+':'')+aSpP+')':'';
    const hPrice=hSpP?' ('+(hSpP>0?'+':'')+hSpP+')':'';
    html+='<div class="odds-row" style="margin-top:2px;"><span><span class="odds-label">'+aAbbr+' SPR</span> <span class="odds-val '+(aSp<0?'fav':'dog')+'">'+aSpStr+'</span><span class="odds-implied">'+aPrice+'</span></span><span class="odds-src">'+o.book+src+'</span><span><span class="odds-implied">'+hPrice+'</span> <span class="odds-val '+(hSp<0?'fav':'dog')+'">'+hSpStr+'</span> <span class="odds-label">'+hAbbr+' SPR</span></span></div>';
  }
  return html;
}

function getESPNUrl(){return isNCAA() ? 'https://site.api.espn.com/apis/site/v2/sports/basketball/mens-college-basketball/scoreboard' : 'https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard';}

// ==================== STAR DATABASE (23+ PPG) ====================
const DEFAULT_STARS = [
  { name: "Luka Doncic", team: "LAL", ppg: 32.5 },
  { name: "Shai Gilgeous-Alexander", team: "OKC", ppg: 31.8 },
  { name: "Anthony Edwards", team: "MIN", ppg: 29.6 },
  { name: "Jaylen Brown", team: "BOS", ppg: 29.2 },
  { name: "Tyrese Maxey", team: "PHI", ppg: 29.1 },
  { name: "Nikola Jokic", team: "DEN", ppg: 28.8 },
  { name: "Donovan Mitchell", team: "CLE", ppg: 28.5 },
  { name: "Kawhi Leonard", team: "LAC", ppg: 28.0 },
  { name: "Lauri Markkanen", team: "UTA", ppg: 26.7 },
  { name: "Jalen Brunson", team: "NYK", ppg: 26.7 },
  { name: "Kevin Durant", team: "HOU", ppg: 25.9 },
  { name: "Jamal Murray", team: "DEN", ppg: 25.5 },
  { name: "Cade Cunningham", team: "DET", ppg: 25.3 },
  { name: "Devin Booker", team: "PHX", ppg: 24.7 },
  { name: "Michael Porter Jr.", team: "BKN", ppg: 24.6 },
  { name: "James Harden", team: "LAC", ppg: 24.5 },
  { name: "Deni Avdija", team: "POR", ppg: 24.4 },
  { name: "Victor Wembanyama", team: "SAS", ppg: 24.2 },
  { name: "Pascal Siakam", team: "IND", ppg: 23.9 },
  { name: "Keyonte George", team: "UTA", ppg: 23.8 },
  { name: "Jalen Johnson", team: "ATL", ppg: 23.0 },
  { name: "Norman Powell", team: "MIA", ppg: 22.9 },
  { name: "Trey Murphy III", team: "NOP", ppg: 21.9 },
  { name: "Julius Randle", team: "MIN", ppg: 21.9 },
  { name: "Zion Williamson", team: "NOP", ppg: 21.8 },
];

const TEAM_MAP = {
  'Atlanta Hawks':'ATL','Boston Celtics':'BOS','Brooklyn Nets':'BKN','Charlotte Hornets':'CHA',
  'Chicago Bulls':'CHI','Cleveland Cavaliers':'CLE','Dallas Mavericks':'DAL','Denver Nuggets':'DEN',
  'Detroit Pistons':'DET','Golden State Warriors':'GSW','Houston Rockets':'HOU','Indiana Pacers':'IND',
  'LA Clippers':'LAC','Los Angeles Clippers':'LAC','Los Angeles Lakers':'LAL','Memphis Grizzlies':'MEM',
  'Miami Heat':'MIA','Milwaukee Bucks':'MIL','Minnesota Timberwolves':'MIN','New Orleans Pelicans':'NOP',
  'New York Knicks':'NYK','Oklahoma City Thunder':'OKC','Orlando Magic':'ORL','Philadelphia 76ers':'PHI',
  'Phoenix Suns':'PHX','Portland Trail Blazers':'POR','Sacramento Kings':'SAC','San Antonio Spurs':'SAS',
  'Toronto Raptors':'TOR','Utah Jazz':'UTA','Washington Wizards':'WAS',
};
function shortName(n) { return TEAM_MAP[n] || n.split(' ').pop().substring(0,3).toUpperCase(); }
function teamDisplay(abbr, fullName) { return abbr; }
function teamDisplayShort(abbr, fullName) { return abbr; }
function teamLogoImg(logoUrl, size) { if (!logoUrl) return ''; return `<img src="${logoUrl}" alt="" onerror="this.style.display='none'" style="width:${size||20}px;height:${size||20}px;object-fit:contain;vertical-align:middle;">`; }
function gameLinksHTML(espnLink, leaguePassLink) {
  let links = [];
  if (espnLink) links.push(`<a href="${espnLink}" target="_blank" class="watch-link">ESPN</a>`);
  if (leaguePassLink) links.push(`<a href="${leaguePassLink}" target="_blank" class="watch-link">League Pass</a>`);
  if (!isNCAA()) links.push(`<a href="https://sports.qq.com/nba/" target="_blank" class="watch-link">WATCH </a>`);
  return links.length ? `<div class="game-links">${links.join('')}</div>` : '';
}

// ==================== STATE ====================
let state = {
  betLog: JSON.parse(localStorage.getItem('betLog') || '[]'),
  bankroll: JSON.parse(localStorage.getItem('bankroll') || '{"start":0,"current":0}'),
  stars: JSON.parse(localStorage.getItem('starPlayers') || 'null') || DEFAULT_STARS,
  autoRefresh: false, refreshTimer: null, countdownTimer: null,
  quarterAlerts: JSON.parse(localStorage.getItem('quarterAlerts') || '[]'),
  lastKnownPeriods: {}, prevTeamData: {},
  scoreHistory: {},  // { gameId: [ {ts, aS, hS}, ... ] }  tracks score over time for momentum
  errorCount: 0, consecutiveErrors: 0,
  signalFirstSeen: {},
  favorites: JSON.parse(localStorage.getItem('favorites') || '[]'),
  signalHistory: JSON.parse(localStorage.getItem('signalHistory') || '[]'),
  signalTracker: JSON.parse(localStorage.getItem('signalTracker') || '[]'),
  oddsHistory: JSON.parse(localStorage.getItem('oddsHistory') || '{}'), // { gameKey: [{ts, homeML, awayML}, ...] }
  nearMisses: JSON.parse(localStorage.getItem('nearMisses') || '[]'), // counterfactual: level-1 signals
};

// ==================== INIT ====================
const _bsEl = document.getElementById('bankroll-start');
const _bcEl = document.getElementById('bankroll-current');
if (_bsEl) _bsEl.value = state.bankroll.start || '';
if (_bcEl) _bcEl.value = state.bankroll.current || '';
renderBetLog(); renderStarDB(); renderQtrAlerts(); loadBankrollSettings();

// ==================== TEAM PROFILES CACHE ====================
// Full team data: record, standing, streak + offense/defense stats from ESPN statistics API
let teamProfileCache = {};
let teamProfileLastFetch = 0;
let _teamProfileMode = ''; // track mode changes

// Top 3 scorers per team by season PPG  { teamAbbr: [{name, ppg}] }
let teamScorerCache = {};
let teamScorerLastFetch = 0;
async function fetchTeamScorers() {
  const now = Date.now();
  if (now - teamScorerLastFetch < 60 * 60 * 1000 && Object.keys(teamScorerCache).length > 0) return;
  if (isNCAA()) {
    // NCAA: build from ncaaStarCache (already fetched per-team leaders)
    const byTeam = {};
    ncaaStarCache.forEach(s => {
      if (!byTeam[s.team]) byTeam[s.team] = [];
      byTeam[s.team].push({ name: s.name, ppg: s.ppg });
    });
    for (const t in byTeam) {
      byTeam[t].sort((a, b) => b.ppg - a.ppg);
      byTeam[t] = byTeam[t].slice(0, 3);
    }
    teamScorerCache = byTeam;
    teamScorerLastFetch = now;
    console.log(`[TeamScorers] NCAA: Cached top 3 scorers for ${Object.keys(byTeam).length} teams from ncaaStarCache`);
    return;
  }
  try {
    const res = await fetch('https://site.web.api.espn.com/apis/common/v3/sports/basketball/nba/statistics/byathlete?season=2025&limit=500&sort=offensive.avgPoints', { signal: AbortSignal.timeout(8000) });
    if (!res.ok) return;
    const data = await res.json();
    const byTeam = {};
    (data.athletes || []).forEach(a => {
      const name = a.athlete?.displayName || '';
      const team = a.athlete?.teamShortName || '';
      const ppg = parseFloat(a.categories?.[1]?.values?.[0]) || 0;
      if (!name || !team || ppg <= 0) return;
      if (!byTeam[team]) byTeam[team] = [];
      byTeam[team].push({ name, ppg });
    });
    for (const t in byTeam) {
      byTeam[t].sort((a, b) => b.ppg - a.ppg);
      byTeam[t] = byTeam[t].slice(0, 3);
    }
    teamScorerCache = byTeam;
    teamScorerLastFetch = now;
    console.log(`[TeamScorers] NBA: Cached top 3 scorers for ${Object.keys(byTeam).length} teams`);
  } catch (e) {
    console.warn('[TeamScorers] Fetch error:', e);
  }
}

async function fetchTeamProfiles() {
  const now = Date.now();
  const mode = isNCAA() ? 'ncaab' : 'nba';
  // Refresh every 30 min, or immediately if mode changed
  if (mode === _teamProfileMode && now - teamProfileLastFetch < 30 * 60 * 1000 && Object.keys(teamProfileCache).length > 0) return;
  _teamProfileMode = mode;
  try {
    const league = isNCAA() ? 'mens-college-basketball' : 'nba';

    // Step 1: Get team IDs. NBA: all 30. NCAA: today's scoreboard teams.
    let teamIds = [];
    if (isNCAA()) {
      const sbRes = await fetch(`https://site.api.espn.com/apis/site/v2/sports/basketball/${league}/scoreboard`);
      if (!sbRes.ok) return;
      const sbData = await sbRes.json();
      const idSet = new Set();
      for (const ev of (sbData.events || [])) {
        for (const c of (ev.competitions?.[0]?.competitors || [])) {
          if (c.team?.id) idSet.add(c.team.id);
        }
      }
      teamIds = [...idSet];
    } else {
      teamIds = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30];
    }

    // Step 2: Fetch team info + statistics in parallel
    const teamFetches = teamIds.map(id =>
      fetch(`https://site.api.espn.com/apis/site/v2/sports/basketball/${league}/teams/${id}`)
        .then(r => r.ok ? r.json() : null).catch(() => null)
    );
    const statFetches = teamIds.map(id =>
      fetch(`https://site.api.espn.com/apis/site/v2/sports/basketball/${league}/teams/${id}/statistics`)
        .then(r => r.ok ? r.json() : null).catch(() => null)
    );
    const [teamResults, statResults] = await Promise.all([
      Promise.all(teamFetches),
      Promise.all(statFetches)
    ]);

    for (let i = 0; i < teamIds.length; i++) {
      const tData = teamResults[i];
      const sData = statResults[i];
      if (!tData?.team) continue;
      parseTeamProfile(tData.team, sData);
    }

    teamProfileLastFetch = now;
    console.log(`[TeamProfiles] Cached ${Object.keys(teamProfileCache).length} teams with full stats`);
  } catch (e) {
    console.warn('[TeamProfiles] Fetch error:', e);
  }
}

function parseTeamProfile(team, statsData) {
  const abbr = team.abbreviation;
  if (!abbr) return;
  const rec = team.record || {};
  const items = rec.items || [];
  const total = items.find(i => i.type === 'total') || {};
  const home = items.find(i => i.type === 'home') || {};
  const road = items.find(i => i.type === 'road') || {};
  const getStat = (item, name) => { const s = (item.stats || []).find(x => x.name === name); return s ? s.value : null; };

  // Parse statistics categories
  const cats = statsData?.results?.stats?.categories || [];
  const offCat = cats.find(c => c.displayName === 'Offensive') || {};
  const defCat = cats.find(c => c.displayName === 'Defensive') || {};
  const genCat = cats.find(c => c.displayName === 'General') || {};
  const getS = (cat, name) => { const s = (cat.stats || []).find(x => x.name === name); return s ? parseFloat(s.displayValue) : null; };

  teamProfileCache[abbr] = {
    // Record
    seed: getStat(total, 'playoffSeed'),
    standing: team.standingSummary || '',
    streak: getStat(total, 'streak'),
    ppg: getStat(total, 'avgPointsFor'),
    oppg: getStat(total, 'avgPointsAgainst'),
    diff: getStat(total, 'differential'),
    homeRec: home.summary || '',
    roadRec: road.summary || '',
    winPct: getStat(total, 'winPercent'),
    // Offense
    fgPct: getS(offCat, 'fieldGoalPct'),
    threePct: getS(offCat, 'threePointPct') || getS(offCat, 'threePointFieldGoalPct'),
    ftPct: getS(offCat, 'freeThrowPct'),
    avgPts: getS(offCat, 'avgPoints'),
    avg3PM: getS(offCat, 'avgThreePointFieldGoalsMade'),
    avg3PA: getS(offCat, 'avgThreePointFieldGoalsAttempted'),
    avgAst: getS(offCat, 'avgAssists'),
    avgTO: getS(offCat, 'avgTurnovers'),
    avgOReb: getS(offCat, 'avgOffensiveRebounds'),
    avgFTM: getS(offCat, 'avgFreeThrowsMade'),
    avgFTA: getS(offCat, 'avgFreeThrowsAttempted'),
    // Defense
    avgDReb: getS(defCat, 'avgDefensiveRebounds'),
    avgBlk: getS(defCat, 'avgBlocks'),
    avgStl: getS(defCat, 'avgSteals'),
    // General
    avgReb: getS(genCat, 'avgRebounds'),
    astToRatio: getS(genCat, 'assistTurnoverRatio'),
    avgFouls: getS(genCat, 'avgFouls'),
  };
}

function teamProfileHTML(abbr, homeAway, logoUrl) {
  const p = teamProfileCache[abbr];
  if (!p) return '';
  const streakStr = p.streak != null ? (p.streak > 0 ? 'W' + Math.round(p.streak) : 'L' + Math.abs(Math.round(p.streak))) : '';
  const streakColor = p.streak > 0 ? 'var(--green)' : 'var(--red)';
  const seedStr = p.seed != null ? '#' + Math.round(p.seed) : '';
  const ctxRec = homeAway === 'home' ? (p.homeRec || '') : (p.roadRec || '');

  const chips = [];
  if (seedStr) chips.push(`<span style="font-weight:700;color:var(--accent);">${seedStr}</span>`);
  if (ctxRec) chips.push(`<span>${homeAway === 'home' ? 'H' : 'R'}:${ctxRec}</span>`);
  if (streakStr) chips.push(`<span style="font-weight:700;color:${streakColor};">${streakStr}</span>`);

  return `<div style="font-size:9px;color:var(--text-muted);margin-top:1px;">
    <span class="tp-inline" onclick="openTeamProfile('${abbr}','${homeAway}','${(logoUrl||'').replace(/'/g,'')}')">${chips.join(' <span style="opacity:0.4;"></span> ')}</span>
  </div>`;
}

function openTeamProfile(abbr, homeAway, logoUrl) {
  const p = teamProfileCache[abbr];
  if (!p) return;
  const diff = p.diff != null ? (p.diff > 0 ? '+' + p.diff.toFixed(1) : p.diff.toFixed(1)) : '';
  const diffColor = p.diff > 0 ? 'var(--green)' : p.diff < 0 ? 'var(--red)' : 'var(--text-muted)';

  const row = (label, val, color) => `<div class="tp-row"><span class="tp-label">${label}</span><span class="tp-val"${color ? ' style="color:'+color+'"' : ''}>${val}</span></div>`;

  let html = `<div class="tp-modal">
    <div class="tp-modal-header">
      <h3>${logoUrl ? '<img src="'+logoUrl+'" style="width:24px;height:24px;object-fit:contain;">' : ''}${abbr}</h3>
      <button class="tp-modal-close" onclick="this.closest('.tp-modal-overlay').classList.remove('active')">&times;</button>
    </div>`;

  if (p.standing) html += `<div style="font-size:11px;color:var(--accent);font-weight:600;margin-bottom:8px;">${p.standing}</div>`;

  // Record
  html += `<div class="tp-section"><div class="tp-section-title">Record</div>`;
  if (p.homeRec) html += row('Home', p.homeRec);
  if (p.roadRec) html += row('Road', p.roadRec);
  if (p.diff != null) html += row('Point Diff', diff, diffColor);
  html += `</div>`;

  // Offense
  html += `<div class="tp-section"><div class="tp-section-title">Offense</div>`;
  if (p.avgPts != null) html += row('PPG', p.avgPts);
  if (p.fgPct != null) html += row('FG%', p.fgPct + '%');
  if (p.threePct != null) html += row('3PT%', p.threePct + '%' + (p.avg3PM != null ? ' (' + p.avg3PM.toFixed(1) + '/' + p.avg3PA.toFixed(1) + ')' : ''));
  if (p.ftPct != null) html += row('FT%', p.ftPct + '%');
  if (p.avgAst != null) html += row('Assists', p.avgAst);
  if (p.avgTO != null) html += row('Turnovers', p.avgTO);
  if (p.astToRatio != null) html += row('AST/TO', p.astToRatio);
  html += `</div>`;

  // Defense
  html += `<div class="tp-section"><div class="tp-section-title">Defense</div>`;
  if (p.oppg != null) html += row('Opp PPG', p.oppg.toFixed(1));
  if (p.avgReb != null) html += row('Rebounds', p.avgReb);
  if (p.avgOReb != null) html += row('Off Reb', p.avgOReb);
  if (p.avgDReb != null) html += row('Def Reb', p.avgDReb);
  if (p.avgStl != null) html += row('Steals', p.avgStl);
  if (p.avgBlk != null) html += row('Blocks', p.avgBlk);
  html += `</div>`;

  // General
  html += `<div class="tp-section"><div class="tp-section-title">General</div>`;
  if (p.avgFouls != null) html += row('Fouls/Game', p.avgFouls);
  if (p.avgReb != null) html += row('Total Reb', p.avgReb);
  html += `</div></div>`;

  // Create or reuse overlay
  let overlay = document.getElementById('tp-modal-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'tp-modal-overlay';
    overlay.className = 'tp-modal-overlay';
    overlay.addEventListener('click', function(e) { if (e.target === overlay) overlay.classList.remove('active'); });
    document.body.appendChild(overlay);
  }
  overlay.innerHTML = html;
  overlay.classList.add('active');
}

// Kill browser notifications permanently  we use in-app toasts only
if (window.Notification) { window.Notification = function(){}; window.Notification.permission = 'denied'; window.Notification.requestPermission = function(){ return Promise.resolve('denied'); }; }

// In-app toast notification system
let notifiedSignals = new Set(JSON.parse(localStorage.getItem('notifiedSignals') || '[]'));
function sendSignalNotification(title, body, gameId, signalType) {
  // No popups  signals show on chips and game cards only
  const key = gameId + '_' + signalType + '_' + new Date().getHours();
  if (notifiedSignals.has(key)) return;
  notifiedSignals.add(key);
  if (notifiedSignals.size > 200) notifiedSignals = new Set([...notifiedSignals].slice(-100));
  localStorage.setItem('notifiedSignals', JSON.stringify([...notifiedSignals]));
  // Play pleasant chime for new signals
  if (signalType.startsWith('star_')) playAlertSound('coil');
  else if (signalType.startsWith('3ptfragile')) playAlertSound('hot3pt');
}

// ==================== TABS ====================
function switchTab(t) {
  document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(x => x.classList.remove('active'));
  document.getElementById('tab-'+t).classList.add('active');
  document.getElementById('content-'+t).classList.add('active');
}

// ==================== SIGNAL CHIP CLICK-TO-EXPAND ====================
function toggleSignalDetail(type) {
  const panel = document.getElementById('chip-detail-' + type);
  if (!panel) return;

  // Close all other panels first
  document.querySelectorAll('.chip-detail-panel.active').forEach(p => {
    if (p.id !== 'chip-detail-' + type) p.classList.remove('active');
  });

  // Toggle this panel
  const isOpen = panel.classList.contains('active');
  if (isOpen) {
    panel.classList.remove('active');
    return;
  }

  // Build panel content from stored signal games
  const games = window._signalGames ? window._signalGames[type] : [];
  const labels = { 'star': 'Star Coil', 'starcoilplus': 'Star Coil+', 'combined': 'Combined Edge', '3ptfragile': '3PT Fragile' };

  if (!games || games.length === 0) {
    panel.innerHTML = `<div class="chip-detail-header">${labels[type] || type} Games</div><div class="chip-detail-empty">No active ${labels[type] || ''} signals right now</div>`;
  } else {
    const periodLabel = (per) => isNCAA() ? (per <= 2 ? `H${per}` : `OT${per-2}`) : `Q${per}`;
    panel.innerHTML = `<div class="chip-detail-header">${labels[type] || type}  ${games.length} game${games.length>1?'s':''}</div>` +
      games.map(g => {
        const truncDetail = g.sigDetail && g.sigDetail.length > 120 ? g.sigDetail.substring(0, 120) + '...' : (g.sigDetail || '');
        const eid = g.eventId || '';
        return `<div class="chip-detail-item chip-detail-clickable" onclick="scrollToGame('${eid}')" title="Click to jump to game">
          <div class="chip-detail-game">${g.gameFull || g.game} <span style="font-size:9px;color:var(--accent);margin-left:4px;"> go</span></div>
          <div class="chip-detail-score">${g.aScore} - ${g.hScore} | ${periodLabel(g.per)} ${g.clk}</div>
          <div class="chip-detail-sig">${truncDetail}</div>
        </div>`;
      }).join('');
  }

  panel.classList.add('active');
}

// Scroll to a game card when clicking from signal dropdown
function scrollToGame(eventId) {
  if (!eventId) return;
  // Close all chip detail panels
  document.querySelectorAll('.chip-detail-panel.active').forEach(p => p.classList.remove('active'));
  // Find the game card
  const card = document.querySelector(`.game-card[data-game-id="${eventId}"]`);
  if (card) {
    // Smooth scroll to the card
    card.scrollIntoView({ behavior: 'smooth', block: 'center' });
    // Flash highlight effect
    card.classList.add('signal-highlight-flash');
    setTimeout(() => card.classList.remove('signal-highlight-flash'), 2500);
  }
}

// Close signal detail panels when clicking outside
document.addEventListener('click', function(e) {
  if (!e.target.closest('.signal-chip-clickable')) {
    document.querySelectorAll('.chip-detail-panel.active').forEach(p => p.classList.remove('active'));
  }
});

// ==================== AUTO REFRESH ====================
function toggleAutoRefresh() {
  state.autoRefresh = !state.autoRefresh;
  const btn = document.getElementById('autoRefreshBtn'), dot = document.getElementById('autoRefreshDot'), lbl = document.getElementById('autoRefreshLabel');
  if (state.autoRefresh) {
    btn.textContent = 'Stop'; btn.className = 'btn btn-sm btn-red'; dot.className = 'dot'; lbl.textContent = 'ON';
    document.getElementById('liveIndicator').style.display = 'inline-flex';
    fetchESPNScoreboard(); startCountdown();
  } else {
    btn.textContent = 'Start'; btn.className = 'btn btn-sm btn-green'; dot.className = 'dot off'; lbl.textContent = 'OFF';
    document.getElementById('liveIndicator').style.display = 'none';
    clearInterval(state.refreshTimer); clearInterval(state.countdownTimer);
    if (_bgWorker) { _bgWorker.postMessage({ cmd: 'stop' }); _bgWorker.terminate(); _bgWorker = null; }
    document.getElementById('countdownFill').style.width = '100%';
  }
}
// === BACKGROUND-SAFE TIMER ===
// Browsers throttle setInterval in background tabs (60s+ delay).
// Use a Web Worker blob to keep the timer alive even when tab is hidden.
let _bgWorker = null;
function _createBgWorker() {
  if (_bgWorker) _bgWorker.terminate();
  try {
    const blob = new Blob([`
      let iv = 30000;
      let tid = null;
      self.onmessage = function(e) {
        if (e.data.cmd === 'start') { iv = e.data.interval || 30000; clearInterval(tid); tid = setInterval(()=>self.postMessage('tick'), iv); self.postMessage('tick'); }
        if (e.data.cmd === 'stop') { clearInterval(tid); tid = null; }
      };
    `], { type: 'application/javascript' });
    _bgWorker = new Worker(URL.createObjectURL(blob));
    _bgWorker.onmessage = function() { if (state.autoRefresh) fetchESPNScoreboard(); };
    return true;
  } catch(e) { console.warn('[BG Worker] Not available, falling back to setInterval'); return false; }
}

function startCountdown() {
  const iv = parseInt(document.getElementById('refreshInterval').value) * 1000;
  let rem = iv;
  clearInterval(state.refreshTimer); clearInterval(state.countdownTimer);
  // Try Web Worker for background-safe timer; fall back to setInterval
  const workerOk = _createBgWorker();
  if (workerOk) {
    _bgWorker.postMessage({ cmd: 'start', interval: iv });
  } else {
    state.refreshTimer = setInterval(() => { if (state.autoRefresh) { fetchESPNScoreboard(); } }, iv);
  }
  state.countdownTimer = setInterval(() => { rem -= 1000; if (rem <= 0) rem = iv; document.getElementById('countdownFill').style.width = Math.max(0, rem/iv*100)+'%'; }, 1000);
}
function updateRefreshInterval() { if (state.autoRefresh) startCountdown(); }

// === VISIBILITY CHANGE  catch up when tab wakes up ===
document.addEventListener('visibilitychange', function() {
  if (document.visibilityState === 'visible' && state.autoRefresh) {
    console.log('[Visibility] Tab visible  immediate refresh to catch missed signals');
    fetchESPNScoreboard();
  }
});

// ==================== PACE HELPERS ====================
function getQ1Expected(ppg) { return ppg * 0.25; }
function getHalfExpected(ppg) { return ppg * 0.5; }
function getExpectedByTime(ppg, mins) { return ppg * (mins / getTotalGameMinutes()); }

// ==================== SIGNAL URGENCY ====================
function getUrgency(period, clock) {
  const gMins = getElapsedMinutes(period, clock);
  const pct = gMins / getTotalGameMinutes();
  if (pct < 0.30) return { level: 'DEVELOPING', mult: 0.70, pct, color: 'var(--text-muted)', icon: '' };
  if (pct < 0.60) return { level: 'PRIME', mult: 1.00, pct, color: 'var(--green)', icon: '' };
  if (pct < 0.85) return { level: 'ACT_NOW', mult: 0.85, pct, color: 'var(--orange)', icon: '' };
  return { level: 'CLOSING', mult: 0.50, pct, color: 'var(--red)', icon: '' };
}

// ==================== BET RECOMMENDATION ENGINE ====================
// Uses live margin + time remaining to decide: ML, Spread, or Watch
// Signal detection is unchanged  this only runs AFTER a signal fires
function getRecommendation(awayScore, homeScore, awayAbbr, homeAbbr, period, clock, signalLevel) {
  const margin = Math.abs(homeScore - awayScore);
  const tied = homeScore === awayScore;
  const trailingTeam = tied ? null : (awayScore < homeScore ? awayAbbr : homeAbbr);
  const leadingTeam = tied ? null : (awayScore < homeScore ? homeAbbr : awayAbbr);

  // Calculate time remaining (mode-aware: NBA 48min/4Q, NCAA 40min/2H)
  const _perLen = getPeriodLength();
  const clockMin = parseFloat(clock?.split(':')[0] || _perLen);
  const clockSec = parseFloat(clock?.split(':')[1] || 0);
  const gameMinElapsed = (period - 1) * _perLen + (_perLen - clockMin - clockSec / 60);
  const gameMinRemaining = Math.max(0, getTotalGameMinutes() - gameMinElapsed);

  // Default: WATCH
  let rec = { type: 'WATCH', side: null, spreadLine: '', units: 0, reasoning: '', margin: margin, minRemaining: Math.round(gameMinRemaining) };

  // OT or <3 min left  always WATCH
  if (period >= getOTPeriod()) {
    rec.reasoning = 'Overtime  too volatile for mean reversion plays.';
    return rec;
  }
  if (gameMinRemaining < 3) {
    rec.reasoning = 'Under 3 min remaining  not enough time for reversion.';
    return rec;
  }

  // Only generate actionable recs for strong signals (level 2)
  if (signalLevel < 2) {
    rec.reasoning = 'Developing signal  monitor, no action yet.';
    return rec;
  }

  // Determine base recommendation from margin
  let type, units;
  if (margin <= 5) {
    type = 'ML'; units = 1.5;
  } else if (margin <= 15) {
    type = 'SPREAD'; units = margin <= 10 ? 1.5 : 1;
  } else if (margin <= 20) {
    type = 'SPREAD'; units = 1;
  } else {
    // 21+ pts  too far gone
    rec.reasoning = `Down ${margin} pts  margin too large for mean reversion play.`;
    return rec;
  }

  // Time adjustment: <6 min remaining  downgrade one tier
  if (gameMinRemaining < 6) {
    if (type === 'ML') {
      type = 'SPREAD'; // ML  SPREAD
    } else if (margin > 15) {
      // cautious SPREAD  WATCH
      rec.reasoning = `Down ${margin} with only ${Math.round(gameMinRemaining)} min left  not enough time.`;
      return rec;
    }
    units = Math.min(units, 1); // cap units when time is short
  }

  // Build the recommendation
  const side = tied ? awayAbbr : trailingTeam; // if tied, pick away team as default
  const spreadLine = type === 'SPREAD' ? `+${margin}` : '';
  const timeStr = Math.round(gameMinRemaining);

  let reasoning = '';
  if (type === 'ML') {
    reasoning = `${side} only down ${margin} pts with ${timeStr} min left  close enough for ML.`;
    if (tied) reasoning = `Game tied with ${timeStr} min left  ML play.`;
  } else {
    reasoning = `${side} down ${margin} with ${timeStr} min left  take the spread for mean reversion.`;
    if (margin > 15) reasoning = `${side} down ${margin}  cautious spread play, large deficit.`;
  }

  rec = { type, side, spreadLine, units, reasoning, margin, minRemaining: timeStr };
  return rec;
}

// === TIME HELPERS (NBA / NCAA) ===
function getTotalGameMinutes() { return isNCAA() ? 40 : 48; }
function getPeriodLength() { return isNCAA() ? 20 : 12; }
function getRegulationPeriods() { return isNCAA() ? 2 : 4; }
function getOTPeriod() { return isNCAA() ? 3 : 5; }
function getElapsedMinutes(per, clk) {
  const perLen = getPeriodLength();
  const parts = (clk || '0:00').split(':');
  const cM = parseFloat(parts[0]) || 0;
  const cS = parseFloat(parts[1]) || 0;
  const clockRemaining = cM + cS / 60;
  return (per - 1) * perLen + (perLen - clockRemaining);
}
function getGamePct(per, clk) {
  return Math.min(getElapsedMinutes(per, clk) / getTotalGameMinutes(), 1);
}

// ==================== SCORE MOMENTUM / DAMAGE LOCKED ====================
// Tracks score snapshots over time to detect if a deficit is growing/stable (damage locked in)
// Anti-bias: requires minimum time span (not just snapshot count), score must change, game must be 15+ min in
function trackScoreMomentum(gameId, aS, hS) {
  if (!state.scoreHistory[gameId]) state.scoreHistory[gameId] = [];
  const hist = state.scoreHistory[gameId];
  const now = Date.now();
  // Only record if 25+ seconds since last snapshot (avoid duplicates from rapid refreshes)
  if (hist.length === 0 || (now - hist[hist.length-1].ts) >= 25000) {
    hist.push({ ts: now, aS, hS });
  }
  // Keep last 15 snapshots (~6-7 min of data at 30s intervals)
  if (hist.length > 15) hist.splice(0, hist.length - 15);
}

// Analyze if the score deficit for a given team is locked in (stable or growing)
// Anti-bias checks:
//   1. Minimum TIME SPAN between first & last snapshot (not just count)  avoids timeout/dead-ball bias
//   2. Score must have changed  avoids frozen-game false positives
//   3. Called only after 15+ game minutes (checked by caller via gMins)
// Returns: { locked, trend, deficitNow, deficitThen, deficitChange, snapshots, timeSpanSec, scoreChanged, reason }
function analyzeDamageLocked(gameId, teamSide, minSnapshots, gMins) {
  const hist = state.scoreHistory[gameId];
  const need = minSnapshots || 4;  // bumped from 3 to 4 for more data
  const MIN_TIME_SPAN_MS = 180000; // 3 minutes minimum between first and last snapshot
  const MIN_GAME_MINUTES = 15;     // don't evaluate before mid-Q2

  if (!hist || hist.length < need) return { locked: false, trend: 'unknown', snapshots: hist?.length || 0, reason: `need ${need} snapshots, have ${hist?.length || 0}` };

  // Anti-bias #3: game must be far enough along
  if (gMins && gMins < MIN_GAME_MINUTES) return { locked: false, trend: 'unknown', snapshots: hist.length, reason: `game only ${gMins.toFixed(0)} min in (need ${MIN_GAME_MINUTES})` };

  // Use all available snapshots (not just last N) for better signal
  const recent = hist.slice(-Math.max(need, hist.length));
  const first = recent[0];
  const last = recent[recent.length - 1];
  const timeSpanMs = last.ts - first.ts;

  // Anti-bias #1: minimum time span between first and last snapshot
  if (timeSpanMs < MIN_TIME_SPAN_MS) return { locked: false, trend: 'unknown', snapshots: recent.length, timeSpanSec: Math.round(timeSpanMs/1000), reason: `time span ${Math.round(timeSpanMs/1000)}s < ${MIN_TIME_SPAN_MS/1000}s minimum` };

  // Anti-bias #2: score must have changed (at least one team scored)
  const totalScoreFirst = first.aS + first.hS;
  const totalScoreLast = last.aS + last.hS;
  const scoreChanged = totalScoreLast !== totalScoreFirst;
  if (!scoreChanged) return { locked: false, trend: 'unknown', snapshots: recent.length, timeSpanSec: Math.round(timeSpanMs/1000), scoreChanged: false, reason: 'no scoring activity  dead ball or timeout' };

  // Calculate deficit FROM the perspective of the team we're evaluating
  // teamSide: 'away' or 'home'  the team whose star is cold / who is trailing
  const getDeficit = (snap) => {
    // Positive deficit = team is behind. Negative = team is ahead.
    return teamSide === 'away' ? (snap.hS - snap.aS) : (snap.aS - snap.hS);
  };

  const deficitNow = getDeficit(last);
  const deficitThen = getDeficit(first);
  const deficitChange = deficitNow - deficitThen;

  // "Locked" = the team was behind AND the deficit didn't shrink (grew or stayed)
  const isTrailing = deficitNow > 0;
  const deficitStable = deficitChange >= 0; // didn't shrink

  // Check if deficit has been consistently non-shrinking across all snapshots
  // Allow small 2-pt fluctuations (single basket noise) but flag any real comeback attempt
  let consistentlyBehind = true;
  let maxRecovery = 0; // track the biggest single-interval recovery
  for (let i = 1; i < recent.length; i++) {
    const recovery = getDeficit(recent[i-1]) - getDeficit(recent[i]);
    if (recovery > maxRecovery) maxRecovery = recovery;
    if (recovery > 3) {
      consistentlyBehind = false; // deficit shrank by more than 3 pts in one interval = comeback attempt
      break;
    }
  }

  let trend = 'unknown';
  if (deficitChange > 3) trend = 'growing';
  else if (deficitChange >= -2) trend = 'stable';
  else trend = 'shrinking';

  const locked = isTrailing && deficitStable && consistentlyBehind;
  const timeSpanSec = Math.round(timeSpanMs / 1000);

  return { locked, trend, deficitNow, deficitThen, deficitChange, snapshots: recent.length, timeSpanSec, scoreChanged, consistentlyBehind, maxRecovery, reason: locked ? 'deficit stable/growing over ' + timeSpanSec + 's with scoring activity' : (isTrailing ? 'trailing but deficit shrinking or inconsistent' : 'not trailing') };
}

// ==================== CONNECTION STATUS ====================
function setConnStatus(status) {
  const el = document.getElementById('connStatus');
  const dot = document.getElementById('statusDot');
  el.style.display = 'inline';
  if (status === 'ok') { el.textContent = 'Connected'; el.className = 'conn-status conn-ok'; dot.className = 'status-dot live'; state.consecutiveErrors = 0; }
  else if (status === 'error') { el.textContent = 'Error'; el.className = 'conn-status conn-err'; dot.className = 'status-dot error'; state.consecutiveErrors++; state.errorCount++; }
  else { el.textContent = 'Loading...'; el.className = 'conn-status conn-loading'; }
  document.getElementById('errorCount').textContent = state.errorCount;
}

// ==================== QUARTER-END DETECTION ====================
function checkQuarterEnd(gameId, teamAbbr, currentPeriod, pct, made, att, gameLabel) {
  const key = `${gameId}_${teamAbbr}`;
  const prev = state.lastKnownPeriods[key] || 0;
  if (currentPeriod > prev && prev > 0) {
    const p = state.prevTeamData[key];
    if (p) {
      const qM = (parseInt(made)||0) - (p.made||0), qA = (parseInt(att)||0) - (p.att||0);
      const qP = qA > 0 ? (qM/qA*100) : 0;
      if (qP >= 50 && qA >= 4) {
        const a = { id: Date.now()+Math.random(), time: new Date().toLocaleTimeString(), team: teamAbbr, quarter: prev, pct: qP.toFixed(1), made: qM, att: qA, game: gameLabel };
        state.quarterAlerts.unshift(a); localStorage.setItem('quarterAlerts', JSON.stringify(state.quarterAlerts));
        renderQtrAlerts(); showQuarterToast(a);
      }
    }
  }
  state.lastKnownPeriods[key] = currentPeriod;
  state.prevTeamData[key] = { made: parseInt(made)||0, att: parseInt(att)||0, period: currentPeriod };
}

function showQuarterToast(a) {
  // No popup  just update the badge count silently
  const badge = document.getElementById('threept-badge');
  if (state.quarterAlerts.length > 0) { badge.style.display = 'inline'; badge.textContent = state.quarterAlerts.length; }
}

function renderQtrAlerts() {
  const tb = document.getElementById('qtr-alerts-body');
  if (!state.quarterAlerts.length) { tb.innerHTML = '<tr><td colspan="7" class="empty-state">No quarter-end alerts yet.</td></tr>'; document.getElementById('threept-qtr-alerts').textContent = '0'; return; }
  tb.innerHTML = state.quarterAlerts.map(a => { const pLabel = isNCAA() ? (a.quarter <= 2 ? `H${a.quarter}` : `OT`) : `Q${a.quarter}`; return `<tr><td>${a.time}</td><td><strong>${a.team}</strong></td><td>${pLabel}</td><td style="color:var(--red);font-weight:800;">${a.pct}%</td><td>${a.made}/${a.att}</td><td>${a.game}</td><td><button class="btn btn-purple btn-sm" onclick="openLogModal('${a.game}','3PT ${pLabel}','3PT Regression')">Log</button></td></tr>`; }).join('');
  document.getElementById('threept-qtr-alerts').textContent = state.quarterAlerts.length;
}
function clearQtrAlerts() { if(confirm('Clear all?')) { state.quarterAlerts=[]; localStorage.setItem('quarterAlerts','[]'); renderQtrAlerts(); document.getElementById('threept-badge').style.display='none'; } }

// ==================== LEAD DURABILITY (PAINT vs 3PT) ====================
function analyzeScoringDurability(teamAbbr, score, fg3Made, opponentScore) {
  const s = parseInt(score) || 0;
  const m3 = parseInt(fg3Made) || 0;
  if (s <= 0) return { pct3: 0, durability: 'neutral', label: '-', fragile: false };
  const pts3 = m3 * 3;
  const pct3 = (pts3 / s * 100);
  const nonThreePts = s - pts3;
  // League average: ~35% of points come from 3PT. Above 42% is fragile, below 28% is durable
  const isLeading = s > (parseInt(opponentScore) || 0);
  const fragile = pct3 >= getFragile3PtThreshold() && isLeading && s >= 20;
  const durable = pct3 <= 28 && isLeading && s >= 20;
  let label = `${pct3.toFixed(0)}% from 3`;
  let durability = 'neutral';
  if (fragile) { durability = 'fragile'; label = `${pct3.toFixed(0)}% from 3 - FRAGILE lead`; }
  else if (durable) { durability = 'durable'; label = `${pct3.toFixed(0)}% from 3 - DURABLE lead`; }
  return { pct3, durability, label, fragile, durable, pts3, nonThreePts };
}


// ==================== HISTORICAL BACKTESTING SYSTEM ====================
// Pure signal detection + game state reconstruction + orchestration runner
// Separate from live tracker  results stored in localStorage['historicalBacktest']

const HBT_BET_SIZE = 200;        // Flat $200 per signal (same as tracker flat mode)
const HBT_DEFAULT_ODDS = -110;   // No historical odds  standard ML juice
let _hbtAbortController = null;
let _hbtRunning = false;

/**
 * evaluateSignalsFromState  Pure signal detection for historical backtesting.
 * Self-contained: no DOM access, no globals. Replicates live tracker thresholds exactly.
 *
 * @param {Object} gs  - Game state: { awayAbbr, homeAbbr, awayScore, homeScore, period, clock,
 *                        away3PM, away3PA, home3PM, home3PA, awayLeaders:[{name,team,pts}], homeLeaders:[{name,team,pts}] }
 * @param {Array}  starDB - Array of { name, team, ppg } objects (star player database)
 * @param {string} mode   - 'nba' or 'ncaab'
 * @returns {Object} { signalLevel, signals[], betSide, betSideAbbr, signalTypes[], sig3Fragile, sigStar,
 *                      sigCombined, period, clock, awayScore, homeScore, gMins, starCoilTeams }
 */
function evaluateSignalsFromState(gs, starDB, mode) {
  const isNcaa = mode === 'ncaab';

  // ===== MODE-AWARE CONSTANTS =====
  const totalGameMinutes   = isNcaa ? 40  : 48;
  const periodLength       = isNcaa ? 20  : 12;
  const fragileThreshold   = isNcaa ? 40  : 42;   // % of scoring from 3PT to be "fragile"
  const noEngineThreshold  = isNcaa ? 1.1 : 1.3;  // non-3PT PPM below this = no engine
  const fragileMaxMargin   = isNcaa ? 12  : 15;
  const coilMaxMargin      = isNcaa ? 12  : 15;

  // ===== INLINE HELPER: elapsed minutes =====
  const getElapsed = (per, clk) => {
    const parts = (clk || '0:00').split(':');
    const cM = parseFloat(parts[0]) || 0;
    const cS = parseFloat(parts[1]) || 0;
    const clockRemaining = cM + cS / 60;
    return (per - 1) * periodLength + (periodLength - clockRemaining);
  };

  // ===== INLINE HELPER: expected points by time =====
  const getExpByTime = (ppg, mins) => ppg * (mins / totalGameMinutes);

  // ===== INLINE HELPER: scoring durability =====
  const scoringDurability = (score, fg3Made, opponentScore) => {
    const s = parseInt(score) || 0;
    const m3 = parseInt(fg3Made) || 0;
    if (s <= 0) return { pct3: 0, fragile: false };
    const pts3 = m3 * 3;
    const pct3 = (pts3 / s * 100);
    const isLeading = s > (parseInt(opponentScore) || 0);
    const fragile = pct3 >= fragileThreshold && isLeading && s >= 20;
    return { pct3, fragile, pts3, nonThreePts: s - pts3 };
  };

  // ===== INLINE HELPER: 3PT hot check =====
  const chk3 = (pctRaw, made, att) => {
    const pn = parseFloat(pctRaw) || 0;
    const an = parseInt(att) || 0;
    const mn = parseInt(made) || 0;
    const isHot = isNcaa
      ? ((pn >= 48 && an >= 10) || (pn >= 52 && an >= 7))
      : ((pn >= 50 && an >= 12) || (pn >= 55 && an >= 8));
    return { isHot, pn, an, mn };
  };

  // ===== INLINE HELPER: cast analysis =====
  const castAnalysis = (starPts, teamScore, opponentScore, starPPG, elapsedMinutes) => {
    const castScore = teamScore - starPts;
    const castGap = castScore - opponentScore;
    const starExpected = starPPG * (elapsedMinutes / totalGameMinutes);
    const starDeficit = starExpected - starPts;
    const regressionFlips = starDeficit > 0 && starDeficit > Math.abs(Math.min(castGap, 0));
    const strong   = castGap >= -8;
    const moderate = castGap >= -15 && castGap < -8;
    const weak     = castGap < -15;
    return { castScore, castGap, starDeficit, starExpected, regressionFlips, strong, moderate, weak };
  };

  // ===== DESTRUCTURE GAME STATE =====
  const { awayAbbr: aA, homeAbbr: hA, awayScore: aS, homeScore: hS,
          period: per, clock: clk,
          away3PM: a3M, away3PA: a3A, home3PM: h3M, home3PA: h3A,
          awayLeaders = [], homeLeaders = [] } = gs;

  const gMins = getElapsed(per, clk) || 1;
  const scoreMargin = Math.abs(aS - hS);

  // Compute 3PT percentages from made/attempted
  const a3Pct = (parseInt(a3A) || 0) > 0 ? ((parseInt(a3M) || 0) / (parseInt(a3A) || 0) * 100) : 0;
  const h3Pct = (parseInt(h3A) || 0) > 0 ? ((parseInt(h3M) || 0) / (parseInt(h3A) || 0) * 100) : 0;

  const a3Check = chk3(a3Pct, a3M, a3A);
  const h3Check = chk3(h3Pct, h3M, h3A);

  let signals = [];
  let signalLevel = 0;
  let sigStar = 0, sigStarPlus = 0;
  let starCoilTeams = {};

  const awayLead = aS - hS;
  const homeLead = hS - aS;

  // ==================== STAR COIL SIGNAL ====================

  const allLeaders = [...awayLeaders, ...homeLeaders];
  allLeaders.forEach(leader => {
    // Star matching: NCAA = last-name + same team. NBA = includes last name + same team.
    let star;
    if (isNcaa) {
      star = starDB.find(s => {
        const leaderLast = leader.name.toLowerCase().split(' ').pop();
        const starLast = s.name.split(' ').pop().toLowerCase();
        return leaderLast === starLast && s.team === leader.team;
      });
    } else {
      star = starDB.find(s =>
        leader.name.toLowerCase().includes(s.name.split(' ').pop().toLowerCase()) && s.team === leader.team
      );
    }
    if (!star) return;

    const exp = getExpByTime(star.ppg, gMins);
    const pr = exp > 0 ? leader.pts / exp : 1;
    const side = leader.team === aA ? 'away' : 'home';

    // Coil window: NBA Q2-Q3 (per 2-3). NCAA 8-35 min elapsed.
    const inCoilWindow = isNcaa ? (gMins >= 8 && gMins <= 35) : (per >= 2 && per <= 3);

    if (pr < 0.65 && inCoilWindow && scoreMargin <= coilMaxMargin) {
      const starTeamScore = side === 'away' ? aS : hS;
      const oppScore = side === 'away' ? hS : aS;
      const cast = castAnalysis(leader.pts, starTeamScore, oppScore, star.ppg, gMins);

      // Tier classification (no damage-locked for historical  no live score history)
      let coilTier;
      if (cast.strong)        coilTier = 'elite';
      else if (cast.moderate) coilTier = 'standard';
      else                    coilTier = 'weak';

      const isStrongSignal = coilTier === 'elite' || coilTier === 'standard';

      if (isStrongSignal) {
        signals.push({ type: 'star', side, text: `${leader.name} ${leader.pts}pts (exp ~${exp.toFixed(0)}, ${(pr * 100).toFixed(0)}% pace). Margin: ${scoreMargin}pts. Cast: ${cast.castScore}pts vs opp ${oppScore}pts (gap: ${cast.castGap > 0 ? '+' : ''}${cast.castGap}) ${coilTier.toUpperCase()}.${cast.regressionFlips ? ' Regression flips lead.' : ''}`, level: 2, coilTier });
        sigStar++;
        starCoilTeams[leader.team] = { name: leader.name, cast, coilTier };
      }
    }
  });

  // ==================== STAR COIL PLUS (Star cold + Opponent shooting cold) ====================
  // Backtest verified: leading2Pct < 0.467 AND star pace < 0.612  57.2% on 208 signals
  // Backtest verified: leadingFGPct < 0.431 AND star pace < 0.612  56.0% on 234 signals

  const hasStar = signals.some(s => s.type === 'star' && s.level === 2);
  let activeSignals = hasStar ? 1 : 0;

  if (hasStar) {
    // Get opponent (leading team) shooting stats from ESPN
    const aFGPctVal = parseFloat(game.aStats?.fieldGoalPct || 0) / 100;
    const hFGPctVal = parseFloat(game.hStats?.fieldGoalPct || 0) / 100;
    const aFGM = parseInt(game.aStats?.fieldGoalsMade || 0);
    const hFGM = parseInt(game.hStats?.fieldGoalsMade || 0);
    const aFGAtt = parseInt(game.aStats?.fieldGoalsAttempted || 0);
    const hFGAtt = parseInt(game.hStats?.fieldGoalsAttempted || 0);
    const a2PA = aFGAtt - (parseInt(a3A) || 0);
    const h2PA = hFGAtt - (parseInt(h3A) || 0);
    const a2PM = aFGM - (parseInt(a3M) || 0);
    const h2PM = hFGM - (parseInt(h3M) || 0);
    const a2Pct = a2PA > 0 ? a2PM / a2PA : 0;
    const h2Pct = h2PA > 0 ? h2PM / h2PA : 0;

    // Check each star coil team  is their opponent's shooting cold?
    Object.keys(starCoilTeams).forEach(stk => {
      const isAway = stk === aA;
      const leadFGPct = isAway ? hFGPctVal : aFGPctVal;
      const lead2Pct = isAway ? h2Pct : a2Pct;
      const side = isAway ? 'away' : 'home';

      if ((leadFGPct > 0 && leadFGPct < 0.43) || (lead2Pct > 0 && lead2Pct < 0.47)) {
        const reason = leadFGPct < 0.43
          ? `Opponent FG% ${(leadFGPct * 100).toFixed(1)}% (< 43%)`
          : `Opponent 2PT% ${(lead2Pct * 100).toFixed(1)}% (< 47%)`;
        signals.push({
          type: 'starCoilPlus', side, text: `STAR COIL+: ${reason}. Double regression edge.`,
          level: 2, coilTier: starCoilTeams[stk]?.coilTier || 'standard'
        });
        sigStarPlus++;
        activeSignals = 2;
      }
    });
  }

  // ==================== SIGNAL LEVEL DETERMINATION ====================

  const hasAnyStrictL2 = signals.some(s => s.level === 2);
  if (activeSignals >= 2)         { signalLevel = 2; }
  else if (hasAnyStrictL2)        { signalLevel = 2; }
  else if (signals.length > 0)    { signalLevel = 1; }

  // ==================== BET SIDE DETERMINATION (fade weights) ====================

  let betSide = '', betSideAbbr = '';
  let signalTypes = [];

  if (sigStar > 0)     signalTypes.push('star');
  if (sigStarPlus > 0) signalTypes.push('starCoilPlus');

  if (signalLevel >= 2) {
    let awayFade = 0, homeFade = 0;

    // Star Coil fade weights (only signal system now  3PT Fragile removed)
    const aStarCoil = starCoilTeams[aA];
    const hStarCoil = starCoilTeams[hA];

    if (aStarCoil?.coilTier === 'elite')        { homeFade += 1.5; }  // away star coiled elite = away surges = fade home
    else if (aStarCoil?.coilTier === 'standard') { homeFade += 1; }    // away star coiled standard = fade home

    if (hStarCoil?.coilTier === 'elite')        { awayFade += 1.5; }  // home star coiled elite = home surges = fade away
    else if (hStarCoil?.coilTier === 'standard') { awayFade += 1; }    // home star coiled standard = fade away

    // Star Coil Plus adds extra weight
    if (sigStarPlus > 0) {
      // Same direction as star coil but boosted
      if (aStarCoil) homeFade += 0.5;
      if (hStarCoil) awayFade += 0.5;
    }

    // Determine bet side
    if (awayFade > homeFade)      { betSideAbbr = hA; betSide = 'home'; }
    else if (homeFade > awayFade) { betSideAbbr = aA; betSide = 'away'; }
    else if (awayFade > 0)        { betSideAbbr = hA; betSide = 'home'; }  // tie-break: bet home
    else                          {
      // Tie-break: bet the trailing team
      if (aS < hS)      { betSideAbbr = aA; betSide = 'away'; }
      else               { betSideAbbr = hA; betSide = 'home'; }
    }
  }

  return {
    signalLevel,
    signals,
    betSide,
    betSideAbbr,
    signalTypes,
    sigStar,
    sigStarPlus,
    sigCombined: 0,
    sig3Fragile: 0,
    period: per,
    clock: clk,
    awayScore: aS,
    homeScore: hS,
    gMins,
    starCoilTeams
  };
}

// ===== STEP 2: Game State Reconstruction from ESPN Summary =====
function reconstructGameStates(summaryData, mode) {
  let awayAbbr = '', homeAbbr = '', awayTeamId = null, homeTeamId = null;
  let finalAwayScore = 0, finalHomeScore = 0;

  const competitors = summaryData?.header?.competitions?.[0]?.competitors ||
    (summaryData?.boxscore?.teams || []).map(t => ({ homeAway: t.homeAway, team: t.team, score: null }));

  for (const comp of competitors) {
    const abbr = comp.team?.abbreviation || '';
    const id = comp.team?.id || comp.id || null;
    const score = parseFloat(comp.score) || 0;
    if (comp.homeAway === 'away') { awayAbbr = abbr; awayTeamId = String(id); finalAwayScore = score; }
    else if (comp.homeAway === 'home') { homeAbbr = abbr; homeTeamId = String(id); finalHomeScore = score; }
  }

  // Build athlete ID  { name, team } map from boxscore
  const athleteMap = {};
  for (const entry of (summaryData?.boxscore?.players || [])) {
    const teamAbbr = entry.team?.abbreviation || '';
    for (const stat of (entry.statistics || [])) {
      for (const a of (stat.athletes || [])) {
        const id = String(a.athlete?.id || '');
        if (id) athleteMap[id] = { name: a.athlete?.displayName || '', team: teamAbbr };
      }
    }
  }

  // Parse clock string to seconds
  const parseClockSec = (dv) => {
    if (!dv) return 0;
    const p = dv.split(':');
    return p.length === 2 ? parseInt(p[0], 10) * 60 + parseFloat(p[1]) : parseFloat(dv) || 0;
  };

  const periodLength = mode === 'ncaab' ? 20 : 12;
  const calcElapsed = (period, clockSec) => (period - 1) * periodLength + (periodLength - clockSec / 60);
  const START_ELAPSED = mode === 'nba' ? 12 : 8;

  // Sort plays chronologically
  const rawPlays = summaryData?.plays || [];
  const plays = [...rawPlays].sort((a, b) => {
    if (a.sequenceNumber != null && b.sequenceNumber != null) return Number(a.sequenceNumber) - Number(b.sequenceNumber);
    const pa = a.period?.number || 0, pb = b.period?.number || 0;
    if (pa !== pb) return pa - pb;
    return parseClockSec(b.clock?.displayValue) - parseClockSec(a.clock?.displayValue);
  });

  // State accumulators
  let awayScore = 0, homeScore = 0, away3PM = 0, away3PA = 0, home3PM = 0, home3PA = 0;
  const playerPoints = {};
  const checkpoints = [];
  let lastCPElapsed = -Infinity;

  const getTopLeaders = (teamAbbr) => Object.values(playerPoints)
    .filter(p => p.team === teamAbbr).sort((a, b) => b.pts - a.pts).slice(0, 5)
    .map(p => ({ name: p.name, team: p.team, pts: p.pts }));

  for (const play of plays) {
    const period = play.period?.number || 1;
    const clockDisplay = play.clock?.displayValue || '0:00';
    const clockSec = parseClockSec(clockDisplay);
    const elapsed = calcElapsed(period, clockSec);
    const playTeamId = String(play.team?.id || '');
    const isAway = playTeamId && awayTeamId && playTeamId === awayTeamId;
    const isHome = playTeamId && homeTeamId && playTeamId === homeTeamId;

    // Update running score
    if (play.awayScore != null && play.homeScore != null) {
      awayScore = Number(play.awayScore); homeScore = Number(play.homeScore);
    } else if (play.scoringPlay && play.scoreValue > 0) {
      if (isAway) awayScore += play.scoreValue;
      else if (isHome) homeScore += play.scoreValue;
    }

    // Track 3PT
    const isMade3 = play.scoringPlay === true && play.scoreValue === 3;
    const typeText = play.type?.text || '';
    const isMissed3 = !play.scoringPlay && (String(play.type?.id) === '80' || /miss(?:ed)?\s+three/i.test(typeText));
    if (isMade3 || (/three\s*point/i.test(typeText) && play.scoringPlay)) {
      if (isAway) { away3PM++; away3PA++; } else if (isHome) { home3PM++; home3PA++; }
    } else if (isMissed3) {
      if (isAway) away3PA++; else if (isHome) home3PA++;
    }

    // Track player points
    if (play.scoringPlay && play.scoreValue > 0) {
      for (const p of (play.participants || [])) {
        const athId = String(p.athlete?.id || p.id || '');
        if (!athId) continue;
        if (!playerPoints[athId]) {
          const info = athleteMap[athId] || {};
          playerPoints[athId] = { name: info.name || p.athlete?.displayName || '', team: info.team || (isAway ? awayAbbr : isHome ? homeAbbr : ''), pts: 0 };
        }
        playerPoints[athId].pts += play.scoreValue;
        break;
      }
    }

    // Emit checkpoint every ~2 game-minutes, starting from Q2/8min
    if (elapsed >= START_ELAPSED && elapsed - lastCPElapsed >= 2) {
      checkpoints.push({
        awayAbbr, homeAbbr, awayScore, homeScore,
        period, clock: clockDisplay,
        away3PM, away3PA, home3PM, home3PA,
        awayLeaders: getTopLeaders(awayAbbr),
        homeLeaders: getTopLeaders(homeAbbr),
        elapsedMinutes: elapsed
      });
      lastCPElapsed = elapsed;
    }
  }
  return { checkpoints, finalAwayScore, finalHomeScore, awayAbbr, homeAbbr };
}

// ===== STEP 3: Backtest Runner + Helpers =====
async function runHistoricalBacktest() {
  if (_hbtRunning) return;
  const mode = document.getElementById('hbt-mode').value;
  const startDate = document.getElementById('hbt-start').value;
  const endDate = document.getElementById('hbt-end').value;
  if (!startDate || !endDate) { alert('Please select start and end dates.'); return; }
  if (startDate > endDate) { alert('Start date must be before end date.'); return; }

  const starDB = mode === 'ncaab' ? ncaaStarCache : (state.stars || []);
  if (mode === 'ncaab' && (!ncaaStarCache || ncaaStarCache.length === 0)) {
    alert('NCAA star database is empty. Switch to NCAA mode first to build the star DB, then return here.');
    return;
  }

  _hbtRunning = true;
  _hbtAbortController = new AbortController();
  const signal = _hbtAbortController.signal;
  document.getElementById('hbt-run-btn').disabled = true;
  document.getElementById('hbt-cancel-btn').style.display = 'inline-block';
  document.getElementById('hbt-progress').style.display = 'block';

  const league = mode === 'ncaab' ? 'mens-college-basketball' : 'nba';
  const baseUrl = `https://site.api.espn.com/apis/site/v2/sports/basketball/${league}/`;

  // Build YYYYMMDD date list
  const dateStrings = [];
  const cursor = new Date(startDate + 'T00:00:00');
  const endDt = new Date(endDate + 'T00:00:00');
  while (cursor <= endDt) {
    const y = cursor.getFullYear(), m = String(cursor.getMonth() + 1).padStart(2, '0'), d = String(cursor.getDate()).padStart(2, '0');
    dateStrings.push(`${y}${m}${d}`);
    cursor.setDate(cursor.getDate() + 1);
  }

  // First pass: count total games
  const dateGames = {};
  let totalGames = 0;
  for (const ds of dateStrings) {
    if (signal.aborted) break;
    try {
      const resp = await fetch(`${baseUrl}scoreboard?dates=${ds}`, { signal });
      const data = await resp.json();
      const events = (data.events || []).filter(ev => ev.status?.type?.state === 'post');
      dateGames[ds] = events;
      totalGames += events.length;
    } catch (e) { if (signal.aborted) break; dateGames[ds] = []; }
    await new Promise(r => setTimeout(r, 400));
  }

  // Second pass: process each game
  const results = [];
  let processedGames = 0, signalsFound = 0;
  for (const ds of dateStrings) {
    if (signal.aborted) break;
    const events = dateGames[ds] || [];
    const isoDate = `${ds.slice(0,4)}-${ds.slice(4,6)}-${ds.slice(6,8)}`;
    for (const ev of events) {
      if (signal.aborted) break;
      const gid = ev.id;
      const pLabel = document.getElementById('hbt-progress-label');
      if (pLabel) pLabel.textContent = `Fetching game ${gid}...`;

      await new Promise(r => setTimeout(r, 800));
      if (signal.aborted) break;

      let summData;
      try {
        const resp = await fetch(`${baseUrl}summary?event=${gid}`, { signal });
        summData = await resp.json();
      } catch (e) { if (signal.aborted) break; processedGames++; updateHBTProgress(processedGames, totalGames, signalsFound); continue; }

      let reconstructed;
      try { reconstructed = reconstructGameStates(summData, mode); } catch (e) { processedGames++; updateHBTProgress(processedGames, totalGames, signalsFound); continue; }

      const { checkpoints, finalAwayScore, finalHomeScore, awayAbbr: aA, homeAbbr: hA } = reconstructed;
      const gameLabel = `${aA} @ ${hA}`;
      if (pLabel) pLabel.textContent = `Processing ${gameLabel} (${isoDate})...`;

      const recordedSides = new Set();
      for (const cp of checkpoints) {
        if (signal.aborted) break;
        let evalResult;
        try { evalResult = evaluateSignalsFromState(cp, starDB, mode); } catch (e) { continue; }
        if (!evalResult || evalResult.signalLevel < 2 || !evalResult.betSide || recordedSides.has(evalResult.betSide)) continue;
        recordedSides.add(evalResult.betSide);

        const betOnAway = evalResult.betSide === 'away';
        const betTeamFinal = betOnAway ? finalAwayScore : finalHomeScore;
        const oppFinal = betOnAway ? finalHomeScore : finalAwayScore;
        const multiplier = 100 / 110;
        const mlResult = betTeamFinal > oppFinal ? 'W' : 'L';
        const mlPayout = mlResult === 'W' ? Math.round(HBT_BET_SIZE * multiplier) : -HBT_BET_SIZE;

        signalsFound++;
        results.push({
          date: isoDate, eventId: gid, game: gameLabel,
          awayAbbr: aA, homeAbbr: hA,
          betSide: evalResult.betSide, betTeamAbbr: evalResult.betSideAbbr,
          signalTypes: evalResult.signalTypes,
          period: evalResult.period, clock: evalResult.clock,
          scoreAtSignal: `${evalResult.awayScore}-${evalResult.homeScore}`,
          awayScoreAtSignal: evalResult.awayScore, homeScoreAtSignal: evalResult.homeScore,
          finalAwayScore, finalHomeScore, mlResult, mlPayout,
          gMins: evalResult.gMins, mode
        });
      }
      processedGames++;
      updateHBTProgress(processedGames, totalGames, signalsFound);
    }
    if (!signal.aborted) await new Promise(r => setTimeout(r, 1000));
  }

  localStorage.setItem('historicalBacktest', JSON.stringify({
    results, mode, startDate, endDate, runAt: Date.now(), totalGames, totalSignals: signalsFound
  }));

  _hbtRunning = false;
  document.getElementById('hbt-run-btn').disabled = false;
  document.getElementById('hbt-cancel-btn').style.display = 'none';
  renderHBTResults();
}

function cancelBacktest() {
  if (_hbtAbortController) _hbtAbortController.abort();
  _hbtRunning = false;
  document.getElementById('hbt-run-btn').disabled = false;
  document.getElementById('hbt-cancel-btn').style.display = 'none';
  const t = document.getElementById('hbt-progress-text');
  if (t) t.textContent = (t.textContent || '') + ' (Cancelled)';
}

function updateHBTProgress(done, total, sigs) {
  const pct = total > 0 ? Math.round(done / total * 100) : 0;
  const fill = document.getElementById('hbt-progress-fill');
  if (fill) fill.style.width = pct + '%';
  const text = document.getElementById('hbt-progress-text');
  if (text) text.textContent = `${done} / ${total} games | ${sigs} signals found`;
}

function setBTRange(days) {
  const end = new Date(), start = new Date();
  start.setDate(start.getDate() - days);
  const fmt = d => d.toISOString().slice(0, 10);
  document.getElementById('hbt-end').value = fmt(end);
  document.getElementById('hbt-start').value = fmt(start);
}

// ===== STEP 4: Results Rendering =====
function renderHBTResults() {
  const el = document.getElementById('hbt-results');
  if (!el) return;
  const raw = localStorage.getItem('historicalBacktest');
  if (!raw) { el.innerHTML = '<div style="text-align:center;padding:30px;color:var(--text-muted);font-size:12px">No historical backtest results yet. Configure dates above and click Run.</div>'; return; }
  const data = JSON.parse(raw);
  const results = data.results || [];
  if (results.length === 0) { el.innerHTML = '<div style="text-align:center;padding:30px;color:var(--text-muted);font-size:12px">Backtest completed but no signals found in selected date range.</div>'; return; }

  // Stats
  const total = results.length;
  const wins = results.filter(r => r.mlResult === 'W').length;
  const losses = results.filter(r => r.mlResult === 'L').length;
  const winRate = total > 0 ? (wins / total * 100).toFixed(1) : '0';
  const totalPL = results.reduce((s, r) => s + (r.mlPayout || 0), 0);
  const totalRisked = total * HBT_BET_SIZE;
  const roi = totalRisked > 0 ? (totalPL / totalRisked * 100).toFixed(1) : '0';

  // By signal type
  const bySig = {};
  results.forEach(r => (r.signalTypes || []).forEach(st => {
    if (!bySig[st]) bySig[st] = { n: 0, w: 0, l: 0, pl: 0 };
    bySig[st].n++; if (r.mlResult === 'W') bySig[st].w++; else bySig[st].l++; bySig[st].pl += (r.mlPayout || 0);
  }));

  // By period
  const byPer = {};
  results.forEach(r => {
    const pLabel = r.mode === 'ncaab' ? ((r.period || 0) <= 2 ? 'H' + (r.period || '?') : 'OT') : 'Q' + (r.period || '?');
    if (!byPer[pLabel]) byPer[pLabel] = { n: 0, w: 0, l: 0, pl: 0 };
    byPer[pLabel].n++; if (r.mlResult === 'W') byPer[pLabel].w++; else byPer[pLabel].l++; byPer[pLabel].pl += (r.mlPayout || 0);
  });

  let h = '';
  const plColor = totalPL >= 0 ? 'var(--green)' : 'var(--red)';
  const wrColor = parseFloat(winRate) >= 52.4 ? 'var(--green)' : 'var(--red)';

  h += `<div style="font-size:10px;color:var(--text-muted);margin-bottom:12px">Last run: ${new Date(data.runAt).toLocaleString()} | ${data.startDate} to ${data.endDate} | ${data.mode === 'ncaab' ? 'NCAA' : 'NBA'} | ${data.totalGames} games scanned</div>`;

  // Summary stat cards
  const sc = (label, val, sub, color) => `<div class="card" style="padding:14px;text-align:center"><div style="font-size:9px;font-weight:700;color:var(--text-muted);letter-spacing:0.8px;margin-bottom:6px">${label}</div><div style="font-size:22px;font-weight:800;color:${color || 'var(--text-primary)'}">${val}</div><div style="font-size:10px;color:var(--text-muted);margin-top:2px">${sub}</div></div>`;
  h += '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:10px;margin-bottom:16px">';
  h += sc('SIGNALS', total, `from ${data.totalGames} games`, 'var(--accent)');
  h += sc('ML RECORD', `${wins}-${losses}`, `${winRate}% win rate`, wrColor);
  h += sc('ROI', `${roi}%`, 'at -110 flat', parseFloat(roi) >= 0 ? 'var(--green)' : 'var(--red)');
  h += sc('CUMULATIVE P&L', `${totalPL >= 0 ? '+' : ''}$${totalPL.toLocaleString()}`, `$${HBT_BET_SIZE}/bet x ${total}`, plColor);
  h += sc('TOTAL RISKED', `$${totalRisked.toLocaleString()}`, `$${HBT_BET_SIZE} flat`, 'var(--text-primary)');
  h += '</div>';

  // By signal type
  const sigKeys = Object.keys(bySig);
  if (sigKeys.length > 0) {
    h += '<div style="margin-bottom:16px"><div style="font-size:12px;font-weight:700;margin-bottom:8px;color:var(--text-muted);letter-spacing:0.5px">BY SIGNAL TYPE</div>';
    h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:10px">';
    sigKeys.forEach(sig => {
      const d = bySig[sig], wr = d.n > 0 ? Math.round(d.w / d.n * 100) : 0;
      h += `<div class="card" style="padding:12px"><div style="font-size:12px;font-weight:800;color:var(--accent);margin-bottom:6px">${sig.toUpperCase()} <span style="font-weight:400;color:var(--text-muted)">(n=${d.n})</span></div>`;
      h += `<div style="font-size:11px;line-height:1.8">ML: <strong style="color:${wr >= 52.4 ? 'var(--green)' : 'var(--red)'}">${d.w}-${d.l}</strong> (${wr}%) | ${d.pl >= 0 ? '+' : ''}$${d.pl.toLocaleString()}</div></div>`;
    });
    h += '</div></div>';
  }

  // By period
  const perKeys = Object.keys(byPer).sort();
  if (perKeys.length > 0) {
    h += '<div style="margin-bottom:16px"><div style="font-size:12px;font-weight:700;margin-bottom:8px;color:var(--text-muted);letter-spacing:0.5px">BY PERIOD</div>';
    h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:10px">';
    perKeys.forEach(p => {
      const d = byPer[p], wr = d.n > 0 ? Math.round(d.w / d.n * 100) : 0;
      h += `<div class="card" style="padding:12px"><div style="font-size:14px;font-weight:800;color:var(--accent);margin-bottom:4px">${p} <span style="font-weight:400;color:var(--text-muted);font-size:11px">(n=${d.n})</span></div>`;
      h += `<div style="font-size:11px">ML: <strong style="color:${wr >= 52.4 ? 'var(--green)' : 'var(--red)'}">${d.w}-${d.l}</strong> (${wr}%) | <span style="color:${d.pl >= 0 ? 'var(--green)' : 'var(--red)'}">${d.pl >= 0 ? '+' : ''}$${d.pl.toLocaleString()}</span></div></div>`;
    });
    h += '</div></div>';
  }

  // Individual signals table
  const thS = 'padding:8px 6px;font-size:9px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:var(--text-muted);border-bottom:2px solid var(--border);white-space:nowrap;text-align:left';
  h += '<div class="card" style="padding:0;overflow:hidden"><div style="overflow-x:auto">';
  h += `<table style="width:100%;border-collapse:collapse;font-size:11px"><thead><tr>`;
  h += `<th style="${thS}">Date</th><th style="${thS}">Game</th><th style="${thS}">Bet</th><th style="${thS}">Signals</th>`;
  h += `<th style="${thS}">Period</th><th style="${thS}">Score@Signal</th><th style="${thS}">Final</th>`;
  h += `<th style="${thS}">ML</th><th style="${thS}">P&L</th></tr></thead><tbody>`;

  results.slice().reverse().forEach(r => {
    const td = 'padding:8px 6px;border-bottom:1px solid var(--border-light, rgba(255,255,255,0.06));white-space:nowrap';
    const mlC = r.mlResult === 'W' ? 'var(--green)' : 'var(--red)';
    const plC = (r.mlPayout || 0) > 0 ? 'var(--green)' : 'var(--red)';
    const pLabel = r.mode === 'ncaab' ? ((r.period || 0) <= 2 ? 'H' + (r.period || '?') : 'OT') : 'Q' + (r.period || '?');
    const badges = (r.signalTypes || []).map(t => `<span style="display:inline-block;font-size:8px;padding:1px 4px;border-radius:3px;background:var(--accent-light);color:var(--accent);font-weight:600;margin-left:2px">${t}</span>`).join('');
    h += `<tr><td style="${td};font-size:10px;color:var(--text-muted)">${r.date}</td>`;
    h += `<td style="${td};font-weight:600">${r.game}</td>`;
    h += `<td style="${td};color:var(--accent);font-weight:700">${r.betTeamAbbr}</td>`;
    h += `<td style="${td}">${badges}</td>`;
    h += `<td style="${td};font-family:monospace">${pLabel} ${r.clock || ''}</td>`;
    h += `<td style="${td};font-family:monospace;font-size:10px">${r.scoreAtSignal}</td>`;
    h += `<td style="${td};font-family:monospace;font-weight:700">${r.finalAwayScore}-${r.finalHomeScore}</td>`;
    h += `<td style="${td};font-weight:800;color:${mlC}">${r.mlResult}</td>`;
    h += `<td style="${td};font-family:monospace;color:${plC}">${r.mlPayout >= 0 ? '+' : ''}$${r.mlPayout.toLocaleString()}</td></tr>`;
  });

  h += '</tbody></table></div></div>';
  h += `<div style="margin-top:12px;text-align:right"><button class="btn btn-sm" style="background:var(--card-bg);color:var(--red);border:1px solid var(--border);padding:6px 14px;border-radius:20px;font-size:11px;cursor:pointer" onclick="if(confirm('Clear historical backtest results?')){localStorage.removeItem('historicalBacktest');renderHBTResults();}">Clear Results</button></div>`;
  el.innerHTML = h;
}

function initHistoricalBacktest() { setBTRange(7); renderHBTResults(); }

// ==================== ESPN SCOREBOARD ====================

function getLeague3PtAvg() { return isNCAA() ? 33.5 : 36.5; }
// Team Season 3PT% Averages

function getFragile3PtThreshold() { return isNCAA() ? 40 : 42; }
function getLeagueName() { return isNCAA() ? 'NCAAB' : 'NBA'; }
let _modeFetchController = null;

async function fetchESPNScoreboard() {
  if (_modeFetchController) _modeFetchController.abort();
  _modeFetchController = new AbortController();
  const grid = document.getElementById('live-games-grid');
  const tpGrid = document.getElementById('threept-grid');
  setConnStatus('loading');
  try {
    await fetchLiveOdds();
    await Promise.all([fetchTeamProfiles(), fetchTeamScorers()]);
    const modeSignal = _modeFetchController ? _modeFetchController.signal : undefined;
    const timeout = setTimeout(() => { if (_modeFetchController) _modeFetchController.abort(); }, 10000);
    const res = await fetch(getESPNUrl(), { signal: modeSignal });
    clearTimeout(timeout);
    if (!res.ok) throw new Error('ESPN ' + res.status);
    const data = await res.json();
    setConnStatus('ok');
    let events = data.events || [];
    document.getElementById('live-last-update').textContent = new Date().toLocaleTimeString();

    // Also fetch upcoming games (tomorrow) if no live games
    const inProgress = events.filter(e => e.status?.type?.state === 'in');
    const preGames = events.filter(e => e.status?.type?.state === 'pre');
    const postGames = events.filter(e => e.status?.type?.state === 'post');
    document.getElementById('live-games-count').textContent = inProgress.length;

    // If no live/pre games, fetch tomorrow's schedule too
    // Use ESPN's own day.date (ET-based) to compute "tomorrow" correctly
    if (inProgress.length === 0 && preGames.length === 0) {
      try {
        const espnToday = data.day?.date; // e.g. "2026-02-25" (ET)
        let dateStr;
        if (espnToday) {
          // Add 1 day to ESPN's date (avoids timezone mismatch with Date.now())
          const parts = espnToday.split('-');
          const d = new Date(+parts[0], +parts[1] - 1, +parts[2]);
          d.setDate(d.getDate() + 1);
          dateStr = d.getFullYear() + String(d.getMonth()+1).padStart(2,'0') + String(d.getDate()).padStart(2,'0');
        } else {
          // Fallback: use ET-based "tomorrow" (ESPN uses Eastern Time)
          const nowET = new Date(new Date().toLocaleString('en-US', { timeZone: 'America/New_York' }));
          nowET.setDate(nowET.getDate() + 1);
          dateStr = nowET.getFullYear() + String(nowET.getMonth()+1).padStart(2,'0') + String(nowET.getDate()).padStart(2,'0');
        }
        const tmrwRes = await fetch(getESPNUrl() + '?dates=' + dateStr, { signal: AbortSignal.timeout(8000) });
        if (tmrwRes.ok) {
          const tmrwData = await tmrwRes.json();
          const tmrwEvents = (tmrwData.events || []).filter(e => e.status?.type?.state === 'pre');
          tmrwEvents.forEach(e => { e._upcoming = true; });
          events = events.concat(tmrwEvents);
        }
      } catch(e) { /* tomorrow fetch optional */ }
    }

    // Build ordered event list: live first, then pre, then post
    const liveEvents = events.filter(e => e.status?.type?.state === 'in');
    const upcomingEvents = events.filter(e => e.status?.type?.state === 'pre');
    const completedEvents = events.filter(e => e.status?.type?.state === 'post');
    const allDisplayEvents = [...liveEvents, ...upcomingEvents, ...completedEvents];

    if (allDisplayEvents.length === 0) {
      grid.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><div style="width:56px;height:56px;margin:0 auto 16px;background:var(--bg);border:2px solid var(--border);border-radius:50%;display:flex;align-items:center;justify-content:center;"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="1.5"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg></div><p style="font-weight:600;color:var(--text-secondary);margin-bottom:4px;">No ${getLeagueName()} games right now</p><p style="font-size:12px;">Check back when games are scheduled or in progress.</p></div>`;
      tpGrid.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><div class="icon">&#x1F3AF;</div><p>No live games.</p></div>`;
      document.getElementById('edgeThesisContainer').classList.remove('active');
      return;
    }

    // Fetch boxscores for live games (parallel)  gives us all player stats, not just leader
    const _boxscoreMap = {}; // gameId  { away: [{name,pts}], home: [{name,pts}] }
    if (liveEvents.length > 0) {
      const league = isNCAA() ? 'mens-college-basketball' : 'nba';
      const boxFetches = liveEvents.map(e =>
        fetch(`https://site.api.espn.com/apis/site/v2/sports/basketball/${league}/summary?event=${e.id}`, { signal: AbortSignal.timeout(6000) })
          .then(r => r.ok ? r.json() : null)
          .catch(() => null)
      );
      const boxResults = await Promise.all(boxFetches);
      boxResults.forEach((bx, i) => {
        if (!bx?.boxscore?.players) return;
        const ev = liveEvents[i];
        const gid = ev.id;
        const comp = ev.competitions?.[0];
        const awayAbbr = comp?.competitors?.find(c=>c.homeAway==='away')?.team?.abbreviation || '';
        const homeAbbr = comp?.competitors?.find(c=>c.homeAway==='home')?.team?.abbreviation || '';
        const map = { away: [], home: [] };
        bx.boxscore.players.forEach(team => {
          const abbr = team.team?.abbreviation || '';
          const side = abbr === awayAbbr ? 'away' : 'home';
          (team.statistics?.[0]?.athletes || []).forEach(a => {
            const pts = parseFloat(a.stats?.[1]) || 0;
            const name = a.athlete?.displayName || a.athlete?.shortName || '?';
            map[side].push({ name, pts, team: abbr });
          });
        });
        _boxscoreMap[gid] = map;
      });
    }

    // Section headers
    let sectionHeaders = { live: false, upcoming: false, completed: false };

    let sigStar=0, hotTeams=0, warmTeams=0;
    let cards='', tpCards='', gameTheses=[];
    // Per-signal game tracking for chip click-to-expand
    let signalGames = { 'star': [], 'starcoilplus': [] };

    for (const event of allDisplayEvents) {
      const comp = event.competitions?.[0]; if (!comp) continue;
      const away = comp.competitors?.find(c => c.homeAway==='away');
      const home = comp.competitors?.find(c => c.homeAway==='home');
      if (!away || !home) continue;

      const gid = event.id;
      const aA = away.team?.abbreviation || shortName(away.team?.displayName||'');
      const aFull = away.team?.displayName||'';
      const hFull = home.team?.displayName||'';
      const hA = home.team?.abbreviation || shortName(home.team?.displayName||'');
      const aLogo = away.team?.logo || '';
      const hLogo = home.team?.logo || '';
      // Game links: ESPN gamecast + NBA League Pass
      const espnLink = event.links?.[0]?.href || '';
      const gameSlug = espnLink ? espnLink.split('/').pop() : '';
      const leaguePassLink = !isNCAA() && gameSlug ? 'https://www.nba.com/game/' + gameSlug : '';
      const aS = parseInt(away.score)||0, hS = parseInt(home.score)||0;
      const gameState = event.status?.type?.state;
      const isLive = gameState === 'in';
      const isUpcoming = gameState === 'pre';
      const isCompleted = gameState === 'post';
      const per = event.status?.period||0, clk = event.status?.displayClock||'';
      const detail = event.status?.type?.shortDetail||'';
      const gLabel = `${aA} @ ${hA}`;
      const aRec = away.records?.[0]?.summary||'', hRec = home.records?.[0]?.summary||'';

      // Section headers
      if (isLive && !sectionHeaders.live) {
        cards += `<div class="grid-section-label" style="border-top:none;margin-top:0;padding-top:8px;"><span style="color:var(--red);">LIVE</span></div>`;
        sectionHeaders.live = true;
      } else if (isUpcoming && !sectionHeaders.upcoming) {
        cards += `<div class="grid-section-label"><span style="color:var(--accent);">UPCOMING</span></div>`;
        sectionHeaders.upcoming = true;
      } else if (isCompleted && !sectionHeaders.completed) {
        cards += `<div class="grid-section-label"><span style="color:var(--text-muted);">COMPLETED</span></div>`;
        sectionHeaders.completed = true;
      }

      // Upcoming game card  minimal style with tipoff time + live odds
      if (isUpcoming) {
        const tipoff = event.date ? new Date(event.date) : null;
        const tipoffStr = tipoff ? tipoff.toLocaleString('en-US', { weekday: 'short', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' }) : detail;
        const broadcast = comp.broadcasts?.[0]?.names?.[0] || '';
        const _finalOddsHTML = buildOddsHTML(aA,hA,aFull,hFull,comp.odds?.[0]);
        const isFav = state.favorites.includes(gid);
        cards += `<div class="game-card" data-game-id="${gid}" style="opacity:0.85;">
          <div class="game-card-header">
            <span style="color:var(--accent);font-weight:600;">UPCOMING</span>
            <span style="display:flex;align-items:center;gap:6px;">
              ${broadcast ? '<span style="font-size:9px;font-weight:600;color:var(--text-muted);background:var(--bg);padding:1px 6px;border-radius:3px;">' + broadcast + '</span>' : ''}
              <span class="fav-star" onclick="toggleFavorite('${gid}')" style="cursor:pointer;font-size:14px;">${isFav?'\u2605':'\u2606'}</span>
            </span>
          </div>
          <div class="game-card-body">
            <div class="game-teams">
              <div class="team-block">
                <div class="team-name">${teamLogoImg(aLogo, 20)}${teamDisplayShort(aA, aFull)}</div>
                <div class="team-record">${aRec}</div>
                ${teamProfileHTML(aA, 'away', aLogo)}
                <div class="team-score" style="color:var(--text-muted);">-</div>
              </div>
              <div class="vs-block">
                <div class="vs-text" style="font-size:11px;font-weight:500;color:var(--text-muted);opacity:0.6;">vs</div>
              </div>
              <div class="team-block">
                <div class="team-name">${teamLogoImg(hLogo, 20)}${teamDisplayShort(hA, hFull)}</div>
                <div class="team-record">${hRec}</div>
                ${teamProfileHTML(hA, 'home', hLogo)}
                <div class="team-score" style="color:var(--text-muted);">-</div>
              </div>
            </div>
            ${gameLinksHTML(espnLink, leaguePassLink)}
            ${_finalOddsHTML}
            <div style="text-align:center;padding:4px 0;">
              <div style="font-size:12px;font-weight:600;color:var(--text-secondary);">${tipoffStr}</div>
            </div>
          </div>
        </div>`;
        continue;
      }

      // Completed game card  muted style with final score
      if (isCompleted) {
        const winner = aS > hS ? 'away' : 'home';
        const isFav = state.favorites.includes(gid);
        cards += `<div class="game-card" data-game-id="${gid}" style="opacity:0.75;">
          <div class="game-card-header">
            <span style="color:var(--text-muted);font-weight:600;">FINAL</span>
            <span class="fav-star" onclick="toggleFavorite('${gid}')" style="cursor:pointer;font-size:14px;">${isFav?'\u2605':'\u2606'}</span>
          </div>
          <div class="game-card-body">
            <div class="game-teams">
              <div class="team-block">
                <div class="team-name" ${winner==='away'?'style="color:var(--accent);font-weight:900;"':''}>${teamLogoImg(aLogo, 20)}${teamDisplayShort(aA, aFull)}</div>
                <div class="team-record">${aRec}</div>
                ${teamProfileHTML(aA, 'away', aLogo)}
                <div class="team-score" ${winner==='away'?'style="color:var(--accent);"':'style="color:var(--text-muted);"'}>${aS}</div>
              </div>
              <div class="vs-block">
                <div class="vs-text" style="font-size:11px;font-weight:500;color:var(--text-muted);opacity:0.6;">vs</div>
              </div>
              <div class="team-block">
                <div class="team-name" ${winner==='home'?'style="color:var(--accent);font-weight:900;"':''}>${teamLogoImg(hLogo, 20)}${teamDisplayShort(hA, hFull)}</div>
                <div class="team-record">${hRec}</div>
                ${teamProfileHTML(hA, 'home', hLogo)}
                <div class="team-score" ${winner==='home'?'style="color:var(--accent);"':'style="color:var(--text-muted);"'}>${hS}</div>
              </div>
            </div>
          </div>
        </div>`;
        continue;
      }

      let aStats={}, hStats={};
      (away.statistics||[]).forEach(s => { aStats[s.name]=s.displayValue; });
      (home.statistics||[]).forEach(s => { hStats[s.name]=s.displayValue; });

      let a3P=aStats.threePointFieldGoalPct||aStats.threePointPct||'-';
      let h3P=hStats.threePointFieldGoalPct||hStats.threePointPct||'-';
      let a3M=aStats.threePointFieldGoalsMade||'-', a3A=aStats.threePointFieldGoalsAttempted||'-';
      let h3M=hStats.threePointFieldGoalsMade||'-', h3A=hStats.threePointFieldGoalsAttempted||'-';
      let aFouls=aStats.fouls||aStats.totalFouls||'0', hFouls=hStats.fouls||hStats.totalFouls||'0';

      // Track score momentum for Damage Locked detection
      if (isLive) trackScoreMomentum(gid, aS, hS);
      let aFTA = parseInt(aStats.freeThrowsAttempted)||0;
      let hFTA = parseInt(hStats.freeThrowsAttempted)||0;

      if (isLive) { checkQuarterEnd(gid, aA, per, a3P, a3M, a3A, gLabel); checkQuarterEnd(gid, hA, per, h3P, h3M, h3A, gLabel); }

      let aLeaders=[], hLeaders=[];
      (comp.competitors||[]).forEach(c => {
        (c.leaders||[]).forEach(cat => {
          if (cat.name==='points'||cat.displayName==='Points') {
            (cat.leaders||[]).forEach(l => {
              const e = { name: l.athlete?.shortName||l.athlete?.displayName||'?', pts: parseFloat(l.value)||0, team: c.homeAway==='away'?aA:hA };
              if (c.homeAway==='away') aLeaders.push(e); else hLeaders.push(e);
            });
          }
        });
      });

      let signals=[], signalLevel=0;
      const gLabelFull = gLabel;
      let thesis = { game: gLabel, gameFull: gLabelFull, aTeam: aA, hTeam: hA, aTeamFull: aFull, hTeamFull: hFull, aLogo, hLogo, aScore: aS, hScore: hS, per, clk, detail, criteria: {}, betSide: '', betSideFull: '', betLogic: '', signals: [] };

      if (isLive) {
        // 3PT CHECK  evaluate shooting stats (used as input for 3PT Fragile signal)
        const chk3 = (p,m,a,t,side,tFull) => {
          const pn=parseFloat(p), an=parseInt(a), mn=parseInt(m);
          const tD = teamDisplay(t, tFull);
          // NCAA: lower thresholds (fewer possessions, lower league avg 3PT%)
          const isHot = isNCAA() ? ((pn>=48&&an>=10)||(pn>=52&&an>=7)) : ((pn>=50&&an>=12)||(pn>=55&&an>=8));
          const isWarm = !isHot && (isNCAA() ? (pn>=43&&an>=8) : (pn>=45&&an>=10));
          if (isHot) {
            fire3PTAlert(t, pn.toFixed(0), mn, an, gLabel, per, clk); hotTeams++;
          } else if (isWarm) { warmTeams++; }
          // NOTE: 3PT alone no longer fires as a level 2 signal.
          // It will be combined with Fragile Lead below into "3PT Fragile"
          return { isHot, isWarm, pn, an, mn, tD };
        };
        const a3Check = chk3(a3P,a3M,a3A,aA,'away',aFull), h3Check = chk3(h3P,h3M,h3A,hA,'home',hFull);

        // FRAGILE LEAD CHECK  evaluate lead composition (used as input for 3PT Fragile signal)
        const aDur = analyzeScoringDurability(aA, aS, a3M, hS);
        const hDur = analyzeScoringDurability(hA, hS, h3M, aS);
        let aFragileData = null, hFragileData = null;
        if (aS > hS && aDur.pct3 >= getFragile3PtThreshold() && aS >= 20) {
          const hNon3Pct = hS > 0 ? ((hS - (parseInt(h3M)||0)*3) / hS * 100) : 0;
          if (hNon3Pct >= 58) aFragileData = { pct3: aDur.pct3, oppPaintPct: hNon3Pct };
        }
        if (hS > aS && hDur.pct3 >= getFragile3PtThreshold() && hS >= 20) {
          const aNon3Pct = aS > 0 ? ((aS - (parseInt(a3M)||0)*3) / aS * 100) : 0;
          if (aNon3Pct >= 58) hFragileData = { pct3: hDur.pct3, oppPaintPct: aNon3Pct };
        }

        // ========== 3PT FRAGILE SIGNAL  fires ONLY when BOTH conditions are met ==========
        // Condition 1: Team shooting hot from 3 (50%+ on 12+ att or 55%+ on 8+ att)
        // Condition 2: Their lead is fragile (3PT-heavy) AND trailing team scores from paint
        const _aD = teamDisplay(aA, aFull), _hD = teamDisplay(hA, hFull);

        // ===== OPPONENT ENGINE CHECK =====
        // Can the trailing team actually capitalize if 3PT regression happens?
        // Compute non-3PT points per minute for each team (paint + FT + mid-range)
        const _gMinsNow = getElapsedMinutes(per, clk) || 1;
        const aNon3Pts = aS - (parseInt(a3M)||0)*3;
        const hNon3Pts = hS - (parseInt(h3M)||0)*3;
        const aNon3Ppm = aNon3Pts / _gMinsNow;  // away non-3PT points per minute
        const hNon3Ppm = hNon3Pts / _gMinsNow;  // home non-3PT points per minute
        // League avg ~1.8-2.0 non-3PT ppm (NBA). NCAA is lower scoring  threshold 1.1.
        const NO_ENGINE_THRESHOLD = isNCAA() ? 1.1 : 1.3;

        // Away team: both hot 3PT AND fragile lead
        const awayLead = aS - hS;
        // If away leads with fragile 3s, check if HOME (trailing) has enough non-3PT engine to capitalize
        const hNoEngine = awayLead > 0 && hNon3Ppm < NO_ENGINE_THRESHOLD && _gMinsNow >= 10;
        const hEngineLabel = hNoEngine ? `  BUT ${_hD} has no scoring engine (${hNon3Ppm.toFixed(1)} non-3PT PPM)  may not capitalize even if 3s regress` : '';

        const _fragileMaxMargin = isNCAA() ? 12 : 15;
        if (a3Check.isHot && aFragileData && awayLead >= 3 && awayLead <= _fragileMaxMargin) {
          const fragileStrength = hNoEngine ? 'weakened' : 'strong';
          // 3PT Fragile REMOVED from signals array (backtest: 31.3% ML win rate, below 35.1% baseline)
          // Thesis criteria below still populate the detail panel for informational purposes
          const engineDetail = hNoEngine
            ? `<br><strong> Opponent Engine Check:</strong> ${_hD} is producing only ${hNon3Ppm.toFixed(1)} non-3PT points/min (threshold: ${NO_ENGINE_THRESHOLD}). Their offense is broken beyond just 3PT variance  even if ${_aD}'s 3s cool down, ${_hD} may not have the scoring engine to capitalize. <strong>Signal is weaker.</strong>`
            : `<br><strong> Opponent Engine:</strong> ${_hD} is producing ${hNon3Ppm.toFixed(1)} non-3PT points/min  they have a real scoring engine from paint/FT/mid-range. When ${_aD}'s 3s regress, ${_hD} can capitalize.`;
          thesis.criteria['3ptfragile_away'] = {met:true, strong:!hNoEngine, label:`${_aD} 3PT Fragile Lead${hNoEngine?' ':''}`, detail:`<strong>3PT Shooting:</strong> ${_aD} is shooting ${a3Check.pn.toFixed(0)}% from 3 on ${a3Check.an} attempts (${getLeagueName()} avg: ${getLeague3PtAvg()}%).<br><strong>Lead Composition:</strong> ${aFragileData.pct3.toFixed(0)}% of ${_aD}'s scoring comes from 3PT (threshold: ${getFragile3PtThreshold()}%).<br><strong>Score Margin:</strong> ${awayLead} pts  in the 3-15pt sweet spot where regression flips the game.<br><strong>Opponent Durability:</strong> ${_hD} has ${aFragileData.oppPaintPct.toFixed(0)}% non-3PT scoring  paint-heavy and sustainable.${engineDetail}<br><strong>Signal:</strong> ${hNoEngine ? 'Hot 3PT + fragile lead detected, but trailing team\'s offense is too weak to exploit regression. Proceed with caution.' : 'Hot 3PT + fragile lead + competitive margin. When shooting cools, lead evaporates.'}`, value:`${a3Check.pn.toFixed(0)}% 3PT + ${aFragileData.pct3.toFixed(0)}% fragile | Lead: ${awayLead}${hNoEngine?' ':''}`};
        } else if (a3Check.isHot && aFragileData && awayLead > _fragileMaxMargin) {
          // Hot + fragile but blowout  too large a margin for reliable fade
          // 3PT Fragile removed from signals (blowout case)  thesis criteria only
          thesis.criteria['3ptfragile_away'] = {met:true, strong:false, label:`${_aD} 3PT Fragile (Blowout)`, detail:`${_aD} has a fragile 3PT lead (${aFragileData.pct3.toFixed(0)}% from 3PT) but the ${awayLead}pt margin is too large. Signal needs 3-${_fragileMaxMargin}pt lead to fire. Even if 3PT% regresses, blowout margin provides too much cushion.`, value:`${awayLead}pt lead  too wide`, warn:true};
        } else if (a3Check.isHot && aFragileData && awayLead < 3) {
          // Hot + fragile but lead too small  not enough edge
          // 3PT Fragile removed from signals (tight margin case)  thesis criteria only
          thesis.criteria['3ptfragile_away'] = {met:true, strong:false, label:`${_aD} 3PT Fragile (Tight)`, detail:`${_aD} has both conditions but only a ${awayLead}pt lead. Signal needs 3-${_fragileMaxMargin}pt margin to ensure meaningful edge from 3PT regression.`, value:`${awayLead}pt lead  too tight`, warn:true};
        } else if (a3Check.isHot && !aFragileData) {
          // Hot shooting but lead not fragile enough  informational only
          // 3PT Fragile removed from signals (no fragile lead case)  thesis criteria only
          thesis.criteria['3ptfragile_away'] = {met:true, strong:false, label:`${_aD} 3PT Hot (no fragile lead)`, detail:`${_aD} is shooting ${a3Check.pn.toFixed(0)}% from 3 on ${a3Check.an} attempts  elevated, but the lead composition isn't fragile enough (needs 3PT-heavy lead vs paint-heavy opponent). Monitoring only.`, value:`${a3Check.pn.toFixed(0)}% 3PT`, warn:true};
        } else if (!a3Check.isHot && aFragileData) {
          // Fragile lead but shooting not extreme  informational only
          thesis.criteria['3ptfragile_away'] = {met:true, strong:false, label:`${_aD} Fragile Lead (not hot enough)`, detail:`${_aD}'s lead is ${aFragileData.pct3.toFixed(0)}% from 3PT  fragile composition detected, but current 3PT shooting rate isn't extreme enough to trigger. Needs 50%+ on 12+ attempts.`, value:`${aFragileData.pct3.toFixed(0)}% fragile`, warn:true};
        } else if (a3Check.isWarm) {
          // 3PT warm  no signal push (removed)
          thesis.criteria['3ptfragile_away'] = {met:false, label:`${_aD} 3PT: ${a3Check.pn.toFixed(0)}%`, detail:`Elevated but no fragile lead. Both conditions needed.`, value:'Watching'};
        } else {
          thesis.criteria['3ptfragile_away'] = {met:false, label:`${_aD} 3PT Fragile`, detail:`No 3PT fragile signal. Normal shooting range and/or no fragile lead composition.`, value:'N/A'};
        }

        // Home team: both hot 3PT AND fragile lead
        const homeLead = hS - aS;
        // If home leads with fragile 3s, check if AWAY (trailing) has enough non-3PT engine to capitalize
        const aNoEngine = homeLead > 0 && aNon3Ppm < NO_ENGINE_THRESHOLD && _gMinsNow >= 10;
        const aEngineLabel = aNoEngine ? `  BUT ${_aD} has no scoring engine (${aNon3Ppm.toFixed(1)} non-3PT PPM)  may not capitalize even if 3s regress` : '';

        if (h3Check.isHot && hFragileData && homeLead >= 3 && homeLead <= _fragileMaxMargin) {
          // 3PT Fragile REMOVED from signals array (backtest: 31.3% ML win rate, below 35.1% baseline)
          // Thesis criteria below still populate the detail panel for informational purposes
          const hEngineDetail = aNoEngine
            ? `<br><strong> Opponent Engine Check:</strong> ${_aD} is producing only ${aNon3Ppm.toFixed(1)} non-3PT points/min (threshold: ${NO_ENGINE_THRESHOLD}). Their offense is broken beyond just 3PT variance  even if ${_hD}'s 3s cool down, ${_aD} may not have the scoring engine to capitalize. <strong>Signal is weaker.</strong>`
            : `<br><strong> Opponent Engine:</strong> ${_aD} is producing ${aNon3Ppm.toFixed(1)} non-3PT points/min  they have a real scoring engine from paint/FT/mid-range. When ${_hD}'s 3s regress, ${_aD} can capitalize.`;
          thesis.criteria['3ptfragile_home'] = {met:true, strong:!aNoEngine, label:`${_hD} 3PT Fragile Lead${aNoEngine?' ':''}`, detail:`<strong>3PT Shooting:</strong> ${_hD} is shooting ${h3Check.pn.toFixed(0)}% from 3 on ${h3Check.an} attempts (${getLeagueName()} avg: ${getLeague3PtAvg()}%).<br><strong>Lead Composition:</strong> ${hFragileData.pct3.toFixed(0)}% of ${_hD}'s scoring comes from 3PT (threshold: ${getFragile3PtThreshold()}%).<br><strong>Score Margin:</strong> ${homeLead} pts  in the 3-15pt sweet spot where regression flips the game.<br><strong>Opponent Durability:</strong> ${_aD} has ${hFragileData.oppPaintPct.toFixed(0)}% non-3PT scoring  paint-heavy and sustainable.${hEngineDetail}<br><strong>Signal:</strong> ${aNoEngine ? 'Hot 3PT + fragile lead detected, but trailing team\'s offense is too weak to exploit regression. Proceed with caution.' : 'Hot 3PT + fragile lead + competitive margin. When shooting cools, lead evaporates.'}`, value:`${h3Check.pn.toFixed(0)}% 3PT + ${hFragileData.pct3.toFixed(0)}% fragile | Lead: ${homeLead}${aNoEngine?' ':''}`};
        } else if (h3Check.isHot && hFragileData && homeLead > _fragileMaxMargin) {
          // 3PT Fragile removed from signals (blowout case)  thesis criteria only
          thesis.criteria['3ptfragile_home'] = {met:true, strong:false, label:`${_hD} 3PT Fragile (Blowout)`, detail:`${_hD} has a fragile 3PT lead (${hFragileData.pct3.toFixed(0)}% from 3PT) but the ${homeLead}pt margin is too large. Signal needs 3-${_fragileMaxMargin}pt lead to fire. Even if 3PT% regresses, blowout margin provides too much cushion.`, value:`${homeLead}pt lead  too wide`, warn:true};
        } else if (h3Check.isHot && hFragileData && homeLead < 3) {
          // 3PT Fragile removed from signals (tight margin case)  thesis criteria only
          thesis.criteria['3ptfragile_home'] = {met:true, strong:false, label:`${_hD} 3PT Fragile (Tight)`, detail:`${_hD} has both conditions but only a ${homeLead}pt lead. Signal needs 3-${_fragileMaxMargin}pt margin to ensure meaningful edge from 3PT regression.`, value:`${homeLead}pt lead  too tight`, warn:true};
        } else if (h3Check.isHot && !hFragileData) {
          // 3PT Fragile removed from signals (no fragile lead case)  thesis criteria only
          thesis.criteria['3ptfragile_home'] = {met:true, strong:false, label:`${_hD} 3PT Hot (no fragile lead)`, detail:`${_hD} is shooting ${h3Check.pn.toFixed(0)}% from 3 on ${h3Check.an} attempts  elevated, but the lead composition isn't fragile enough. Monitoring only.`, value:`${h3Check.pn.toFixed(0)}% 3PT`, warn:true};
        } else if (!h3Check.isHot && hFragileData) {
          thesis.criteria['3ptfragile_home'] = {met:true, strong:false, label:`${_hD} Fragile Lead (not hot enough)`, detail:`${_hD}'s lead is ${hFragileData.pct3.toFixed(0)}% from 3PT  fragile composition detected, but 3PT shooting rate isn't extreme enough. Needs 50%+ on 12+ attempts.`, value:`${hFragileData.pct3.toFixed(0)}% fragile`, warn:true};
        } else if (h3Check.isWarm) {
          // 3PT warm  no signal push (removed)
          thesis.criteria['3ptfragile_home'] = {met:false, label:`${_hD} 3PT: ${h3Check.pn.toFixed(0)}%`, detail:`Elevated but no fragile lead. Both conditions needed.`, value:'Watching'};
        } else {
          thesis.criteria['3ptfragile_home'] = {met:false, label:`${_hD} 3PT Fragile`, detail:`No 3PT fragile signal. Normal shooting and/or no fragile lead composition.`, value:'N/A'};
        }

        // STAR COIL CHECK  Star cold (<60% pace) + competitive game + prime window
        const cM = parseFloat(clk?.split(':')[0]||getPeriodLength()), cS = parseFloat(clk?.split(':')[1]||0);
        const gMins = getElapsedMinutes(per, clk), gPct = getGamePct(per, clk);
        const scoreMargin = Math.abs(aS - hS);
        let starCoilTeams = {};
        [...aLeaders,...hLeaders].forEach(leader => {
          // NCAA: match against pre-game star database (16+ PPG, built from ESPN team leaders API)
          // NBA: match against the curated star database (23+ PPG)
          let star;
          if (isNCAA()) {
            star = ncaaStarCache.find(s => {
              const leaderLast = leader.name.toLowerCase().split(' ').pop();
              const starLast = s.name.split(' ').pop().toLowerCase();
              return leaderLast === starLast && s.team === leader.team;
            });
          } else {
            star = state.stars.find(s => leader.name.toLowerCase().includes(s.name.split(' ').pop().toLowerCase()) && s.team===leader.team);
          }
          if (star) {
            const exp = getExpectedByTime(star.ppg, gMins);
            const pr = exp>0 ? leader.pts/exp : 1;
            const side = leader.team===aA?'away':'home';
            const oppSide = side==='away'?'home':'away';
            // Star Coil: <65% pace + prime window + game within 15 pts (competitive)
            // NBA: Q2-Q3 (per 2-3). NCAA: 8-35 min elapsed (halves, not quarters)
            const _coilMaxMargin = isNCAA() ? 12 : 15;
            const _inCoilWindow = isNCAA() ? (gMins >= 8 && gMins <= 35) : (per>=2 && per<=3);
            if (pr<0.65 && _inCoilWindow && scoreMargin<=_coilMaxMargin) {
              const starTeamSide = leader.team===aA ? 'away' : 'home';
              const starTeamScore = starTeamSide==='away' ? aS : hS;
              const starTeamTrailing = (starTeamSide==='away' && aS < hS) || (starTeamSide==='home' && hS < aS);

              // ===== SUPPORTING CAST ANALYSIS (core edge strengthener) =====
              // How well are the star's teammates performing WITHOUT the star's contribution?
              // If cast is strong (90% pace), the team is competitive DESPITE the star being cold.
              // Star regression on top of a strong cast = massive swing. This is the strongest edge.
              const oppScore = starTeamSide==='away' ? hS : aS;
              const cast = analyzeSupportingCast(leader.pts, starTeamScore, oppScore, star.ppg, gMins);

              // ===== DAMAGE LOCKED CHECK =====
              const dmg = analyzeDamageLocked(gid, starTeamSide, 4, gMins);
              const damageLocked = starTeamTrailing && dmg.locked;

              // ===== SIGNAL STRENGTH CLASSIFICATION =====
              // 3 tiers based on supporting cast gap (cast score vs opponent score):
              //   ELITE: castGap  -8  cast within 8pts of opponent or leading  strongest signal
              //   STANDARD: castGap -8 to -15  cast behind but in range  normal signal
              //   WEAK: castGap < -15  cast way behind opponent  whole team broken, star alone won't save
              // Damage Locked overrides: if deficit is baked in, downgrade regardless
              // regressionFlips: star's missing pts > cast gap  regression alone closes the deficit
              let coilTier, tierEmoji, tierLabel;
              if (damageLocked) {
                coilTier = 'locked'; tierEmoji = ''; tierLabel = 'DAMAGE LOCKED';
              } else if (cast.strong) {
                coilTier = 'elite'; tierEmoji = ''; tierLabel = 'CAST STRONG';
              } else if (cast.moderate) {
                coilTier = 'standard'; tierEmoji = ''; tierLabel = 'STANDARD';
              } else {
                coilTier = 'weak'; tierEmoji = ''; tierLabel = 'CAST WEAK';
              }

              const isStrongSignal = coilTier === 'elite' || coilTier === 'standard';

              let ctx = per===2?` Half exp: ${getHalfExpected(star.ppg).toFixed(0)}`:'';
              signals.push({type:'star',text:`${tierEmoji} ${leader.name} ${leader.pts}pts (exp ~${exp.toFixed(0)}, ${(pr*100).toFixed(0)}% pace). Margin: ${scoreMargin}pts. Cast: ${cast.castScore}pts vs opp ${oppScore}pts (gap: ${cast.castGap > 0 ? '+' : ''}${cast.castGap}) ${tierLabel}.${cast.regressionFlips ? '  Regression flips lead.' : ''}${ctx}`,level:2});
              sigStar++;
              fireStarCoilAlert(leader, star, gMins, per, clk, gLabel, pr, scoreMargin);
              sendSignalNotification(`${tierEmoji} Star Coil [${tierLabel}]: ${leader.name}`, `${leader.name} ${leader.pts}pts (exp ~${exp.toFixed(0)}). Cast ${cast.castScore}pts vs opp ${oppScore} (gap: ${cast.castGap}). ${cast.regressionFlips ? 'Regression flips!' : ''} Margin: ${scoreMargin}pts.`, gid, 'star_' + leader.team);
              if (!state.signalFirstSeen[gid]) state.signalFirstSeen[gid] = Date.now();
              starCoilTeams[leader.team] = { name: leader.name, damageLocked, dmg, cast, coilTier };
              const starTeamFull = leader.team===aA ? aFull : hFull;

              // Build detailed thesis breakdown
              const oppTeamAbbr = starTeamSide==='away' ? hA : aA;
              const castDetail = `<br><strong>${cast.emoji} Supporting Cast (${cast.label}):</strong> Without ${leader.name}, teammates have <strong>${cast.castScore} pts</strong> vs ${oppTeamAbbr}'s <strong>${oppScore} pts</strong> (gap: <strong>${cast.castGap > 0 ? '+' : ''}${cast.castGap}</strong>).<br>&nbsp;&nbsp; ${leader.name} is missing ~${cast.starDeficit.toFixed(0)} pts from expected (${star.ppg} PPG  ${(gMins/getTotalGameMinutes()*100).toFixed(0)}% game = ~${cast.starExpected.toFixed(0)} exp, has ${leader.pts}).<br>&nbsp;&nbsp; ${cast.regressionFlips ? `<strong>KEY: Star's missing ${cast.starDeficit.toFixed(0)}pts > team deficit of ${Math.abs(Math.min(cast.castGap, 0))}pts.</strong> When ${leader.name} regresses to mean, the team takes the lead.` : cast.castGap >= 0 ? `<strong>Cast is already matching/beating the opponent.</strong> Star regression pushes this team into dominant territory.` : cast.strong ? `Cast is close to the opponent  within striking distance. Star regression makes this a real fight.` : cast.moderate ? `Cast is behind but game is still in range. Star regression helps but may not be enough alone.` : `<strong>Warning:</strong> Cast is ${Math.abs(cast.castGap)} pts behind the opponent. The whole team is struggling. Star regression of ~${cast.starDeficit.toFixed(0)}pts may not close a ${Math.abs(cast.castGap)}pt cast gap.`}`;

              const dmgDetail = damageLocked
                ? `<br><strong> Damage Locked:</strong> Trailing across ${dmg.snapshots} checks over ${dmg.timeSpanSec}s. Deficit: ${dmg.deficitThen}${dmg.deficitNow}pts (${dmg.trend}). Even if star + cast are strong, the hole is baked in.`
                : (starTeamTrailing && dmg.snapshots >= 2
                  ? `<br><strong>Momentum:</strong> Trailing by ${scoreMargin}pts. Trend: ${dmg.trend} (${dmg.snapshots} checks, ${dmg.timeSpanSec||'?'}s). Not locked: ${dmg.reason}.`
                  : `<br><strong>Momentum:</strong> Collecting data (${dmg.snapshots}/4 snapshots). ${dmg.reason}.`);

              const whyItMatters = coilTier === 'elite'
                ? `STRONGEST EDGE: Without ${leader.name}, the cast has ${cast.castScore}pts  only ${Math.abs(cast.castGap)}pts ${cast.castGap >= 0 ? 'AHEAD of' : 'behind'} the opponent's ${oppScore}pts.${cast.regressionFlips ? ` Star is missing ~${cast.starDeficit.toFixed(0)}pts, which is MORE than the ${Math.abs(cast.castGap)}pt gap. When ${leader.name} regresses to mean, this team takes the lead.` : ` The cast is already competing. Star regression pushes this team into dominant territory.`} The market is pricing in the star's cold stretch but ignoring that the rest of the team is holding.`
                : coilTier === 'standard'
                ? `Star is cold, game is close. Cast has ${cast.castScore}pts vs opponent's ${oppScore} (gap: ${cast.castGap}).${cast.regressionFlips ? ` Star's missing ~${cast.starDeficit.toFixed(0)}pts covers the gap.` : ''} Standard edge  star regression helps.`
                : coilTier === 'locked'
                ? `Star is cold AND deficit is locked in. Cast: ${cast.castScore}pts vs opp ${oppScore}. Despite cast effort, the hole is baked in  bet AGAINST the star's team.`
                : `CAUTION: Cast only has ${cast.castScore}pts vs opponent's ${oppScore} (gap: ${cast.castGap}). The whole team is broken, not just the star.${cast.starDeficit > 0 ? ` Star is missing ~${cast.starDeficit.toFixed(0)}pts but the cast gap is ${Math.abs(cast.castGap)}pts  regression alone can't close it.` : ''} Proceed with caution.`;

              const _coilPLabel = isNCAA() ? (per <= 2 ? `H${per}` : `OT`) : `Q${per}`;
              thesis.criteria[`star_${oppSide}`] = {met:true, strong:isStrongSignal, label:`Star Coil ${tierEmoji} [${tierLabel}]: ${leader.name} (${teamDisplay(leader.team, starTeamFull)})`, detail:`<strong>Player:</strong> ${leader.name}  averages ${star.ppg} PPG.<br><strong>Current:</strong> ${leader.pts} pts at ${_coilPLabel} ${clk} (expected ~${exp.toFixed(0)}).<br><strong>Pace:</strong> ${(pr*100).toFixed(0)}% of expected  below 65% threshold.<br><strong>Game Context:</strong> Score margin ${scoreMargin} pts. ${_coilPLabel}  prime window.${castDetail}${dmgDetail}<br><strong>Why it matters:</strong> ${whyItMatters}`, value:`${leader.pts}/${exp.toFixed(0)} pts (${(pr*100).toFixed(0)}%) | Cast gap: ${cast.castGap > 0 ? '+' : ''}${cast.castGap} | ${tierLabel}`};
            } else if (pr<0.65 && (isNCAA() ? gMins <= 35 : per<=3)) {
              // Star is cold but game not competitive or wrong window  monitoring only
              const starTeamFull2 = leader.team===aA ? aFull : hFull;
              const reason = isNCAA() ? (gMins<8 ? 'too early' : scoreMargin>_coilMaxMargin ? `blowout (${scoreMargin}pt margin)` : '') : (per<2 ? 'too early (Q1)' : scoreMargin>_coilMaxMargin ? `blowout (${scoreMargin}pt margin)` : '');
              signals.push({type:'star',text:`${leader.name} (${teamDisplay(leader.team, starTeamFull2)}) cold at ${(pr*100).toFixed(0)}% pace  but ${reason}. No coil.`,level:1});
              const windowLabel = isNCAA() ? '8-35 min' : 'Q2-Q3';
              thesis.criteria[`star_${oppSide}`] = {met:true, strong:false, label:`Star Cold (No Coil): ${leader.name}`, detail:`${leader.name} (${star.ppg} PPG) is at ${(pr*100).toFixed(0)}% pace but signal doesn't fire: ${reason || 'conditions not met'}. Star Coil needs ${windowLabel} + game within ${_coilMaxMargin} pts.`, value:`${(pr*100).toFixed(0)}% pace`, warn:true};
            } else if (pr<0.75 && gPct>=0.2) {
              const starTeamFull2 = leader.team===aA ? aFull : hFull;
              signals.push({type:'star',text:`${leader.name} (${teamDisplay(leader.team, starTeamFull2)}) ${leader.pts}pts, behind ${star.ppg} PPG pace (exp ~${exp.toFixed(0)})`,level:1});
              thesis.criteria[`star_${oppSide}`] = {met:true, strong:false, label:`Star Below Pace: ${leader.name} (${teamDisplay(leader.team, starTeamFull2)})`, detail:`${leader.name} (${star.ppg} PPG) has ${leader.pts} pts vs ${exp.toFixed(0)} expected. Below pace but not at critical 65% threshold yet.`, value:`${(pr*100).toFixed(0)}% pace`, warn:true};
            }
          }
        });

        // STAR COIL PLUS  Star cold + Opponent shooting cold (backtest verified: 57% on 208+ signals)
        const hasStar=signals.some(s=>s.type==='star'&&s.level===2);
        let activeSignals = hasStar ? 1 : 0;
        let sigStarPlus = 0;

        if (hasStar) {
          // Get opponent (leading team) FG% and 2PT% from ESPN stats
          const aFGPctLive = parseFloat(aStats.fieldGoalPct || 0) / 100;
          const hFGPctLive = parseFloat(hStats.fieldGoalPct || 0) / 100;
          const aFGMLive = parseInt(aStats.fieldGoalsMade || 0);
          const hFGMLive = parseInt(hStats.fieldGoalsMade || 0);
          const aFGALive = parseInt(aStats.fieldGoalsAttempted || 0);
          const hFGALive = parseInt(hStats.fieldGoalsAttempted || 0);
          const a2PALive = aFGALive - (parseInt(a3A) || 0);
          const h2PALive = hFGALive - (parseInt(h3A) || 0);
          const a2PMLive = aFGMLive - (parseInt(a3M) || 0);
          const h2PMLive = hFGMLive - (parseInt(h3M) || 0);
          const a2PctLive = a2PALive > 0 ? a2PMLive / a2PALive : 0;
          const h2PctLive = h2PALive > 0 ? h2PMLive / h2PALive : 0;

          Object.keys(starCoilTeams).forEach(stk => {
            const isAway = stk === aA;
            const leadFGPct = isAway ? hFGPctLive : aFGPctLive;
            const lead2Pct = isAway ? h2PctLive : a2PctLive;
            const oppTeam = isAway ? hA : aA;
            const oppTeamFull = isAway ? hFull : aFull;
            const oppD = teamDisplay(oppTeam, oppTeamFull);
            const side = isAway ? 'away' : 'home';
            const oppSide = isAway ? 'home' : 'away';

            if ((leadFGPct > 0 && leadFGPct < 0.43) || (lead2Pct > 0 && lead2Pct < 0.47)) {
              const reason = leadFGPct < 0.43
                ? `${oppD} FG% ${(leadFGPct * 100).toFixed(1)}% (< 43%)`
                : `${oppD} 2PT% ${(lead2Pct * 100).toFixed(1)}% (< 47%)`;
              signals.push({
                type: 'starCoilPlus', text: `STAR COIL+: ${reason}. Star cold + opponent shooting cold = double regression edge.`,
                level: 2
              });
              sigStarPlus++;
              activeSignals = 2;
              signalLevel = 2;
              if (!state.signalFirstSeen[gid]) state.signalFirstSeen[gid] = Date.now();
              sendSignalNotification('STAR COIL+: ' + gLabel, `Star cold + ${reason}. Double regression edge.`, gid, 'starcoilplus_' + stk);
              thesis.criteria['starcoilplus'] = {
                met: true, strong: true,
                label: `Star Coil+ (Double Edge)`,
                detail: `<strong>Star Coil Plus:</strong> Star is cold AND ${reason}.<br><strong>Backtest:</strong> This combination wins 57% on moneyline (208+ signals tested).<br><strong>Why it works:</strong> The opponent's lead is built on the star being cold AND the opponent shooting unsustainably well from inside. Both will regress  double edge.`,
                value: reason
              };
            }
          });
        }

        // Any strict L2 signal (solo or combined) should be actionable and recorded
        const hasAnyStrictL2 = signals.some(s => s.level === 2);
        if (activeSignals >= 2) { signalLevel = 2; }
        else if (hasAnyStrictL2) { signalLevel = 2; }
        else if (signals.some(s => s.level >= 1)) { signalLevel = 1; }

        // Track which games have which signals for chip click-to-expand
        const _gameInfo = { game: gLabel, gameFull: gLabelFull, aScore: aS, hScore: hS, per, clk, detail, eventId: gid };
        if (hasStar) signalGames['star'].push({ ..._gameInfo, sigDetail: signals.filter(s=>s.type==='star'&&s.level===2).map(s=>s.text).join('; ') });
        if (sigStarPlus > 0) {
          if (!signalGames['starcoilplus']) signalGames['starcoilplus'] = [];
          signalGames['starcoilplus'].push({ ..._gameInfo, sigDetail: signals.filter(s=>s.type==='starCoilPlus'&&s.level===2).map(s=>s.text).join('; ') });
        }

        // Determine bet side and build thesis logic
        if (signalLevel >= 2) {
          let betTeam = '', fadeTeam = '', reasons = [];

          // Star Coil fade weights (only signal system now)
          let awayFade=0, homeFade=0;
          const aStarCoil = starCoilTeams[aA];
          const hStarCoil = starCoilTeams[hA];
          if (aStarCoil?.coilTier === 'elite') { homeFade += 1.5; }
          else if (aStarCoil?.coilTier === 'standard') { homeFade += 1; }
          else if (aStarCoil?.coilTier === 'locked') { awayFade += 1; }
          if (hStarCoil?.coilTier === 'elite') { awayFade += 1.5; }
          else if (hStarCoil?.coilTier === 'standard') { awayFade += 1; }
          else if (hStarCoil?.coilTier === 'locked') { homeFade += 1; }

          // Star Coil Plus adds extra weight in same direction
          if (sigStarPlus > 0) {
            if (aStarCoil) homeFade += 0.5;
            if (hStarCoil) awayFade += 0.5;
          }

          // No conflict detection needed  only Star Coil drives direction now
          const _conflicting = false;
          if (_conflicting) {
            console.log(`[Conflict] ${gLabel}: awayFade=${awayFade.toFixed(1)}, homeFade=${homeFade.toFixed(1)}  downgraded from COMBINED`);
          }

          // Double Regression caveat removed  3PT Fragile no longer fires as actionable signal
          let doubleRegression = false;

          // ===== HOME COURT FACTOR (NCAA ONLY  BIDIRECTIONAL BOOSTER) =====
          // NCAA home court = 3.5-4 pts (vs NBA 2.5). This is a structural force.
          // BOOSTER, not standalone signal. Amplifies existing signals:
          //   - When signals say bet HOME: tailwind (+0.5 fade weight + Kelly boost)
          //   - When signals say bet ROAD: headwind (+0.5 fade weight = penalty for road bet)
          // KEY CHANGE: In NCAA, 1 strict signal + home court tailwind = combined-level Kelly.
          // Rationale: Each standalone signal is already 5-condition strict. Fewer possessions
          // in NCAA = stronger regression certainty. Home court adds a 6th independent factor
          // (crowd energy, ref bias, travel fatigue) that compounds the edge. Requiring a
          // second strict signal to fire simultaneously is over-restrictive for NCAA.
          // NBA: NO CHANGE  this factor does not apply. NBA lines are sharper, need true combined.
          let homeCourtEdge = false;
          let homeCourtBoost = 0; // Kelly signal count boost (0 or 1)
          if (isNCAA()) {
            const _hcFactor = 0.5;
            if (awayFade > 0) {
              awayFade += _hcFactor; // boost fading away = tailwind for home bet
              homeCourtEdge = true;
              homeCourtBoost = 1;    // home court tailwind  treat as combined-level Kelly
            }
            if (homeFade > 0) {
              homeFade += _hcFactor; // boost fading home = headwind for road bet
              // No Kelly boost for road bets  headwind doesn't add confidence
            }
          }

          if (awayFade > homeFade) { betTeam = hA; fadeTeam = aA; }
          else if (homeFade > awayFade) { betTeam = aA; fadeTeam = hA; }
          else if (awayFade > 0) { betTeam = hA; fadeTeam = aA; }
          else { betTeam = aS < hS ? aA : hA; fadeTeam = aS < hS ? hA : aA; }

          // Build the narrative
          if (aStarCoil?.coilTier === 'elite') reasons.push(` ${aStarCoil.name} (${_aD}) is coiled. Cast: ${aStarCoil.cast.castScore}pts vs opp (gap: ${aStarCoil.cast.castGap > 0 ? '+' : ''}${aStarCoil.cast.castGap}).${aStarCoil.cast.regressionFlips ? ' Star regression alone flips the lead.' : ' Cast is holding  star regression = surge.'} Strongest edge.`);
          else if (aStarCoil?.coilTier === 'standard') reasons.push(` ${aStarCoil.name} (${_aD}) is coiled. Cast gap: ${aStarCoil.cast.castGap}. Standard edge.`);
          else if (aStarCoil?.coilTier === 'locked') reasons.push(` ${aStarCoil.name} (${_aD}) is coiled BUT damage locked  deficit baked in. Fade ${_aD}.`);
          else if (aStarCoil?.coilTier === 'weak') reasons.push(` ${aStarCoil.name} (${_aD}) is coiled but cast gap is ${aStarCoil.cast.castGap}  whole team broken. No directional weight.`);
          if (hStarCoil?.coilTier === 'elite') reasons.push(` ${hStarCoil.name} (${_hD}) is coiled. Cast: ${hStarCoil.cast.castScore}pts vs opp (gap: ${hStarCoil.cast.castGap > 0 ? '+' : ''}${hStarCoil.cast.castGap}).${hStarCoil.cast.regressionFlips ? ' Star regression alone flips the lead.' : ' Cast is holding  star regression = surge.'} Strongest edge.`);
          else if (hStarCoil?.coilTier === 'standard') reasons.push(` ${hStarCoil.name} (${_hD}) is coiled. Cast gap: ${hStarCoil.cast.castGap}. Standard edge.`);
          else if (hStarCoil?.coilTier === 'locked') reasons.push(` ${hStarCoil.name} (${_hD}) is coiled BUT damage locked  deficit baked in. Fade ${_hD}.`);
          else if (hStarCoil?.coilTier === 'weak') reasons.push(` ${hStarCoil.name} (${_hD}) is coiled but cast gap is ${hStarCoil.cast.castGap}  whole team broken. No directional weight.`);
          if (sigStarPlus > 0) reasons.push(`STAR COIL+: Opponent shooting cold. Star cold + opponent cold = double regression. Backtest: 57% win rate.`);

          // Home Court Factor narrative (NCAA only  homeCourtEdge is always false for NBA)
          if (isNCAA() && betTeam === hA) {
            const boostLabel = thesis.homeCourtBoost ? ' Kelly boosted to combined-level.' : '';
            reasons.push(` HOME COURT TAILWIND: Betting ${_hD} (home team). NCAAB home court ~3.5-4 pts  crowd energy + regression signals = double tailwind.${boostLabel}`);
            thesis.criteria['homecourt_boost'] = { met: true, strong: true, label: ` Home Court Booster`, detail: `<strong>Home Court Booster (NCAA):</strong> ${_hD} is at home. NCAAB home court averages ~3.5-4 pts  an independent structural factor.<br><strong>Why this is a BOOSTER, not a standalone signal:</strong> Home court alone doesn't generate alpha. But when a strict signal fires AND the bet is on the home team, the home court compounds the edge:<br>&nbsp;&nbsp; Crowd energy sustains runs triggered by regression<br>&nbsp;&nbsp; Ref bias in foul calls (documented ~60% home foul advantage)<br>&nbsp;&nbsp; Travel fatigue amplifies road team's 3PT regression<br><strong>Kelly Impact:</strong> Single strict signal + home court booster = combined-level Kelly sizing.${activeSignals >= 2 ? ' (Already combined  booster adds further confidence.)' : ` Effective signal count: ${activeSignals}  ${effectiveSignals}.`}<br><strong>The math:</strong> Each standalone signal is already 5-condition strict. Fewer NCAA possessions = stronger regression certainty. Home court is the 6th independent factor. Requiring a 2nd strict signal to also fire simultaneously is over-restrictive for NCAA.`, value: `Tailwind (+0.5 weight, +1 Kelly boost)` };
          } else if (isNCAA() && betTeam === aA && homeFade > 0) {
            reasons.push(` HOME COURT HEADWIND: Betting ${_aD} (road team). NCAAB home court ~3.5-4 pts works against road comebacks  signal must overcome structural disadvantage.`);
            thesis.criteria['homecourt_boost'] = { met: true, strong: false, label: ` Home Court Headwind`, detail: `<strong>Home Court Headwind:</strong> ${_aD} is on the road. NCAAB home court averages ~3.5-4 pts working AGAINST the road team.<br><strong>Why it weakens your signal:</strong> Even if regression happens, the home crowd fuels counter-runs. Road teams need stronger regression to overcome the structural disadvantage.<br><strong>Kelly Impact:</strong> No Kelly boost for road bets. Signal must stand on its own merit.<br><strong>Impact:</strong> Headwind weight applied (+0.5 to fade). No Kelly confidence boost.`, value: `Road headwind (+0.5 weight, no Kelly boost)` };
          }

          const strongCriteria = Object.values(thesis.criteria).filter(c => c.met && c.strong).length;
          const allCriteria = Object.values(thesis.criteria).filter(c => c.met).length;

          const betTeamFull = betTeam === aA ? aFull : hFull;
          const fadeTeamFull = fadeTeam === aA ? aFull : hFull;
          thesis.betSide = betTeam;
          thesis.betSideFull = betTeamFull;
          thesis.fadeSide = fadeTeam;
          thesis.fadeSideFull = fadeTeamFull;
          thesis.betLogic = reasons.join('. ') + '.';
          // NCAA: home court booster counts as strong criteria for confidence level
          const _boostCriteria = thesis.homeCourtBoost ? 1 : 0;
          thesis.confidence = (strongCriteria + _boostCriteria) >= 3 ? 'high' : (strongCriteria + _boostCriteria) >= 2 ? 'high' : allCriteria >= 2 ? 'medium' : 'low';
          thesis.doubleRegression = doubleRegression;
          // Double regression caveat: downgrade confidence  don't auto-lock
          if (doubleRegression) {
            thesis.confidence = thesis.confidence === 'high' ? 'medium' : 'low';
          }
          thesis.strongCount = strongCriteria;
          thesis.totalMet = allCriteria;
          thesis.signals = signals;
          thesis.signalLevel = signalLevel;
          thesis.sigStarPlus = sigStarPlus;
          thesis.homeCourtEdge = homeCourtEdge && betTeam === hA;
          thesis.homeCourtBoost = homeCourtBoost > 0 && betTeam === hA;
          // Effective signal count: base signals + home court booster (NCAA only, home bets only)
          const effectiveSignals = activeSignals + (thesis.homeCourtBoost ? homeCourtBoost : 0);
          // Urgency: how much game runway remains for regression
          const _urgency = getUrgency(per, clk);
          thesis.urgency = _urgency;
          const _tOdds = matchOdds(aA, hA, aFull, hFull);
          let _betML = null, _implP = 0;
          if (_tOdds) {
            _betML = betTeam === aA ? _tOdds.awayML : _tOdds.homeML;
            _implP = _betML < 0 ? Math.abs(_betML)/(Math.abs(_betML)+100) : 100/(_betML+100);
            thesis.marketOdds = _betML;
            thesis.impliedP = _implP;
            // Store odds key for LEC tracking
            thesis.oddsKey = _tOdds.away + ' vs ' + _tOdds.home;
            const _drMult = doubleRegression ? 0.5 : 1; // halve Kelly when double regression detected
            const _k = kellySize(_implP, _betML, null, effectiveSignals, _urgency.mult * _drMult);
            thesis.kellyPct = _k.fStar;
            thesis.kellyBet = _k.bet;
            thesis.kellyEdge = _k.edge;
            thesis.estimatedP = _k.p;
          }
          thesis.eventId = event.id;
          thesis.betTeamAbbr = betTeam;
          // Always log the bet  use default -110 odds if live odds unavailable
          const _logOdds = _betML || -110;
          const _logImplP = _betML ? _implP : 0.524; // -110 implied = 52.4%
          autoLogBet(event.id, betTeam, 'ML', signals.filter(x=>x.level===2).map(x=>x.type), _logOdds, _logImplP, effectiveSignals, _urgency.mult);
          gameTheses.push(thesis);
        }

        // Counterfactual: track near-miss signals (level 1 only, no level 2)
        // Games where conditions were developing but didn't fully trigger
        if (signalLevel === 1 && isLive) {
          const l1signals = signals.filter(s => s.level === 1);
          if (l1signals.length > 0) {
            const nmKey = event.id + '_nm';
            if (!state.nearMisses.find(n => n.key === nmKey)) {
              const trailing = aS < hS ? aA : hA;
              state.nearMisses.push({
                key: nmKey, eventId: event.id, game: gLabel,
                awayTeam: aA, homeTeam: hA,
                hypotheticalSide: trailing,
                signals: l1signals.map(s => s.type),
                signalTexts: l1signals.map(s => s.text),
                awayScore: aS, homeScore: hS, period: per, clock: clk,
                timestamp: Date.now(), mode: currentMode,
                gameCompleted: false, finalAwayScore: null, finalHomeScore: null, wouldHaveWon: null
              });
              if (state.nearMisses.length > 300) state.nearMisses = state.nearMisses.slice(-200);
              localStorage.setItem('nearMisses', JSON.stringify(state.nearMisses));
            }
          }
        }
      }

      const cc = signalLevel===2?'signal-fire':signalLevel===1?'signal-warn':'';
      const hc = isLive?'game-card-header live-pulse':'game-card-header';

      const bar3 = (p,m,a,t) => {
        const v=parseFloat(p)||0, bc=v>=50?'hot':v>=getLeague3PtAvg()?'normal':'cold';
        return `<div class="stat-bar-row"><span class="stat-bar-label">${t} 3PT%</span><div class="stat-bar-track"><div class="stat-bar-fill ${bc}" style="width:${Math.min(v,100)}%">${v.toFixed(0)}%</div><div class="stat-bar-avg" style="left:${getLeague3PtAvg()}%" data-label="${getLeague3PtAvg()}%"></div></div><span class="stat-bar-value">${m||'-'}/${a||'-'}</span></div>`;
      };

      // Durability bars
      let durabilityHTML = '';
      if (isLive && (aS > 0 || hS > 0)) {
        const aDur = analyzeScoringDurability(aA, aS, a3M, hS);
        const hDur = analyzeScoringDurability(hA, hS, h3M, aS);
        const durBar = (team, dur) => {
          if (dur.pct3 <= 0) return '';
          const cls = dur.durability;
          const w = Math.min(dur.pct3, 100);
          const col = dur.fragile ? 'var(--red)' : dur.durable ? 'var(--green)' : 'var(--accent)';
          return `<div class="durability-bar ${cls}"><span>${team}</span><div class="durability-meter"><div class="durability-meter-fill" style="width:${w}%;background:${col};"></div></div><span>${dur.label}</span></div>`;
        };
        durabilityHTML = durBar(aA, aDur) + durBar(hA, hDur);
      }

      // FT info
      let foulHTML = '';
      if (isLive && (aFTA > 0 || hFTA > 0)) {
        const ftGap = Math.abs(aFTA - hFTA);
        foulHTML = `<div class="stat-bar-row"><span class="stat-bar-label">FTA</span><span style="flex:1;font-size:11px;">${aA}: ${aFTA} | ${hA}: ${hFTA}</span></div>`;
      }

      const isFav = state.favorites.includes(gid);
      const periodLabel = isNCAA() ? (per <= 2 ? `H${per}` : `OT${per-2}`) : `Q${per}`;
      const _oddsHTML = buildOddsHTML(aA,hA,aFull,hFull,comp.odds?.[0]);
      const _liveSpreadHTML = ''; // spread now included in buildOddsHTML

      // Signal summary for card header
      const sigSummary = signals.filter(s=>s.level===2).map(s => {
        const icons = {'3pt':'3PT','star':'STAR','fragile':'FRAG','combined':'COMBO'};
        return icons[s.type] || s.type.toUpperCase();
      });

      cards += `<div class="game-card ${cc}" data-game-id="${gid}">
        <div class="${hc}">
          <span>${isLive ? '<span style="color:var(--red);font-weight:700;">LIVE</span> ' + periodLabel + ' ' + clk : 'UPCOMING'}</span>
          <span style="display:flex;align-items:center;gap:6px;">
            ${sigSummary.length ? '<span style="font-size:9px;font-weight:700;color:var(--accent);background:var(--accent-light);padding:1px 6px;border-radius:3px;">' + sigSummary.join(' + ') + '</span>' : ''}
            <span class="fav-star" onclick="toggleFavorite('${gid}')" style="cursor:pointer;font-size:14px;">${isFav?'\u2605':'\u2606'}</span>
          </span>
        </div>
        <div class="game-card-body">
          <!-- SCOREBOARD -->
          <div class="game-teams">
            <div class="team-block">
              <div class="team-name">${teamLogoImg(aLogo, 20)}${teamDisplayShort(aA, aFull)}</div>
              <div class="team-record">${aRec}</div>
              ${teamProfileHTML(aA, 'away', aLogo)}
              <div class="team-score">${isLive?aS:'-'}</div>
            </div>
            <div class="vs-block">
              <div class="vs-text" style="font-size:11px;font-weight:500;color:var(--text-muted);opacity:0.6;">vs</div>
            </div>
            <div class="team-block">
              <div class="team-name">${teamLogoImg(hLogo, 20)}${teamDisplayShort(hA, hFull)}</div>
              <div class="team-record">${hRec}</div>
              ${teamProfileHTML(hA, 'home', hLogo)}
              <div class="team-score">${isLive?hS:'-'}</div>
            </div>
          </div>
          ${gameLinksHTML(espnLink, leaguePassLink)}
          <!-- ODDS -->
          ${_oddsHTML}
          ${_liveSpreadHTML}
          <!-- LIVE STATS -->
          ${isLive?`<div class="stat-bars">
            ${bar3(a3P,a3M,a3A,aA)}
            ${bar3(h3P,h3M,h3A,hA)}
            ${foulHTML}
          </div>
          ${durabilityHTML}
          ${(()=>{
            const bx = _boxscoreMap[gid];
            const getTeamTop3 = (side, teamAbbr) => {
              const top3 = teamScorerCache[teamAbbr] || [];
              const roster = bx?.[side] || [];
              if (roster.length === 0 && top3.length === 0) return [];
              // Start with season top scorers who are actually playing
              const result = [];
              const usedNames = new Set();
              top3.forEach(s => {
                const sLast = s.name.split(' ').pop().toLowerCase();
                const player = roster.find(p => p.name.toLowerCase().split(' ').pop() === sLast);
                if (player) {
                  result.push({ name: s.name, pts: player.pts });
                  usedNames.add(player.name.toLowerCase());
                }
              });
              // Backfill with top scorers from boxscore if we have <3
              if (result.length < 3) {
                roster
                  .filter(p => p.pts > 0 && !usedNames.has(p.name.toLowerCase()))
                  .sort((a, b) => b.pts - a.pts)
                  .slice(0, 3 - result.length)
                  .forEach(p => result.push({ name: p.name, pts: p.pts }));
              }
              return result.slice(0, 3);
            };
            const aTop3 = getTeamTop3('away', aA);
            const hTop3 = getTeamTop3('home', hA);
            if (aTop3.length === 0 && hTop3.length === 0) return '';
            const renderPlayer = (p) => {
              const lastName = p.name.split(' ').pop();
              return `<div style="display:flex;align-items:center;gap:6px;padding:2px 0;"><strong style="min-width:75px;">${lastName}</strong> <span>${p.pts}pts</span></div>`;
            };
            const renderTeam = (abbr, players) => {
              if (players.length === 0) return '';
              return `<div style="flex:1;padding:5px 8px;background:var(--bg);border-radius:6px;"><div style="font-size:9px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px;margin-bottom:3px;">${abbr}</div>${players.map(renderPlayer).join('')}</div>`;
            };
            return `<div style="display:flex;gap:8px;margin-top:6px;font-size:11px;">${renderTeam(aA, aTop3)}${renderTeam(hA, hTop3)}</div>`;
          })()}`:''}
          <!-- SIGNALS -->
          ${signals.length?(()=>{
            const rec=getRecommendation(aS,hS,aA,hA,per,clk,signalLevel);
            let titleText,recDetail='',betBtn='';
            if(signalLevel<2){
              titleText='DEVELOPING';
            } else if(rec.type==='ML'){
              titleText=`EDGE \u2014 ML PLAY: ${rec.side} ML`;
              recDetail=`<div style="font-size:11px;margin-top:4px;font-weight:700;color:var(--green);">&#x1F4B0; ${rec.reasoning}</div>`;
              betBtn=`<div style="margin-top:6px;"><button class="btn btn-orange btn-sm" onclick="openLogModal('${aA} @ ${hA}','${rec.side} ML','Mean Reversion - ML')">Log ML Bet (${rec.units}u)</button></div>`;
            } else if(rec.type==='SPREAD'){
              titleText=`EDGE \u2014 SPREAD: ${rec.side} ${rec.spreadLine}`;
              recDetail=`<div style="font-size:11px;margin-top:4px;font-weight:700;color:var(--purple);">&#x1F3AF; ${rec.reasoning}</div>`;
              betBtn=`<div style="margin-top:6px;"><button class="btn btn-purple btn-sm" onclick="openLogModal('${aA} @ ${hA}','${rec.side} ${rec.spreadLine}','Mean Reversion - Spread')">Log Spread Bet (${rec.units}u)</button></div>`;
            } else {
              titleText='EDGE \u2014 WATCH';
              recDetail=`<div style="font-size:11px;margin-top:4px;font-weight:700;color:var(--text-muted);">&#x1F440; ${rec.reasoning}</div>`;
            }
            const bgColor=signalLevel===2?(rec.type==='WATCH'?'var(--accent-light)':'var(--accent-light)'):'var(--orange-light)';
            const borderColor=signalLevel===2?'var(--accent)':'var(--orange)';
            const titleColor=signalLevel===2?'var(--accent)':'var(--orange)';
            return `<div style="margin-top:8px;padding:8px 10px;border-radius:6px;background:${bgColor};border-left:3px solid ${borderColor};">
              <div style="font-size:10px;font-weight:800;color:${titleColor};margin-bottom:4px;letter-spacing:0.5px;">${titleText}</div>
              ${signals.map(s=>`<div style="font-size:11px;color:var(--text-secondary);line-height:1.5;">${s.level===2?'&#x1F525;':'&#x26A0;&#xFE0F;'} ${s.text}</div>`).join('')}
              ${recDetail}
              ${betBtn}
              ${state.signalFirstSeen[gid]?`<div style="font-size:9px;color:var(--text-muted);margin-top:4px;">\u23F1 ${Math.floor((Date.now()-state.signalFirstSeen[gid])/60000)}m ago</div>`:''}
            </div>`;
          })():`<div style="margin-top:8px;padding:6px 10px;border-radius:6px;background:var(--bg);border-left:3px solid var(--border);"><div style="font-size:10px;font-weight:700;color:var(--text-muted);letter-spacing:0.5px;">NO SIGNAL  DO NOT BET</div><div style="font-size:10px;color:var(--text-muted);margin-top:2px;">Wait for edge. No signal = no edge = no bet.</div></div>`}
        </div>
      </div>`;

      // 3PT TRACKER CARD
      if (isLive) {
        const ap=parseFloat(a3P)||0, hp=parseFloat(h3P)||0;
        const aHot=ap>=50&&parseInt(a3A)>=8, hHot=hp>=50&&parseInt(h3A)>=8;
        const aWarm=ap>=45&&parseInt(a3A)>=6&&!aHot, hWarm=hp>=45&&parseInt(h3A)>=6&&!hHot;
        const cb=(aHot||hHot)?'hot-card':(aWarm||hWarm)?'warm-card':'';
        const _pCount=isNCAA()?2:4,_pPfx=isNCAA()?'H':'Q';const qBoxes=(t,p,m,a)=>{const pv=parseFloat(p)||0,mv=parseInt(m)||0,av=parseInt(a)||0;let b='';for(let q=1;q<=_pCount;q++){const act=q===per,past=q<per;if(past||act){const hc2=pv>=50&&av>=8&&act?'hot-q':act?'active-q':'';b+=`<div class="qtr-box ${hc2}"><div class="qtr-label">${_pPfx}${q}${act?' *':''}</div><div class="qtr-value ${act&&pv>=50?'hot-val':'normal-val'}">${act?pv.toFixed(0)+'%':'-'}</div><div class="qtr-detail">${act?mv+'/'+av:'done'}</div></div>`;}else b+=`<div class="qtr-box"><div class="qtr-label">${_pPfx}${q}</div><div class="qtr-value normal-val">-</div><div class="qtr-detail">-</div></div>`;}return b;};
        const tRow=(t,p,m,a,hot,warm)=>{const badge=hot?'<span class="signal-badge signal-fire">UNSUSTAINABLE</span>':warm?'<span class="signal-badge signal-moderate">ELEVATED</span>':'<span class="signal-badge signal-none">Normal</span>';return `<div style="margin-bottom:12px;"><div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;"><span style="font-weight:800;font-size:14px;color:var(--text-primary);">${t}</span>${badge}</div>${bar3(p,m,a,t)}<div class="qtr-grid">${qBoxes(t,p,m,a)}</div></div>`;};
        tpCards+=`<div class="three-pt-card ${cb}"><div class="three-pt-card-header"><span style="display:inline-flex;align-items:center;gap:4px;">${teamLogoImg(aLogo,16)}${gLabel}${teamLogoImg(hLogo,16)}</span><span>${periodLabel} ${clk}</span></div><div class="three-pt-card-body">${tRow(aA,a3P,a3M,a3A,aHot,aWarm)}${tRow(hA,h3P,h3M,h3A,hHot,hWarm)}${(aHot||hHot)?`<div style="text-align:center;margin-top:6px;"><button class="btn btn-purple btn-sm" onclick="openLogModal('${gLabel}','3PT Reg','3PT Regression')">Log 3PT Bet</button></div>`:''}</div></div>`;
      }
    }

    grid.innerHTML = cards || `<div class="empty-state" style="grid-column:1/-1;"><p>No games.</p></div>`;
    tpGrid.innerHTML = tpCards || `<div class="empty-state" style="grid-column:1/-1;"><p>No live games.</p></div>`;

    // Signal Priority: Sort gameTheses by strength
    gameTheses.sort((a,b) => (b.strongCount||0) - (a.strongCount||0));

    // Build Quick Bet Action Cards
    const qbPanel = document.getElementById('quick-bet-panel');
    const qbCards = document.getElementById('quick-bet-cards');
    if (gameTheses.length > 0) {
      qbPanel.style.display = 'block';
      qbCards.innerHTML = gameTheses.map(t => {
        let sigs = t.signals.filter(s=>s.level===2).map(s => {
          const badges = {'3pt':'3PT','star':'STAR','fragile':'FRAGILE'};
          return '<span class="signal-badge badge-' + s.type + '">' + (badges[s.type]||s.type.toUpperCase()) + '</span>';
        }).join(' ');
        if (t.homeCourtBoost) sigs += ' <span class="signal-badge badge-road"> HOME BOOST</span>';
        else if (t.homeCourtEdge) sigs += ' <span class="signal-badge badge-road">HOME COURT</span>';
        const _urg = t.urgency || { level: 'PRIME', icon: '', color: 'var(--green)' };
        sigs += ' <span class="signal-badge" style="background:' + _urg.color + ';color:#fff;font-size:9px;">' + _urg.icon + ' ' + _urg.level.replace('_', ' ') + '</span>';
        const oddsStr = t.marketOdds ? ' @ ' + (t.marketOdds > 0 ? '+' : '') + t.marketOdds : '';
        const kellyStr = t.kellyPct ? ' (Kelly: ' + (t.kellyPct*100).toFixed(1) + '%)' : '';
        const elapsed = state.signalFirstSeen[t.eventId] ? Math.floor((Date.now() - state.signalFirstSeen[t.eventId]) / 60000) : 0;
        const elapsedStr = elapsed > 0 ? ' \u2022 Signal active ' + elapsed + 'm' : ' \u2022 NEW';
        return '<div style="background:var(--card-bg);border:1px solid var(--accent);border-radius:var(--radius);padding:14px 18px;margin-bottom:10px;display:flex;justify-content:space-between;align-items:center;box-shadow:var(--shadow-sm);animation:slideUp 0.3s ease;border-left:4px solid ' + _urg.color + ';">' +
          '<div><div style="font-size:14px;font-weight:800;color:var(--accent);letter-spacing:-0.3px;display:flex;align-items:center;gap:5px;">' + teamLogoImg(t.betSide === t.aTeam ? t.aLogo : t.hLogo, 20) + 'BET ' + t.betSide + ' ML' + oddsStr + '</div>' +
          '<div style="font-size:11px;color:var(--text-secondary);margin-top:3px;">' + t.game + ' \u2022 ' + (isNCAA() ? ((t.per||0)<=2 ? 'H'+(t.per||'?') : 'OT') : 'Q'+(t.per||'?')) + ' ' + (t.clk||'') + kellyStr + elapsedStr + '</div>' +
          '<div style="margin-top:6px;display:flex;gap:4px;flex-wrap:wrap;">' + sigs + '</div></div>' +
          '<div style="text-align:right;padding-left:16px;"><div style="font-size:24px;font-weight:900;color:var(--accent);letter-spacing:-1px;line-height:1;">' + (t.strongCount||0) + '</div><div style="font-size:9px;font-weight:600;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px;margin-top:2px;">SIGNALS</div></div></div>';
      }).join('');
    } else {
      qbPanel.style.display = 'none';
      qbCards.innerHTML = '';
    }

    // Record signal history
    gameTheses.forEach(t => {
      const histKey = t.eventId + '_' + (t.betSide||'');
      const existing = state.signalHistory.find(h => h.key === histKey);
      if (!existing) {
        state.signalHistory.push({
          key: histKey, game: t.game||'', betSide: t.betSide||'', signals: (t.signals||[]).filter(s=>s.level===2).map(s=>s.type),
          strongCount: t.strongCount||0, confidence: t.confidence||'', odds: t.marketOdds||0,
          timestamp: Date.now(), date: new Date().toLocaleDateString()
        });
        if (state.signalHistory.length > 200) state.signalHistory = state.signalHistory.slice(-150);
        localStorage.setItem('signalHistory', JSON.stringify(state.signalHistory));
      }
    });

    // Auto-track signals for backtest
    gameTheses.forEach(t => {
      if (t.signalLevel >= 2 && t.betSide) {
        const rec = getRecommendation(t.aScore, t.hScore, t.aTeam, t.hTeam, t.per, t.clk, t.signalLevel);
        autoTrackSignal(t, rec);
      }
    });


    // Update counts
    document.getElementById('live-star-signals').textContent = sigStar;
    // Star Coil Plus count  aggregate from all games
    const totalStarPlus = gameTheses.reduce((sum, t) => sum + (t.sigStarPlus || 0), 0);
    const scpEl = document.getElementById('live-starcoilplus-signals');
    if (scpEl) scpEl.textContent = totalStarPlus;
    document.getElementById('threept-hot-count').textContent = hotTeams;
    document.getElementById('threept-warm-count').textContent = warmTeams;

    const totalSigs = sigStar;
    if (totalSigs>0) { document.getElementById('live-badge').style.display='inline'; document.getElementById('live-badge').textContent=totalSigs; }
    else document.getElementById('live-badge').style.display='none';
    if (hotTeams>0) { document.getElementById('threept-badge').style.display='inline'; document.getElementById('threept-badge').textContent=hotTeams; }

    // EDGE THESIS PANEL
    const etc = document.getElementById('edgeThesisContainer');
    const etCards = document.getElementById('edgeThesisCards');
    if (gameTheses.length > 0) {
      etc.classList.add('active');
      document.getElementById('thesisCount').textContent = gameTheses.length + ' LIVE';
      // Sort by confidence (high first)
      gameTheses.sort((a,b) => (b.strongCount||0) - (a.strongCount||0));
      etCards.innerHTML = gameTheses.map(t => {
        const confDots = Array.from({length:5}, (_,i) => {
          if (i < t.strongCount) return `<div class="conf-dot lit-red"></div>`;
          if (i < t.totalMet) return `<div class="conf-dot lit"></div>`;
          return `<div class="conf-dot"></div>`;
        }).join('');
        const confCls = t.confidence==='high'?'high':t.confidence==='medium'?'medium':'low';
        const scoreDiff = Math.abs(t.aScore - t.hScore);
        const leading = t.aScore > t.hScore ? teamDisplay(t.aTeam, t.aTeamFull) : t.hScore > t.aScore ? teamDisplay(t.hTeam, t.hTeamFull) : 'TIE';
        const trailing = t.aScore > t.hScore ? teamDisplay(t.hTeam, t.hTeamFull) : t.hScore > t.aScore ? teamDisplay(t.aTeam, t.aTeamFull) : '';

        // Build criteria cards
        const criteriaKeys = ['star_away','star_home','starcoilplus','3ptfragile_away','3ptfragile_home'];
        const criteriaHTML = criteriaKeys.map(k => {
          const c = t.criteria[k];
          if (!c) return '';
          const cls = c.met ? (c.strong ? 'met' : 'met') : 'not-met';
          const icon = c.met ? (c.strong ? '&#x1F525;' : '&#x26A0;&#xFE0F;') : '&#x2796;';
          const valCls = c.met ? (c.strong ? '' : 'warn') : 'neg';
          return `<div class="criteria-item ${cls}">
            <span class="criteria-check">${icon}</span>
            <div class="criteria-text">
              <span class="criteria-label">${c.label}</span>
              <span class="criteria-value ${valCls}">${c.value}</span>
              <span class="criteria-detail">${c.detail}</span>
            </div>
          </div>`;
        }).filter(Boolean).join('');

        const betSideDisplay = teamDisplay(t.betSide, t.betSideFull);
        const fadeSideDisplay = teamDisplay(t.fadeSide, t.fadeSideFull);
        const aTeamDisplay = teamDisplay(t.aTeam, t.aTeamFull);
        const hTeamDisplay = teamDisplay(t.hTeam, t.hTeamFull);

        return `<div class="thesis-card">
          <div class="thesis-game-bar">
            <div>
              <div class="thesis-game-label" style="display:flex;align-items:center;gap:6px;">${teamLogoImg(t.aLogo, 18)}${t.gameFull || t.game}${teamLogoImg(t.hLogo, 18)}</div>
              <div class="thesis-game-period">${isNCAA() ? (t.per<=2 ? 'H'+t.per : 'OT'+(t.per-2)) : 'Q'+t.per} ${t.clk} ${leading!=='TIE'?`| ${leading} leads by ${scoreDiff}`:'| Tied'}</div>
            </div>
            <div class="thesis-confidence">
              <div class="conf-meter">${confDots}</div>
              <span class="conf-label ${confCls}">${t.totalMet} criteria met</span>
            </div>
          </div>
          <div class="thesis-body">
            <div class="thesis-bet-line">
              <div>
                <div class="thesis-bet-action">BET ${betSideDisplay} ML ${t.marketOdds ? "(" + (t.marketOdds > 0 ? "+" : "") + t.marketOdds + ")" : ""}</div>${t.kellyPct ? '<div style="color:var(--green);font-size:12px;margin-top:4px"><strong>KELLY:</strong> ' + t.kellyPct + '% of bankroll ($' + t.kellyBet + ') &bull; <strong>Our P:</strong> ' + t.estimatedP + '% vs <strong>Market:</strong> ' + (t.impliedP * 100).toFixed(1) + '%</div>' : ""}
                <div class="thesis-bet-side">Fade ${fadeSideDisplay}  ${t.confidence.toUpperCase()} confidence</div>
              </div>
              <button class="btn btn-orange btn-sm" onclick="openLogModal('${t.game}','Live ML','Mean Reversion')">Log This Bet</button>
            </div>
            <div class="thesis-logic">
              <div class="thesis-logic-title">Why This Is an Edge</div>
              <div class="thesis-logic-text" style="line-height:1.7;">
                <div style="margin-bottom:6px;">${t.betLogic}</div>
                <div style="padding:8px 10px;background:var(--accent-light);border-radius:6px;border-left:3px solid var(--accent);margin-top:6px;font-size:11px;line-height:1.6;">
                  <strong>The Thesis:</strong> The live ML is priced on the current score, but the score is built on unsustainable conditions. When those conditions normalize, the true probability shifts toward <strong>${betSideDisplay}</strong>. The market is slow to reprice these temporary swings  that's the edge.
                </div>
              </div>
            </div>
            <div class="thesis-criteria">${criteriaHTML}</div>
            <div class="thesis-actions">
              <span style="font-size:10px;color:#666;display:inline-flex;align-items:center;gap:3px;">${teamLogoImg(t.aLogo, 14)}${aTeamDisplay} ${t.aScore} - ${t.hScore} ${hTeamDisplay}${teamLogoImg(t.hLogo, 14)} | ${t.detail}</span>
              <button class="btn btn-green btn-sm" onclick="openLogModal('${t.game}','Live ML','Mean Reversion')">Log Bet</button>
            </div>
          </div>
        </div>`;
      }).join('');
    } else { etc.classList.remove('active'); etCards.innerHTML = ''; }

    // Store signal games globally for chip click-to-expand
    window._signalGames = signalGames;

    updateStarTracker(events);
        renderBetLog();
        updateBacktestPanel();
        updateKelly();
        autoResolveBets(); // Check for final scores and auto-mark W/L
        resolveSignalTracker(); // Check signal tracker results
        renderQualityEdge(); // Refresh Quality Edge tab


  } catch (err) {
    setConnStatus('error');
    if (state.consecutiveErrors < 3) {
      grid.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><p style="color:var(--orange);">Connection issue (${err.message}). Retrying next cycle...</p></div>`;
    } else {
      grid.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><p style="color:var(--red);">Connection failed ${state.consecutiveErrors}x. ESPN may be rate-limiting. Wait 30s then try again.</p></div>`;
    }
  }
}

// ==================== STAR TRACKER ====================
function updateStarTracker(events) {
  const tb = document.getElementById('live-star-status');
  let rows = '';
  for (const ev of events) {
    if (ev.status?.type?.state !== 'in') continue;
    const comp = ev.competitions?.[0]; if (!comp) continue;
    const per=ev.status?.period||1, clk=ev.status?.displayClock||'12:00';
    const cM=parseFloat(clk?.split(':')[0]||12), cS=parseFloat(clk?.split(':')[1]||0);
    const gMins=getElapsedMinutes(per, clk), gPct=getGamePct(per, clk);
    for (const team of (comp.competitors||[])) {
      const tA=team.team?.abbreviation||'';
      const tLogo=team.team?.logo||'';
      const aT=comp.competitors?.find(c=>c.homeAway==='away'), hT=comp.competitors?.find(c=>c.homeAway==='home');
      const gl=`${aT?.team?.abbreviation||''} @ ${hT?.team?.abbreviation||''}`;
      for (const cat of (team.leaders||[])) {
        if (cat.name!=='points') continue;
        for (const l of (cat.leaders||[])) {
          const nm=l.athlete?.shortName||l.athlete?.displayName||'';
          const pts=parseFloat(l.value)||0;
          // NCAA: use pre-game star DB. NBA: use curated star DB.
          let star;
          if (isNCAA()) {
            star = ncaaStarCache.find(s => { const ll=nm.toLowerCase().split(' ').pop(); const sl=s.name.split(' ').pop().toLowerCase(); return ll===sl&&s.team===tA; });
          } else {
            star = state.stars.find(s=>nm.toLowerCase().includes(s.name.split(' ').pop().toLowerCase())&&s.team===tA);
          }
          if (!star) continue;
          const exp=getExpectedByTime(star.ppg,gMins), pr=exp>0?(pts/exp*100):100;
          const q1E=getQ1Expected(star.ppg), hE=getHalfExpected(star.ppg);
          const _regPer = getRegulationPeriods(); // NBA: 4, NCAA: 2
          let q1T='-';
          // NBA: Q1 ends at per=2. NCAA: no Q1 concept, show H1 pace when per===1
          if (isNCAA()) {
            if (per>=2) q1T=`${hE.toFixed(1)} exp`; // H1 done
            else if (per===1) { const p=hE>0?(pts/hE*100):100; q1T=`<span style="color:${p<60?'var(--red)':p<80?'var(--orange)':'var(--green)'};font-weight:700;">${p.toFixed(0)}%</span> of ${hE.toFixed(1)}`; }
          } else {
            if (per>=2) q1T=`${q1E.toFixed(1)} exp`;
            else if (per===1) { const p=q1E>0?(pts/q1E*100):100; q1T=`<span style="color:${p<60?'var(--red)':p<80?'var(--orange)':'var(--green)'};font-weight:700;">${p.toFixed(0)}%</span> of ${q1E.toFixed(1)}`; }
          }
          let hT2='-';
          if (per>_regPer) hT2=`${hE.toFixed(1)} exp`; // past halftime/regulation
          else if (per>=1&&gMins>0) { const p=hE>0?(pts/hE*100):100; hT2=`<span style="color:${p<60?'var(--red)':p<80?'var(--orange)':'var(--green)'};font-weight:700;">${p.toFixed(0)}%</span> of ${hE.toFixed(1)}`; }
          const fc=pr<60?'var(--red)':pr<80?'var(--orange)':'var(--green)';
          const sig=pr<60&&gPct>=0.2&&per<=_regPer?'<span class="signal-badge signal-fire">COLD - BET</span>':pr<75?'<span class="signal-badge signal-moderate">Below Pace</span>':'<span class="signal-badge signal-none">On Pace</span>';
          const _pLabel = isNCAA() ? (per <= 2 ? `H${per}` : `OT${per-2}`) : `Q${per}`;
          rows+=`<tr class="star-row"><td style="display:flex;align-items:center;gap:4px;">${teamLogoImg(tLogo, 16)}<div><strong>${nm}</strong><br><span style="font-size:9px;color:var(--text-muted);">${star.ppg} PPG</span></div></td><td>${gl}</td><td style="font-size:16px;font-weight:800;">${pts}</td><td>${q1T}</td><td>${hT2}</td><td><div class="pace-indicator"><div class="pace-fill" style="width:${Math.min(pr,100)}%;background:${fc};"></div></div> ${pr.toFixed(0)}%</td><td>${_pLabel} ${clk}</td><td>${sig}</td></tr>`;
        }
      }
    }
  }
  tb.innerHTML = rows || '<tr><td colspan="8" class="empty-state">No tracked stars in live games.</td></tr>';
}

// ==================== STAR DB ====================
function renderStarDB() {
  const tb = document.getElementById('star-db-body');
  tb.innerHTML = state.stars.map((s,i) => {
    const q1=getQ1Expected(s.ppg), h=getHalfExpected(s.ppg);
    const pLabel = isNCAA() ? 'H1' : 'Q1';
    return `<tr><td><strong>${s.name}</strong></td><td>${s.team}</td><td>${s.ppg}</td><td>${isNCAA() ? h.toFixed(1) : q1.toFixed(1)}</td><td>${h.toFixed(1)}</td><td>&lt;${(isNCAA() ? (h*0.6).toFixed(0) : (q1*0.6).toFixed(0))} ${pLabel}, &lt;${(h*0.6).toFixed(0)} half</td><td><button class="btn btn-red btn-sm" onclick="removeStar(${i})">X</button></td></tr>`;
  }).join('');
}
function addStar() {
  const n=document.getElementById('add-star-name').value.trim(), t=document.getElementById('add-star-team').value.trim().toUpperCase(), p=parseFloat(document.getElementById('add-star-ppg').value);
  if (!n||!t||isNaN(p)) { alert('Fill all fields'); return; }
  state.stars.push({name:n,team:t,ppg:p}); localStorage.setItem('starPlayers',JSON.stringify(state.stars)); renderStarDB();
  document.getElementById('add-star-name').value=''; document.getElementById('add-star-team').value=''; document.getElementById('add-star-ppg').value='';
}
function removeStar(i) { state.stars.splice(i,1); localStorage.setItem('starPlayers',JSON.stringify(state.stars)); renderStarDB(); }

// ==================== SIGNAL GUIDE (MODE-AWARE) ====================
function updateSignalGuide(mode) {
  const ncaa = mode === 'ncaab';
  // Quick reference table
  const fragileDesc = ncaa
    ? 'A team is <strong>way too hot from 3</strong> (48%+ on 10+ att or 52%+ on 7+) and their entire lead depends on it. NCAA avg is ~33.5%. That shooting will cool off  lead will shrink.'
    : 'A team is <strong>way too hot from 3</strong> (50%+) and their entire lead depends on it. That shooting will cool off  lead will shrink.';
  const starDesc = ncaa
    ? 'A lead scorer (16+ PPG) is cold (&lt;65% pace) AND the game is close (within 12pts) during minutes 8-35. <strong>Compressed spring</strong>  breakout incoming. NCAA teams are more star-dependent.'
    : 'A star player (21+ PPG) is cold (&lt;65% pace) AND the game is close (within 15pts) in Q2-Q3. <strong>Compressed spring</strong>  breakout incoming.';
  // Update quick reference cells
  const cells = document.querySelectorAll('#guide-fragile-desc');
  if (cells.length) cells[0].innerHTML = fragileDesc;
  const starCells = document.querySelectorAll('#guide-star-desc');
  if (starCells.length) starCells[0].innerHTML = starDesc;

  // Update detailed guide
  const guideEl = document.getElementById('nba-guide');
  if (!guideEl) return;
  const leagueName = ncaa ? 'NCAAB' : 'NBA';
  const leagueAvg = ncaa ? '~33.5%' : '~36.5%';
  const hotThresh = ncaa ? '48%+ from 3 on 10+ attempts (or 52%+ on 7+)' : '50%+ from 3 on 12+ attempts (or 55%+ on 8+)';
  const fragileThresh = ncaa ? '40%' : '42%';
  const marginRange = ncaa ? '3-12' : '3-15';
  const enginePPM = ncaa ? '1.1' : '1.3';
  const starPPG = ncaa ? '16+' : '21+';
  const coilMargin = ncaa ? '12' : '15';
  const coilWindow = ncaa ? 'minutes 8-35 (first half through mid second half)' : 'Q2-Q3';
  const gameMins = ncaa ? '40 min (220 halves)' : '48 min (412 quarters)';
  const softHot = ncaa ? '40%/7att (or 45%/5att), fragile 36%, margin 2-18pts' : '45%/10att (or 50%/8att), fragile 38%, margin 2-18pts';
  const softStar = ncaa ? '&lt;80% pace, minutes 4-37, margin 18pts, accepts weak cast' : '&lt;75% pace, Q1-Q3 (not just Q2-Q3), margin 18pts';
  const homeCourtNote = ncaa ? '<p style="margin-top:8px;"><strong>Home Court Booster (NCAAB only):</strong> When signals point toward betting the home team, a +0.5 boost is applied. NCAA home court advantage is ~3.5-4 points  significantly stronger than NBA (~2.5). Crowd energy + regression signals = double tailwind.</p>' : '';

  guideEl.innerHTML = `
<p class="guide-intro" style="margin-bottom:12px;"><strong>Core thesis:</strong> The current score was built on something unsustainable, so the live odds are mispriced. We bet on regression. <span style="color:var(--accent);font-weight:700;">${leagueName} mode</span>  ${gameMins}.</p>
<div style="background:var(--accent-light);border:1px solid var(--accent);border-radius:var(--radius);padding:14px;margin-bottom:16px;font-size:12px;">
<strong>Backtest Validated (3,517 games, Oct 2023 - Feb 2027):</strong>
<div style="display:flex;gap:16px;margin-top:6px;flex-wrap:wrap;">
<div><strong>Star Coil:</strong> 58.6% win rate, 2,181 signals, +11.9% ROI</div>
<div><strong>Star Coil+:</strong> 57.2% win rate, 208 signals (highest conviction)</div>
</div>
</div>
<div class="guide-grid">
<div class="guide-card"><h3><span class="signal-badge badge-star">STAR</span> Star Coil</h3><p class="edge-label">Star is cold + game is close + supporting cast is holding = verified profitable edge</p><p>When a ${starPPG} PPG player is at &lt;65% of expected pace AND the game is within ${coilMargin} points during ${coilWindow}. <strong>Backtest: 58.6% win rate on 2,181 signals.</strong></p><p><strong>Supporting Cast Analysis:</strong> Pure live data  team score minus star's points vs opponent total. If cast is within 8pts, team is competitive WITHOUT the star.</p><p><strong>4 tiers:</strong> Elite (cast gap -8), Standard (-8 to -15), Weak (&lt;-15), Locked (deficit stable 3+min).</p><div class="threshold">Trigger: Star &lt;65% pace + margin ${coilMargin} + ${coilWindow}.<br>Tiers: Elite (cast gap -8, 1.5 weight), Standard (-8 to -15, 1 weight), Weak (0 weight), Locked (reverse bet).<br>Q3 subset: 68.8% win rate (elite).</div></div>
<div class="guide-card"><h3><span style="display:inline-block;font-size:10px;font-weight:700;color:white;background:var(--accent);padding:3px 8px;border-radius:4px;">STAR COIL+</span> Star Coil Plus</h3><p class="edge-label">Star cold + opponent shooting cold = double regression edge</p><p>When Star Coil fires AND the opponent (leading team) has poor shooting: FG% &lt; 43% or 2PT% &lt; 47%. <strong>Backtest: 57.2% win rate on 208+ signals.</strong></p><p><strong>Why it works:</strong> The opponent's lead is built on two unsustainable factors  star being cold AND opponent shooting unsustainably well from inside. Both regress = dramatic swing.</p><div class="threshold">Trigger: Star Coil active + opponent FG% &lt; 43% OR opponent 2PT% &lt; 47%.<br>Highest-conviction ML signal. Fires ~1x per night.</div></div>
</div>${homeCourtNote}`;
}

// ==================== BET LOG ====================
function openLogModal(g,p,s) { document.getElementById('modal-game').value=g; document.getElementById('modal-price').value=p; document.getElementById('modal-strategy').value=s; document.getElementById('modal-side').value=''; document.getElementById('modal-notes').value=''; document.getElementById('logModal').classList.add('active'); }
function closeModal() { document.getElementById('logModal').classList.remove('active'); }
function confirmLogBet() {
  state.betLog.push({date:new Date().toLocaleDateString(),strategy:document.getElementById('modal-strategy').value,game:document.getElementById('modal-game').value,side:document.getElementById('modal-side').value,price:document.getElementById('modal-price').value,units:parseFloat(document.getElementById('modal-units').value),result:'Pending',profit:0,notes:document.getElementById('modal-notes').value,id:Date.now()});
  localStorage.setItem('betLog',JSON.stringify(state.betLog)); renderBetLog(); closeModal();
}
function getEdgeBonus(signalCount) {
  const mode = document.getElementById('edge-mode') ? document.getElementById('edge-mode').value : 'moderate';
  if (mode === 'backtest') {
    const d = getBacktestData();
    if (d.total >= 10) return Math.max(0.01, Math.min(0.10, d.edge));
    return 0.03;
  }
  const sc = signalCount || 1;
  const base = mode === 'conservative' ? 0.03 : mode === 'aggressive' ? 0.08 : 0.05;
  const bonus = Math.min(sc - 1, 3) * 0.015;
  return Math.min(base + bonus, 0.12);
}

function kellySize(impliedP, odds, fraction, signalCount, urgencyMult) {
  if (!fraction) {
    const sel = document.getElementById('kelly-fraction');
    fraction = sel ? parseFloat(sel.value) : 0.75;
  }
  const bankroll = parseFloat((document.getElementById('bankroll-input')||{}).value) || 1000;
  const edge = getEdgeBonus(signalCount);
  const p = Math.min(0.90, impliedP + edge);
  const q = 1 - p;
  const b = odds > 0 ? odds / 100 : 100 / Math.abs(odds);
  let fStar = (b * p - q) / b;
  if (fStar < 0) fStar = 0;
  fStar = fStar * fraction;
  // Apply urgency multiplier (PRIME=1.0, ACT_NOW=0.85, DEVELOPING=0.7, CLOSING=0.5)
  if (urgencyMult !== undefined) fStar *= urgencyMult;
  if (fStar > 0.10) fStar = 0.10;
  // Minimum edge threshold: if edge < 2%, don't bet
  if (edge < 0.02) { fStar = 0; }
  const bet = Math.max(0, Math.round(bankroll * fStar));
  return { bet, fStar: Math.round(fStar * 1000) / 10, p: Math.round(p * 1000) / 10, edge: Math.round(edge * 1000) / 10, fraction, bankroll };
}

function autoLogBet(gameId, team, side, signals, marketOdds, impliedP, signalCount, urgencyMult) {
  let log = JSON.parse(localStorage.getItem('betLog') || '[]');
  const key = gameId + '_' + team;
  if (log.find(x => x.key === key)) return;
  const k = kellySize(impliedP, marketOdds, null, signalCount || 1, urgencyMult);
  log.push({
    id: Date.now(),
    key: key,
    gameId: gameId,
    team: team,
    side: side,
    signals: signals.map(s => typeof s === 'object' ? s.type : s),
    marketOdds: marketOdds,
    impliedP: Math.round(impliedP * 1000) / 10,
    estimatedP: k.p,
    kellyPct: k.fStar,
    kellyBet: k.bet,
    timestamp: new Date().toISOString(),
    outcome: null,
    payout: null,
    mode: currentMode || 'nba'
  });
  localStorage.setItem('betLog', JSON.stringify(log));
}

// ==================== SIGNAL BACKTEST TRACKER ====================
const TRACKER_BANKROLL = 20000;
const TRACKER_MAX_KELLY = 0.05;    // Max 5% of bankroll per bet (half-Kelly cap)

const TRACKER_FLAT_UNIT = 200; // Flat $200/bet until 200+ resolved signals
const TRACKER_MIN_SAMPLE = 200; // Minimum resolved signals before using Kelly

function trackerKellyBet(odds, signalCount, urgencyMult) {
  // Check if we have enough data for Kelly  if not, use flat units
  const resolved = (state.signalTracker || []).filter(s => s.gameCompleted).length;
  const sc = signalCount || 1;

  if (resolved < TRACKER_MIN_SAMPLE) {
    // FLAT UNIT MODE: $200/bet regardless of signal strength
    // Still compute estimated edge for display, but don't size on it
    const baseEdge = 0.035 + Math.min(sc - 1, 3) * 0.01;
    const edge = Math.min(baseEdge, 0.08);
    const impliedP = odds < 0 ? Math.abs(odds)/(Math.abs(odds)+100) : 100/(odds+100);
    const p = Math.min(0.90, impliedP + edge);
    const f = TRACKER_FLAT_UNIT / TRACKER_BANKROLL;
    return { f: Math.round(f*1000)/10, p: Math.round(p*1000)/10, bet: TRACKER_FLAT_UNIT, edge: Math.round(edge*1000)/10, flatMode: true };
  }

  // KELLY MODE: 200+ resolved signals  use empirical edge if available
  const completed = state.signalTracker.filter(s => s.gameCompleted && s.mlResult);
  const wins = completed.filter(s => s.mlResult === 'W').length;
  const empiricalWR = completed.length > 0 ? wins / completed.length : 0.524;
  const breakEven = odds < 0 ? Math.abs(odds)/(Math.abs(odds)+100) : 100/(odds+100);
  const empiricalEdge = Math.max(0, empiricalWR - breakEven);
  // Blend: 70% empirical + 30% formula (hedge against recency)
  const formulaEdge = 0.035 + Math.min(sc - 1, 3) * 0.01;
  const edge = Math.min(empiricalEdge * 0.7 + formulaEdge * 0.3, 0.08);
  const impliedP = breakEven;
  const p = Math.min(0.90, impliedP + edge);
  const q = 1 - p;
  const b = odds < 0 ? 100/Math.abs(odds) : odds/100;
  let f = (b * p - q) / b;
  if (f <= 0) f = 0;
  f = f * 0.5; // half-Kelly
  if (urgencyMult !== undefined) f *= urgencyMult;
  f = Math.min(f, TRACKER_MAX_KELLY);
  if (edge < 0.03) f = 0;
  const bet = Math.max(0, Math.round(TRACKER_BANKROLL * f));
  return { f: Math.round(f*1000)/10, p: Math.round(p*1000)/10, bet, edge: Math.round(edge*1000)/10, flatMode: false };
}

function autoTrackSignal(thesis, rec) {
  if (!thesis) return;
  if (!rec) rec = { type: 'WATCH', side: null, spreadLine: '', units: 0, reasoning: 'No recommendation generated', margin: 0, minRemaining: 0 };
  const trackerKey = thesis.eventId + '_' + (thesis.betSide||'');
  if (state.signalTracker.find(s => s.key === trackerKey)) return;

  const sigCount = (thesis.signals||[]).filter(s=>s.level===2).length;
  const odds = thesis.marketOdds || -110;
  const urgMult = thesis.urgency?.mult !== undefined ? thesis.urgency.mult : (thesis.urgencyMult !== undefined ? thesis.urgencyMult : 1.0);
  const kelly = trackerKellyBet(odds, sigCount, urgMult);

  const entry = {
    id: Date.now() + '_' + Math.random().toString(36).substr(2,6),
    key: trackerKey,
    eventId: thesis.eventId,
    game: thesis.game || '',
    awayTeam: thesis.aTeam || '',
    homeTeam: thesis.hTeam || '',
    awayTeamFull: thesis.aTeamFull || '',
    homeTeamFull: thesis.hTeamFull || '',
    signalSide: thesis.betSide || '',
    signalSideFull: thesis.betSideFull || '',
    recType: rec.type,
    spreadLine: rec.spreadLine || '',
    units: rec.units || 1,
    signalLevel: thesis.signalLevel || 2,
    signals: (thesis.signals||[]).filter(s=>s.level===2).map(s=>s.type),
    confidence: thesis.confidence || '',
    strongCount: thesis.strongCount || 0,
    awayScore: thesis.aScore,
    homeScore: thesis.hScore,
    period: thesis.per,
    clock: thesis.clk,
    reasoning: rec.reasoning || '',
    marketOdds: odds,
    kellyPct: kelly.f,
    kellyBet: kelly.bet,
    estWinProb: kelly.p,
    estEdge: kelly.edge,
    timestamp: Date.now(),
    date: new Date().toLocaleDateString(),
    mode: currentMode,
    // LEC tracking  odds key for matching post-entry odds
    entryOddsKey: thesis.oddsKey || null,
    lec5minOdds: null, lec5min: null,
    lec10minOdds: null, lec10min: null,
    // Result fields  filled by resolveSignalTracker
    finalAwayScore: null,
    finalHomeScore: null,
    gameCompleted: false,
    mlResult: null,
    atsResult: null,
    mlPayout: null,
    atsPayout: null,
    resultCheckedAt: null
  };

  state.signalTracker.push(entry);
  if (state.signalTracker.length > 500) state.signalTracker = state.signalTracker.slice(-400);
  localStorage.setItem('signalTracker', JSON.stringify(state.signalTracker));
  renderSignalTracker();
}

// === IMPORT FROM BACKGROUND ENGINE ===
// Loads engine-signals.json (written by signal-engine.js when browser was offline)
// and merges any new signals into the signal tracker + bet log.
async function importEngineSignals() {
  try {
    const resp = await fetch('engine-signals.json?t=' + Date.now());
    if (!resp.ok) return; // no engine file  normal if engine hasn't run
    const engineSignals = await resp.json();
    if (!Array.isArray(engineSignals) || engineSignals.length === 0) return;
    let imported = 0;
    for (const sig of engineSignals) {
      // Quality Edge signals are spread bets  handled by renderQualityEdge(), not the ML tracker
      if (sig.type === 'quality_edge') continue;
      // Skip if already in tracker
      const trackerKey = sig.eventId + '_' + (sig.betTeam || '');
      if (state.signalTracker.find(s => s.key === trackerKey)) continue;
      // Convert engine format to tracker format
      const entry = {
        id: sig.timestamp + '_' + Math.random().toString(36).substr(2, 6),
        key: trackerKey,
        eventId: sig.eventId,
        game: sig.game || '',
        awayTeam: sig.game?.split(' @ ')?.[0] || '',
        homeTeam: sig.game?.split(' @ ')?.[1] || '',
        awayTeamFull: sig.gameFullAway || '',
        homeTeamFull: sig.gameFullHome || '',
        signalSide: sig.betTeam || '',
        signalSideFull: sig.betTeamFull || '',
        recType: sig.recType || 'ML',
        spreadLine: '',
        units: 1,
        signalLevel: 2,
        signals: sig.signalTypes || [],
        confidence: sig.signalCount >= 2 ? 'high' : 'medium',
        strongCount: sig.signalCount || 1,
        awayScore: sig.awayScore,
        homeScore: sig.homeScore,
        period: sig.period,
        clock: sig.clock,
        reasoning: `Background engine signal: ${(sig.signalTypes || []).join(' + ')}`,
        marketOdds: sig.marketOdds || -110,
        kellyPct: sig.kellyPct,
        kellyBet: sig.kellyBet,
        estWinProb: sig.estWinProb,
        estEdge: sig.estEdge,
        timestamp: sig.timestamp,
        date: sig.date || new Date(sig.timestamp).toLocaleDateString(),
        mode: sig.mode || currentMode,
        finalAwayScore: sig.finalAwayScore,
        finalHomeScore: sig.finalHomeScore,
        gameCompleted: sig.gameCompleted || false,
        mlResult: sig.mlResult || null,
        atsResult: null,
        mlPayout: sig.mlPayout || null,
        atsPayout: null,
        resultCheckedAt: null,
        source: 'engine' // tag so you know it came from background
      };
      state.signalTracker.push(entry);
      imported++;
      // Also add to bet log if not there
      const logKey = sig.eventId + '_' + sig.betTeam;
      let betLog = JSON.parse(localStorage.getItem('betLog') || '[]');
      if (!betLog.find(x => x.key === logKey)) {
        betLog.push({
          id: sig.timestamp,
          key: logKey,
          gameId: sig.eventId,
          team: sig.betTeam,
          side: 'ML',
          signals: sig.signalTypes || [],
          marketOdds: sig.marketOdds || -110,
          impliedP: sig.impliedP,
          estimatedP: sig.estWinProb,
          kellyPct: sig.kellyPct,
          kellyBet: sig.kellyBet,
          timestamp: new Date(sig.timestamp).toISOString(),
          outcome: sig.mlResult || null,
          payout: sig.mlPayout || null,
          mode: sig.mode || currentMode,
          source: 'engine'
        });
        localStorage.setItem('betLog', JSON.stringify(betLog));
      }
    }
    if (imported > 0) {
      localStorage.setItem('signalTracker', JSON.stringify(state.signalTracker));
      renderSignalTracker();
      renderBetLog();
      console.log(`[Engine Import] Imported ${imported} signals from background engine`);
    }
  } catch(e) {
    // Silently ignore  engine file may not exist
  }
}

async function resolveSignalTracker(specificDateStr) {
  const pending = state.signalTracker.filter(s => !s.gameCompleted);
  const pendingNearMisses = (state.nearMisses || []).filter(s => !s.gameCompleted);
  if (pending.length === 0 && pendingNearMisses.length === 0) { renderSignalTracker(); return; }

  const datesToFetch = new Set();
  if (specificDateStr) {
    datesToFetch.add(specificDateStr);
  } else {
    datesToFetch.add('today');
    pending.forEach(s => {
      if (s.date) {
        const parts = s.date.split('/');
        if (parts.length === 3) {
          const mm = parts[0].padStart(2,'0');
          const dd = parts[1].padStart(2,'0');
          const yyyy = parts[2].length === 2 ? '20'+parts[2] : parts[2];
          datesToFetch.add(yyyy+mm+dd);
        }
      }
    });
  }

  let allEvents = [];
  for (const ds of datesToFetch) {
    try {
      const base = getESPNUrl();
      const url = ds === 'today' ? base : base + '?dates=' + ds;
      const resp = await fetch(url);
      if (!resp.ok) continue;
      const data = await resp.json();
      allEvents = allEvents.concat(data.events || []);
    } catch(e) { console.warn('Signal tracker fetch error:', e); }
  }

  const eventMap = {};
  allEvents.forEach(e => { eventMap[e.id] = e; eventMap[String(e.id)] = e; });

  let changed = false;
  pending.forEach(signal => {
    const event = eventMap[signal.eventId] || eventMap[String(signal.eventId)];
    if (!event) return;
    if (event.status?.type?.state !== 'post') return;

    const comp = event.competitions?.[0];
    if (!comp) return;
    const away = comp.competitors?.find(c => c.homeAway === 'away');
    const home = comp.competitors?.find(c => c.homeAway === 'home');
    if (!away || !home) return;

    const finalAway = parseInt(away.score) || 0;
    const finalHome = parseInt(home.score) || 0;
    signal.finalAwayScore = finalAway;
    signal.finalHomeScore = finalHome;
    signal.gameCompleted = true;
    signal.resultCheckedAt = Date.now();

    const signalIsAway = signal.signalSide === signal.awayTeam;
    const sigFinal = signalIsAway ? finalAway : finalHome;
    const oppFinal = signalIsAway ? finalHome : finalAway;
    const betAmt = signal.kellyBet || 0;
    const odds = signal.marketOdds || -110;
    const multiplier = odds < 0 ? 100/Math.abs(odds) : odds/100;

    // ML result
    if (sigFinal > oppFinal) {
      signal.mlResult = 'W';
      signal.mlPayout = Math.round(betAmt * multiplier);
    } else {
      signal.mlResult = 'L';
      signal.mlPayout = -betAmt;
    }

    // ATS result
    if (signal.spreadLine) {
      const spread = parseFloat(signal.spreadLine) || 0;
      const adjusted = sigFinal + spread;
      if (adjusted > oppFinal) {
        signal.atsResult = 'W';
        signal.atsPayout = Math.round(betAmt * (100/110)); // spread always -110
      } else if (adjusted === oppFinal) {
        signal.atsResult = 'P';
        signal.atsPayout = 0;
      } else {
        signal.atsResult = 'L';
        signal.atsPayout = -betAmt;
      }
    } else {
      signal.atsResult = signal.mlResult;
      signal.atsPayout = signal.mlPayout;
    }
    changed = true;
  });

  if (changed) {
    localStorage.setItem('signalTracker', JSON.stringify(state.signalTracker));
  }

  // Resolve near-miss (counterfactual) signals too
  const pendingNM = (state.nearMisses || []).filter(s => !s.gameCompleted);
  let nmChanged = false;
  pendingNM.forEach(nm => {
    const event = eventMap[nm.eventId] || eventMap[String(nm.eventId)];
    if (!event || event.status?.type?.state !== 'post') return;
    const comp = event.competitions?.[0];
    if (!comp) return;
    const away = comp.competitors?.find(c => c.homeAway === 'away');
    const home = comp.competitors?.find(c => c.homeAway === 'home');
    if (!away || !home) return;
    nm.finalAwayScore = parseInt(away.score) || 0;
    nm.finalHomeScore = parseInt(home.score) || 0;
    nm.gameCompleted = true;
    // Would the hypothetical bet have won?
    const isAway = nm.hypotheticalSide === nm.awayTeam;
    const betFinal = isAway ? nm.finalAwayScore : nm.finalHomeScore;
    const oppFinal = isAway ? nm.finalHomeScore : nm.finalAwayScore;
    nm.wouldHaveWon = betFinal > oppFinal;
    nmChanged = true;
  });
  if (nmChanged) {
    localStorage.setItem('nearMisses', JSON.stringify(state.nearMisses));
  }

  renderSignalTracker();
}

function getSignalTrackerStats(modeFilter) {
  const allRaw = state.signalTracker;
  const all = modeFilter ? allRaw.filter(s => s.mode === modeFilter) : allRaw;
  const completed = all.filter(s => s.gameCompleted);
  const pending = all.filter(s => !s.gameCompleted);

  const mlR = completed.filter(s => s.mlResult);
  const mlW = mlR.filter(s => s.mlResult==='W').length;
  const mlL = mlR.filter(s => s.mlResult==='L').length;
  const mlWR = mlR.length>0 ? Math.round(mlW/mlR.length*1000)/10 : 0;
  const mlProfit = mlR.reduce((s,x) => s+(x.mlPayout||0), 0);
  const mlRisked = mlR.reduce((s,x) => s+(x.kellyBet||0), 0);
  const mlROI = mlRisked>0 ? Math.round(mlProfit/mlRisked*1000)/10 : 0;

  const atsR = completed.filter(s => s.atsResult);
  const atsW = atsR.filter(s => s.atsResult==='W').length;
  const atsL = atsR.filter(s => s.atsResult==='L').length;
  const atsP = atsR.filter(s => s.atsResult==='P').length;
  const atsWR = atsR.length>0 ? Math.round(atsW/atsR.length*1000)/10 : 0;
  const atsProfit = atsR.reduce((s,x) => s+(x.atsPayout||0), 0);
  const atsRisked = atsR.reduce((s,x) => s+(x.kellyBet||0), 0);
  const atsROI = atsRisked>0 ? Math.round(atsProfit/atsRisked*1000)/10 : 0;

  // By signal type
  const bySig = {};
  completed.forEach(s => {
    (s.signals||[]).forEach(sig => {
      if (!bySig[sig]) bySig[sig] = {n:0, mlW:0, mlL:0, atsW:0, atsL:0, atsP:0, mlProfit:0, atsProfit:0, risked:0};
      const b = bySig[sig]; b.n++;
      if (s.mlResult==='W') b.mlW++; else b.mlL++;
      if (s.atsResult==='W') b.atsW++; else if (s.atsResult==='L') b.atsL++; else if (s.atsResult==='P') b.atsP++;
      b.mlProfit += (s.mlPayout||0); b.atsProfit += (s.atsPayout||0); b.risked += (s.kellyBet||0);
    });
  });

  // By quarter
  const byQ = {};
  completed.forEach(s => {
    const q = s.mode === 'ncaab' ? ((s.period||0) <= 2 ? 'H'+(s.period||'?') : 'OT'+((s.period||3)-2)) : 'Q'+(s.period||'?');
    if (!byQ[q]) byQ[q] = {n:0, mlW:0, mlL:0, atsW:0, atsL:0, mlProfit:0, atsProfit:0, risked:0};
    const b = byQ[q]; b.n++;
    if (s.mlResult==='W') b.mlW++; else b.mlL++;
    if (s.atsResult==='W') b.atsW++; else if (s.atsResult==='L') b.atsL++;
    b.mlProfit += (s.mlPayout||0); b.atsProfit += (s.atsPayout||0); b.risked += (s.kellyBet||0);
  });

  // By rec type
  const byRec = {};
  completed.forEach(s => {
    const rt = s.recType || 'ML';
    if (!byRec[rt]) byRec[rt] = {n:0, mlW:0, mlL:0, atsW:0, atsL:0, mlProfit:0, atsProfit:0, risked:0};
    const b = byRec[rt]; b.n++;
    if (s.mlResult==='W') b.mlW++; else b.mlL++;
    if (s.atsResult==='W') b.atsW++; else if (s.atsResult==='L') b.atsL++;
    b.mlProfit += (s.mlPayout||0); b.atsProfit += (s.atsPayout||0); b.risked += (s.kellyBet||0);
  });

  const totalRisked = completed.reduce((s,x) => s+(x.kellyBet||0), 0);
  const currentBankroll = TRACKER_BANKROLL + mlProfit;

  // LEC (Live Edge Captured) stats
  const lec5arr = all.filter(s => s.lec5min !== null && s.lec5min !== undefined);
  const lec10arr = all.filter(s => s.lec10min !== null && s.lec10min !== undefined);
  const avgLec5 = lec5arr.length > 0 ? Math.round(lec5arr.reduce((s,x) => s + x.lec5min, 0) / lec5arr.length * 10) / 10 : null;
  const avgLec10 = lec10arr.length > 0 ? Math.round(lec10arr.reduce((s,x) => s + x.lec10min, 0) / lec10arr.length * 10) / 10 : null;
  const lecPositive5 = lec5arr.filter(s => s.lec5min > 0).length;
  const lecPositive10 = lec10arr.filter(s => s.lec10min > 0).length;

  // Near-miss (counterfactual) stats
  const nearMisses = state.nearMisses || [];
  const nmCompleted = nearMisses.filter(s => s.gameCompleted);
  const nmWins = nmCompleted.filter(s => s.wouldHaveWon).length;
  const nmWR = nmCompleted.length > 0 ? Math.round(nmWins / nmCompleted.length * 1000) / 10 : 0;

  return {
    total: all.length, completed: completed.length, pending: pending.length,
    mlW, mlL, mlWR, mlProfit, mlROI, mlRisked,
    atsW, atsL, atsP, atsWR, atsProfit, atsROI, atsRisked,
    bySig, byQ, byRec,
    totalRisked, currentBankroll,
    avgLec5, avgLec10, lecCount5: lec5arr.length, lecCount10: lec10arr.length,
    lecPositive5, lecPositive10,
    nearMissTotal: nearMisses.length, nearMissCompleted: nmCompleted.length, nearMissWR: nmWR
  };
}

// ==================== QUALITY EDGE RENDERING ====================
function renderQualityEdge() {
  // Read engine signals from the already-loaded state
  let engineSignals = [];
  try {
    fetch('engine-signals.json?t=' + Date.now()).then(r => r.ok ? r.json() : []).then(data => {
      if (!Array.isArray(data)) return;
      const qeSignals = data.filter(s => s.type === 'quality_edge');
      const active = qeSignals.filter(s => !s.gameCompleted);
      const completed = qeSignals.filter(s => s.gameCompleted).sort((a,b) => b.timestamp - a.timestamp).slice(0, 20);

      // Update badge + chip
      const badge = document.getElementById('edge-badge');
      const chip = document.getElementById('qe-count');
      const activeCountEl = document.getElementById('qe-active-count');
      if (badge) {
        if (active.length > 0) { badge.style.display = 'inline'; badge.textContent = active.length; }
        else { badge.style.display = 'none'; }
      }
      if (chip) chip.textContent = active.length || '\u2014';
      if (activeCountEl) activeCountEl.textContent = active.length;

      // Render active signals
      const activeEl = document.getElementById('qe-active-signals');
      if (activeEl) {
        if (active.length === 0) {
          activeEl.innerHTML = '<div style="text-align:center;padding:30px 20px;color:var(--text-muted);font-size:13px;background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);">No active Quality Edge signals right now. Signals fire during live NBA games (Q1-Q2) when a strong team (15%+ gap) is trailing 1-10 pts and the live spread still has them favored.</div>';
        } else {
          activeEl.innerHTML = active.map(s => {
            const gapPct = s.qualityGap || 0;
            const strongPct = s.strongerWinPct || 50;
            const weakPct = s.weakerWinPct || 50;
            return `<div style="background:var(--card-bg);border:2px solid var(--green);border-radius:var(--radius);padding:16px;margin-bottom:10px;">
              <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;">
                <div style="font-size:15px;font-weight:800;">${s.game || ''}</div>
                <span style="background:var(--green);color:white;font-size:10px;font-weight:700;padding:3px 10px;border-radius:12px;">${s.periodLabel || ''} ${s.clock || ''}</span>
              </div>
              <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
                <div style="font-size:22px;font-weight:800;">${s.awayScore || 0} - ${s.homeScore || 0}</div>
                <div style="background:var(--green-light);padding:4px 12px;border-radius:8px;font-size:12px;font-weight:700;color:var(--green);">${s.betTeam} ${s.bookSpread}${s.estLiveSpread != null ? ` (live ~${s.estLiveSpread})` : ''}</div>
              </div>
              <div style="display:flex;gap:8px;margin-bottom:10px;">
                <div style="flex:1;background:var(--bg);border-radius:var(--radius-sm);padding:8px;text-align:center;">
                  <div style="font-size:10px;color:var(--text-muted);font-weight:600;">${s.betTeam || ''}</div>
                  <div style="font-size:16px;font-weight:800;color:var(--green);">.${(strongPct * 10 | 0)}</div>
                  <div style="height:4px;background:var(--border);border-radius:2px;margin-top:4px;"><div style="height:100%;background:var(--green);border-radius:2px;width:${strongPct}%;"></div></div>
                </div>
                <div style="flex:1;background:var(--bg);border-radius:var(--radius-sm);padding:8px;text-align:center;">
                  <div style="font-size:10px;color:var(--text-muted);font-weight:600;">${s.fadeTeam || ''}</div>
                  <div style="font-size:16px;font-weight:800;color:var(--text-secondary);">.${(weakPct * 10 | 0)}</div>
                  <div style="height:4px;background:var(--border);border-radius:2px;margin-top:4px;"><div style="height:100%;background:var(--text-muted);border-radius:2px;width:${weakPct}%;"></div></div>
                </div>
              </div>
              <div style="display:flex;gap:8px;align-items:center;">
                <div style="background:var(--green);color:white;padding:6px 14px;border-radius:8px;font-size:12px;font-weight:800;">BET ${s.betTeam} SPREAD</div>
                <div style="font-size:11px;color:var(--text-muted);">Trailing by ${s.trailingBy} &bull; Gap: ${gapPct}% &bull; Live spread still negative${s.urgency ? ' &bull; ' + s.urgency : ''}</div>
              </div>
            </div>`;
          }).join('');
        }
      }

      // Render recent results
      const recentEl = document.getElementById('qe-recent-results');
      if (recentEl) {
        if (completed.length === 0) {
          recentEl.innerHTML = '<div style="text-align:center;padding:20px;color:var(--text-muted);font-size:12px;background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);">No completed Quality Edge signals yet.</div>';
        } else {
          recentEl.innerHTML = '<div style="display:grid;gap:8px;">' + completed.map(s => {
            const won = s.spreadResult === 'WIN';
            const color = won ? 'var(--green)' : 'var(--red)';
            const bg = won ? 'var(--green-light)' : 'var(--red-light)';
            return `<div style="background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius-sm);padding:12px;display:flex;justify-content:space-between;align-items:center;">
              <div>
                <div style="font-size:13px;font-weight:700;">${s.game || ''}</div>
                <div style="font-size:11px;color:var(--text-muted);">${s.betTeam} ${s.bookSpread} &bull; Gap ${s.qualityGap}% &bull; Trail ${s.trailingBy}</div>
              </div>
              <div style="display:flex;align-items:center;gap:8px;">
                <span style="font-size:11px;color:var(--text-muted);">${s.finalAwayScore || '?'}-${s.finalHomeScore || '?'}</span>
                <span style="background:${bg};color:${color};font-size:11px;font-weight:800;padding:3px 10px;border-radius:6px;">${s.spreadResult || 'PENDING'}</span>
                ${s.spreadPayout ? `<span style="font-size:12px;font-weight:700;color:${color};">${s.spreadPayout > 0 ? '+' : ''}$${Math.round(s.spreadPayout)}</span>` : ''}
              </div>
            </div>`;
          }).join('') + '</div>';
        }
      }
    }).catch(() => {});
  } catch(e) {}
}

let _trackerModeFilter = null; // null = all, 'nba', 'ncaab'
function setTrackerMode(mode) {
  _trackerModeFilter = mode;
  renderSignalTracker();
}
function renderSignalTracker() {
  const el = document.getElementById('signal-tracker-content');
  if (!el) return;

  const st = getSignalTrackerStats(_trackerModeFilter);
  const allFiltered = _trackerModeFilter
    ? state.signalTracker.filter(s => s.mode === _trackerModeFilter)
    : state.signalTracker;
  const all = allFiltered.slice().reverse();

  // Count by mode for tab badges
  const nbaCount = state.signalTracker.filter(s => s.mode === 'nba').length;
  const ncaaCount = state.signalTracker.filter(s => s.mode === 'ncaab').length;

  let h = '';

  // Mode filter tabs
  h += '<div style="display:flex;gap:6px;margin-bottom:14px;">';
  const tabStyle = (active) => `padding:6px 14px;font-size:11px;font-weight:700;border-radius:20px;cursor:pointer;border:1px solid ${active ? 'var(--accent)' : 'var(--border)'};background:${active ? 'var(--accent-light)' : 'var(--card-bg)'};color:${active ? 'var(--accent)' : 'var(--text-muted)'};`;
  h += `<div style="${tabStyle(!_trackerModeFilter)}" onclick="setTrackerMode(null)">ALL (${state.signalTracker.length})</div>`;
  h += `<div style="${tabStyle(_trackerModeFilter==='nba')}" onclick="setTrackerMode('nba')">NBA (${nbaCount})</div>`;
  h += `<div style="${tabStyle(_trackerModeFilter==='ncaab')}" onclick="setTrackerMode('ncaab')">NCAA (${ncaaCount})</div>`;
  h += '</div>';

  if (all.length === 0) {
    el.innerHTML = h + '<div style="text-align:center;padding:40px 20px;color:var(--text-muted);font-size:13px;">No signals tracked' + (_trackerModeFilter ? ' for ' + (_trackerModeFilter === 'ncaab' ? 'NCAA' : 'NBA') : '') + '. Signals are automatically recorded when combined signals (level 2) fire during live games with auto-refresh on.</div>';
    return;
  }

  // ===== BANKROLL HEADER =====
  const bkColor = st.currentBankroll >= TRACKER_BANKROLL ? 'var(--green)' : 'var(--red)';
  const pnl = st.mlProfit;
  const pnlSign = pnl >= 0 ? '+' : '';
  h += '<div class="card" style="margin-bottom:16px;padding:16px 20px;background:linear-gradient(135deg,var(--card-bg),var(--accent-light));border:1px solid var(--accent)">';
  h += '<div style="display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;gap:12px">';
  h += '<div><div style="font-size:10px;font-weight:700;color:var(--text-muted);letter-spacing:1px;margin-bottom:4px">BACKTEST BANKROLL</div>';
  h += '<div style="font-size:28px;font-weight:800;color:'+bkColor+'">$'+st.currentBankroll.toLocaleString()+'</div>';
  h += '<div style="font-size:11px;color:var(--text-muted)">Started: $'+TRACKER_BANKROLL.toLocaleString()+' | P&L: <span style="color:'+bkColor+'">'+pnlSign+'$'+pnl.toLocaleString()+'</span></div></div>';
  h += '<div style="text-align:right"><div style="font-size:10px;font-weight:700;color:var(--text-muted);letter-spacing:1px;margin-bottom:4px">KELLY SIZING</div>';
  const _resolved = st.completed;
  const _sizingMode = _resolved < TRACKER_MIN_SAMPLE
    ? 'FLAT UNIT: $'+TRACKER_FLAT_UNIT+'/bet ('+_resolved+'/'+TRACKER_MIN_SAMPLE+' signals to unlock Kelly)'
    : 'KELLY: empirical edge  Half-Kelly  Max '+Math.round(TRACKER_MAX_KELLY*100)+'% ($'+(TRACKER_BANKROLL*TRACKER_MAX_KELLY).toLocaleString()+')';
  h += '<div style="font-size:12px;color:var(--text-secondary);line-height:1.6">'+_sizingMode+'<br>Odds: live market or -110 default</div></div>';
  h += '</div></div>';

  // ===== SUMMARY STATS GRID =====
  h += '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:10px;margin-bottom:16px">';

  const statCard = (label, value, sub, color) => {
    return '<div class="card" style="padding:14px;text-align:center"><div style="font-size:9px;font-weight:700;color:var(--text-muted);letter-spacing:0.8px;margin-bottom:6px">'+label+'</div><div style="font-size:22px;font-weight:800;color:'+(color||'var(--text-primary)')+'">'+value+'</div><div style="font-size:10px;color:var(--text-muted);margin-top:2px">'+sub+'</div></div>';
  };

  h += statCard('TRACKED', st.total, st.pending+' pending', 'var(--accent)');
  h += statCard('ML RECORD', st.mlW+'-'+st.mlL, st.mlWR+'% win rate', st.mlWR>=52.4?'var(--green)':'var(--red)');
  h += statCard('ATS RECORD', st.atsW+'-'+st.atsL+'-'+st.atsP, st.atsWR+'% win rate', st.atsWR>=52.4?'var(--green)':'var(--red)');
  h += statCard('ML P&L', (st.mlProfit>=0?'+':'')+' $'+st.mlProfit.toLocaleString(), 'ROI: '+(st.mlROI>=0?'+':'')+st.mlROI+'%', st.mlProfit>=0?'var(--green)':'var(--red)');
  h += statCard('ATS P&L', (st.atsProfit>=0?'+':'')+' $'+st.atsProfit.toLocaleString(), 'ROI: '+(st.atsROI>=0?'+':'')+st.atsROI+'%', st.atsProfit>=0?'var(--green)':'var(--red)');
  h += statCard('TOTAL RISKED', '$'+st.totalRisked.toLocaleString(), st.completed+' resolved', 'var(--text-primary)');
  // LEC card
  const lecVal = st.avgLec5 !== null ? (st.avgLec5 > 0 ? '+' : '') + st.avgLec5 : '--';
  const lecColor = st.avgLec5 === null ? 'var(--text-muted)' : st.avgLec5 > 0 ? 'var(--green)' : 'var(--red)';
  const lecSub = st.lecCount5 > 0 ? st.lecPositive5 + '/' + st.lecCount5 + ' moved in favor (5m)' : 'Needs live odds data';
  h += statCard('LEC (5 MIN)', lecVal, lecSub, lecColor);
  // Near-miss counterfactual card
  const nmVal = st.nearMissCompleted > 0 ? st.nearMissWR + '%' : '--';
  const nmColor = st.nearMissCompleted === 0 ? 'var(--text-muted)' : st.nearMissWR >= 52.4 ? 'var(--orange)' : 'var(--text-muted)';
  h += statCard('NEAR-MISS WR', nmVal, st.nearMissTotal + ' tracked (' + st.nearMissCompleted + ' resolved)', nmColor);
  h += '</div>';

  // ===== BREAKDOWN BY SIGNAL TYPE =====
  const sigKeys = Object.keys(st.bySig);
  if (sigKeys.length > 0) {
    h += '<div style="margin-bottom:16px"><div style="font-size:12px;font-weight:700;margin-bottom:8px;color:var(--text-muted);letter-spacing:0.5px">BY SIGNAL TYPE</div>';
    h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px">';
    sigKeys.forEach(sig => {
      const d = st.bySig[sig];
      const mlWR = d.n>0?Math.round(d.mlW/d.n*100):0;
      const atsWR = d.n>0?Math.round(d.atsW/d.n*100):0;
      h += '<div class="card" style="padding:12px"><div style="font-size:12px;font-weight:800;color:var(--accent);margin-bottom:6px">'+sig.toUpperCase()+' <span style="font-weight:400;color:var(--text-muted)">(n='+d.n+')</span></div>';
      h += '<div style="font-size:11px;line-height:1.8">';
      h += 'ML: <strong style="color:'+(mlWR>=52.4?'var(--green)':'var(--red)')+'">'+d.mlW+'-'+d.mlL+'</strong> ('+mlWR+'%) | '+(d.mlProfit>=0?'+':'')+' $'+d.mlProfit.toLocaleString()+'<br>';
      h += 'ATS: <strong style="color:'+(atsWR>=52.4?'var(--green)':'var(--red)')+'">'+d.atsW+'-'+d.atsL+'-'+d.atsP+'</strong> ('+atsWR+'%) | '+(d.atsProfit>=0?'+':'')+' $'+d.atsProfit.toLocaleString();
      h += '</div></div>';
    });
    h += '</div></div>';
  }

  // ===== BREAKDOWN BY QUARTER =====
  const qKeys = Object.keys(st.byQ).sort();
  if (qKeys.length > 0) {
    h += '<div style="margin-bottom:16px"><div style="font-size:12px;font-weight:700;margin-bottom:8px;color:var(--text-muted);letter-spacing:0.5px">BY QUARTER</div>';
    h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:10px">';
    qKeys.forEach(q => {
      const d = st.byQ[q];
      const mlWR = d.n>0?Math.round(d.mlW/d.n*100):0;
      h += '<div class="card" style="padding:12px"><div style="font-size:14px;font-weight:800;color:var(--accent);margin-bottom:4px">'+q+' <span style="font-weight:400;color:var(--text-muted);font-size:11px">(n='+d.n+')</span></div>';
      h += '<div style="font-size:11px">ML: <strong style="color:'+(mlWR>=52.4?'var(--green)':'var(--red)')+'">'+d.mlW+'-'+d.mlL+'</strong> ('+mlWR+'%) | P&L: <span style="color:'+(d.mlProfit>=0?'var(--green)':'var(--red)')+'">'+(d.mlProfit>=0?'+':'')+' $'+d.mlProfit.toLocaleString()+'</span></div>';
      h += '</div>';
    });
    h += '</div></div>';
  }

  // ===== BREAKDOWN BY REC TYPE =====
  const recKeys = Object.keys(st.byRec);
  if (recKeys.length > 0) {
    h += '<div style="margin-bottom:16px"><div style="font-size:12px;font-weight:700;margin-bottom:8px;color:var(--text-muted);letter-spacing:0.5px">BY REC TYPE</div>';
    h += '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:10px">';
    recKeys.forEach(rt => {
      const d = st.byRec[rt];
      const mlWR = d.n>0?Math.round(d.mlW/d.n*100):0;
      const atsWR = d.n>0?Math.round(d.atsW/d.n*100):0;
      h += '<div class="card" style="padding:12px"><div style="font-size:12px;font-weight:800;color:'+(rt==='ML'?'var(--orange)':'var(--purple, #7c3aed)')+';margin-bottom:6px">'+rt+' <span style="font-weight:400;color:var(--text-muted)">(n='+d.n+')</span></div>';
      h += '<div style="font-size:11px;line-height:1.8">';
      h += 'ML: <strong>'+d.mlW+'-'+d.mlL+'</strong> ('+mlWR+'%) | '+(d.mlProfit>=0?'+':'')+' $'+d.mlProfit.toLocaleString()+'<br>';
      h += 'ATS: <strong>'+d.atsW+'-'+d.atsL+'</strong> ('+atsWR+'%) | '+(d.atsProfit>=0?'+':'')+' $'+d.atsProfit.toLocaleString();
      h += '</div></div>';
    });
    h += '</div></div>';
  }

  // ===== SIGNAL HISTORY TABLE =====
  const thS = 'padding:8px 6px;font-size:9px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px;color:var(--text-muted);border-bottom:2px solid var(--border);white-space:nowrap;text-align:left';
  h += '<div class="card" style="padding:0;overflow:hidden"><div style="overflow-x:auto">';
  h += '<table style="width:100%;border-collapse:collapse;font-size:11px"><thead><tr>';
  h += '<th style="'+thS+'">Date</th><th style="'+thS+'">Game</th><th style="'+thS+'">Side</th><th style="'+thS+'">Rec</th><th style="'+thS+'">Spread</th>';
  h += '<th style="'+thS+'">Score@Signal</th><th style="'+thS+'">Final</th><th style="'+thS+'">Bet</th>';
  h += '<th style="'+thS+'">ML</th><th style="'+thS+'">ATS</th><th style="'+thS+'">ML P&L</th><th style="'+thS+'">ATS P&L</th>';
  h += '</tr></thead><tbody>';

  all.forEach(s => {
    const td = 'padding:8px 6px;border-bottom:1px solid var(--border-light, rgba(255,255,255,0.06));white-space:nowrap';
    const periodStr = s.mode === 'ncaab' ? ((s.period||0) <= 2 ? 'H'+(s.period||'?') : 'OT'+((s.period||3)-2)) : 'Q'+(s.period||'?');
    const modeBadge = s.mode === 'ncaab' ? '<span style="font-size:8px;font-weight:700;color:var(--orange);background:var(--orange-light);padding:1px 4px;border-radius:3px;margin-right:3px;">NCAA</span>' : '';
    const scoreAt = s.awayScore+'-'+s.homeScore+' '+periodStr+' '+(s.clock||'');
    const final_ = s.gameCompleted ? s.finalAwayScore+'-'+s.finalHomeScore : '<span style="color:var(--orange)">Pending</span>';
    const mlC = s.mlResult==='W'?'var(--green)':s.mlResult==='L'?'var(--red)':'var(--text-muted)';
    const atsC = s.atsResult==='W'?'var(--green)':s.atsResult==='L'?'var(--red)':s.atsResult==='P'?'var(--orange)':'var(--text-muted)';
    const mlPL = s.mlPayout!==null ? (s.mlPayout>=0?'+':'')+' $'+s.mlPayout.toLocaleString() : '-';
    const mlPLC = (s.mlPayout||0)>0?'var(--green)':(s.mlPayout||0)<0?'var(--red)':'var(--text-muted)';
    const atsPL = s.atsPayout!==null ? (s.atsPayout>=0?'+':'')+' $'+s.atsPayout.toLocaleString() : '-';
    const atsPLC = (s.atsPayout||0)>0?'var(--green)':(s.atsPayout||0)<0?'var(--red)':'var(--text-muted)';
    const sigs = (s.signals||[]).map(x => '<span style="display:inline-block;font-size:8px;padding:1px 4px;border-radius:3px;background:var(--accent-light);color:var(--accent);font-weight:600;margin-left:2px">'+x+'</span>').join('');

    h += '<tr>';
    h += '<td style="'+td+';font-size:10px;color:var(--text-muted)">'+s.date+'</td>';
    h += '<td style="'+td+';font-weight:600">'+modeBadge+s.game+'</td>';
    h += '<td style="'+td+';color:var(--accent);font-weight:700">'+s.signalSide+' '+sigs+'</td>';
    h += '<td style="'+td+';font-weight:700;color:'+(s.recType==='ML'?'var(--orange)':'var(--purple, #7c3aed)')+'">'+s.recType+'</td>';
    h += '<td style="'+td+';font-family:monospace">'+(s.spreadLine||'-')+'</td>';
    h += '<td style="'+td+';font-family:monospace;font-size:10px">'+scoreAt+'</td>';
    h += '<td style="'+td+';font-family:monospace;font-weight:700">'+final_+'</td>';
    h += '<td style="'+td+';font-family:monospace;font-size:10px">$'+(s.kellyBet||0).toLocaleString()+' <span style="color:var(--text-muted);font-size:8px">('+((s.kellyPct||0))+'%)</span></td>';
    h += '<td style="'+td+';font-weight:800;color:'+mlC+'">'+(s.mlResult||'-')+'</td>';
    h += '<td style="'+td+';font-weight:800;color:'+atsC+'">'+(s.atsResult||'-')+'</td>';
    h += '<td style="'+td+';font-family:monospace;color:'+mlPLC+'">'+mlPL+'</td>';
    h += '<td style="'+td+';font-family:monospace;color:'+atsPLC+'">'+atsPL+'</td>';
    h += '</tr>';
  });

  h += '</tbody></table></div></div>';
  el.innerHTML = h;
}

function exportSignalTracker() {
  const data = state.signalTracker;
  if (data.length === 0) { alert('No signals tracked yet'); return; }
  let csv = 'Date,Game,SignalSide,RecType,SpreadLine,Signals,MarketOdds,KellyPct,KellyBet,EstEdge,AwayScore,HomeScore,Period,Clock,FinalAway,FinalHome,ML,ATS,MLPayout,ATSPayout\n';
  data.forEach(s => {
    csv += s.date+',"'+s.game+'",'+s.signalSide+','+s.recType+','+(s.spreadLine||'')+',"'+(s.signals||[]).join(';')+'",'+(s.marketOdds||'')+','+(s.kellyPct||'')+','+(s.kellyBet||'')+','+(s.estEdge||'')+','+s.awayScore+','+s.homeScore+','+(s.period||'')+','+(s.clock||'')+','+(s.finalAwayScore!==null?s.finalAwayScore:'')+','+(s.finalHomeScore!==null?s.finalHomeScore:'')+','+(s.mlResult||'')+','+(s.atsResult||'')+','+(s.mlPayout||0)+','+(s.atsPayout||0)+'\n';
  });
  const blob = new Blob([csv], {type:'text/csv'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'signal-backtest-'+new Date().toISOString().split('T')[0]+'.csv';
  a.click();
}


// ==================== AUTO-RESOLVE BETS FROM ESPN FINAL SCORES ====================
async function autoResolveBets() {
  let log = JSON.parse(localStorage.getItem('betLog') || '[]');
  const pending = log.filter(b => !b.outcome && b.gameId);
  if (pending.length === 0) return;

  try {
    // Fetch scoreboard  it includes completed games from today
    const url = getESPNUrl();
    const resp = await fetch(url);
    if (!resp.ok) return;
    const data = await resp.json();
    const events = data.events || [];

    let changed = false;
    pending.forEach(bet => {
      // Find the matching game by gameId
      const event = events.find(e => e.id === bet.gameId || e.id === String(bet.gameId));
      if (!event) return;

      // Only resolve if game is FINAL
      const gameState = event.status?.type?.state;
      if (gameState !== 'post') return;

      const comp = event.competitions?.[0];
      if (!comp) return;
      const away = comp.competitors?.find(c => c.homeAway === 'away');
      const home = comp.competitors?.find(c => c.homeAway === 'home');
      if (!away || !home) return;

      const aScore = parseInt(away.score) || 0;
      const hScore = parseInt(home.score) || 0;
      const aAbbr = away.team?.abbreviation || '';
      const hAbbr = home.team?.abbreviation || '';

      // Determine winner abbreviation
      const winner = aScore > hScore ? aAbbr : hAbbr;

      // Check if our bet team won
      // bet.team could be abbreviation like "BOS" or display name
      const betTeamUpper = bet.team.toUpperCase();
      const betWon = betTeamUpper === winner.toUpperCase() ||
                     winner.toUpperCase().includes(betTeamUpper) ||
                     betTeamUpper.includes(winner.toUpperCase());

      bet.outcome = betWon ? 'W' : 'L';
      bet.finalScore = aAbbr + ' ' + aScore + ' - ' + hScore + ' ' + hAbbr;

      if (betWon) {
        const odds = bet.marketOdds;
        const multiplier = odds > 0 ? odds / 100 : 100 / Math.abs(odds);
        bet.payout = Math.round(bet.kellyBet * multiplier * 100) / 100;
      } else {
        bet.payout = -bet.kellyBet;
      }

      changed = true;
    });

    if (changed) {
      localStorage.setItem('betLog', JSON.stringify(log));
      renderBetLog();
      updateBacktestPanel();
    }
  } catch (e) {
    console.warn('Auto-resolve error:', e);
  }
}

function markOutcome(id, won) {
  let log = JSON.parse(localStorage.getItem('betLog') || '[]');
  const entry = log.find(x => x.id === id);
  if (!entry) return;
  entry.outcome = won ? 'W' : 'L';
  if (won) {
    const b = entry.marketOdds > 0 ? entry.marketOdds / 100 : 100 / Math.abs(entry.marketOdds);
    entry.payout = Math.round(entry.kellyBet * b * 100) / 100;
  } else {
    entry.payout = -entry.kellyBet;
  }
  localStorage.setItem('betLog', JSON.stringify(log));
  renderBetLog();
  updateBacktestPanel();
}

function getBacktestData() {
  const log = JSON.parse(localStorage.getItem('betLog') || '[]');
  const settled = log.filter(x => x.outcome);
  const total = settled.length;
  const wins = settled.filter(x => x.outcome === 'W').length;
  const winRate = total > 0 ? Math.round(wins / total * 1000) / 10 : 0;
  const totalPayout = settled.reduce((s, x) => s + (x.payout || 0), 0);
  const totalRisked = settled.reduce((s, x) => s + x.kellyBet, 0);
  const roi = totalRisked > 0 ? Math.round(totalPayout / totalRisked * 1000) / 10 : 0;
  const avgEdge = total > 0 ? Math.round(settled.reduce((s, x) => s + (x.estimatedP - x.impliedP), 0) / total * 10) / 10 : 0;
  const units = Math.round(totalPayout / 100 * 100) / 100;
  const bySignal = {};
  settled.forEach(x => {
    (x.signals || []).forEach(sig => {
      if (!bySignal[sig]) bySignal[sig] = { total: 0, wins: 0, payout: 0 };
      bySignal[sig].total++;
      if (x.outcome === 'W') bySignal[sig].wins++;
      bySignal[sig].payout += (x.payout || 0);
    });
  });
  return { total, wins, winRate, roi, edge: avgEdge / 100, units, bySignal };
}

function renderBetLog() {
  const el = document.getElementById('bet-log-entries');
  if (!el) return;
  const log = JSON.parse(localStorage.getItem('betLog') || '[]').slice().reverse();
  if (log.length === 0) {
    el.innerHTML = '<p style="color:var(--text-muted);text-align:center;padding:40px;font-size:13px">No bets logged yet. Bets are auto-logged when combined signals fire.</p>';
    return;
  }
  const thS = 'padding:10px 12px;font-size:10px;font-weight:700;text-transform:uppercase;letter-spacing:1px;color:var(--text-muted);border-bottom:2px solid var(--border)';
  let html = '<table style="width:100%;border-collapse:collapse;font-size:12px"><thead><tr>';
  html += '<th style="' + thS + ';text-align:left">TIME</th>';
  html += '<th style="' + thS + ';text-align:left">TEAM</th>';
  html += '<th style="' + thS + ';text-align:left">SIGNALS</th>';
  html += '<th style="' + thS + ';text-align:right">ODDS</th>';
  html += '<th style="' + thS + ';text-align:right">EDGE</th>';
  html += '<th style="' + thS + ';text-align:right">KELLY</th>';
  html += '<th style="' + thS + ';text-align:right">SIZE</th>';
  html += '<th style="' + thS + ';text-align:center">RESULT</th>';
  html += '<th style="' + thS + ';text-align:right">P/L</th>';
  html += '</tr></thead><tbody>';
  log.forEach(b => {
    const t = new Date(b.timestamp);
    const time = (t.getMonth()+1) + '/' + t.getDate() + ' ' + t.getHours() + ':' + String(t.getMinutes()).padStart(2,'0');
    const oddsStr = b.marketOdds > 0 ? '+' + b.marketOdds : '' + b.marketOdds;
    const edgeVal = b.estimatedP && b.impliedP ? (b.estimatedP - b.impliedP).toFixed(1) + '%' : '-';
    let resultCell;
    if (b.outcome) {
      const color = b.outcome === 'W' ? 'var(--green)' : 'var(--red)';
      const bg = b.outcome === 'W' ? 'var(--green-light)' : 'var(--red-light)';
      resultCell = '<span style="color:' + color + ';background:' + bg + ';font-weight:700;padding:2px 10px;border-radius:4px;font-size:11px">' + b.outcome + '</span>';
      if (b.finalScore) resultCell += '<div style="font-size:9px;color:var(--text-muted);margin-top:2px">' + b.finalScore + '</div>';
    } else {
      resultCell = '<span style="font-size:10px;color:var(--orange);font-weight:600">PENDING</span>';
      resultCell += '<div style="margin-top:3px"><button onclick="markOutcome(' + b.id + ',true)" style="background:var(--green-light);color:var(--green);border:none;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:10px;font-weight:700;margin-right:3px">W</button>';
      resultCell += '<button onclick="markOutcome(' + b.id + ',false)" style="background:var(--red-light);color:var(--red);border:none;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:10px;font-weight:700">L</button></div>';
    }
    const plStr = b.payout != null ? (b.payout >= 0 ? '+$' : '-$') + Math.abs(b.payout).toFixed(0) : '-';
    const plColor = b.payout > 0 ? 'var(--green)' : b.payout < 0 ? 'var(--red)' : 'var(--text-muted)';
    const sigBadges = (b.signals||[]).map(s => '<span class="signal-badge badge-' + s + '" style="font-size:9px;padding:1px 6px">' + s.toUpperCase() + '</span>').join(' ');
    html += '<tr style="border-bottom:1px solid var(--border-light)">';
    html += '<td style="padding:10px 12px;color:var(--text-muted);font-size:11px">' + time + '</td>';
    html += '<td style="padding:10px 12px;color:var(--text-primary);font-weight:700">' + b.team + ' <span style="color:var(--text-muted);font-weight:400">' + (b.side||'ML') + '</span></td>';
    html += '<td style="padding:10px 12px">' + sigBadges + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-secondary);font-family:monospace">' + oddsStr + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--accent);font-weight:600">' + edgeVal + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-secondary)">' + b.kellyPct + '%</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-primary);font-weight:700">$' + b.kellyBet + '</td>';
    html += '<td style="padding:10px 12px;text-align:center">' + resultCell + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:' + plColor + ';font-weight:700">' + plStr + '</td>';
    html += '</tr>';
  });
  html += '</tbody></table>';
  el.innerHTML = html;
}

function updateBacktestPanel() {
  const d = getBacktestData();
  const btTotal = document.getElementById('bt-total');
  if (!btTotal) return;
  btTotal.textContent = d.total;
  const wrEl = document.getElementById('bt-winrate');
  wrEl.textContent = d.total > 0 ? d.winRate + '%' : '-';
  wrEl.style.color = d.winRate >= 55 ? 'var(--green)' : d.winRate >= 45 ? 'var(--orange)' : 'var(--red)';
  const roiEl = document.getElementById('bt-roi');
  roiEl.textContent = d.total > 0 ? (d.roi >= 0 ? '+' : '') + d.roi + '%' : '-';
  roiEl.style.color = d.roi > 0 ? 'var(--green)' : d.roi < 0 ? 'var(--red)' : 'var(--text-primary)';
  document.getElementById('bt-edge').textContent = d.total > 0 ? (d.edge * 100).toFixed(1) + '%' : '-';
  const unitsEl = document.getElementById('bt-units');
  unitsEl.textContent = (d.units >= 0 ? '+' : '') + d.units.toFixed(2);
  unitsEl.style.color = d.units > 0 ? 'var(--green)' : d.units < 0 ? 'var(--red)' : 'var(--text-primary)';
  const bd = document.getElementById('signal-breakdown');
  if (!bd) return;
  const sigs = Object.keys(d.bySignal);
  if (sigs.length === 0) { bd.innerHTML = ''; return; }
  let html = '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:10px">';
  sigs.forEach(sig => {
    const sd = d.bySignal[sig];
    const wr = sd.total > 0 ? Math.round(sd.wins / sd.total * 100) : 0;
    const wrColor = wr >= 55 ? 'var(--green)' : wr >= 45 ? 'var(--orange)' : 'var(--red)';
    html += '<div class="stat-card" style="padding:12px"><div style="margin-bottom:6px"><span class="signal-badge badge-' + sig + '" style="font-size:10px">' + sig.toUpperCase() + '</span></div>';
    html += '<div style="color:' + wrColor + ';font-size:20px;font-weight:800">' + wr + '%</div>';
    html += '<div style="color:var(--text-muted);font-size:11px;margin-top:2px">' + sd.wins + 'W-' + (sd.total - sd.wins) + 'L | $' + Math.round(sd.payout) + '</div></div>';
  });
  html += '</div>';
  bd.innerHTML = html;
}

function updateKelly() {
  const el = document.getElementById('kelly-recs');
  if (!el) return;
  if (typeof gameTheses === 'undefined' || !gameTheses || gameTheses.length === 0) {
    el.innerHTML = '<p style="color:var(--text-muted);text-align:center;padding:30px;font-size:13px">Refresh games to see Kelly-sized recommendations</p>';
    return;
  }
  const recs = gameTheses.filter(t => t.marketOdds && t.kellyPct > 0);
  if (recs.length === 0) {
    el.innerHTML = '<p style="color:var(--text-muted);text-align:center;padding:30px;font-size:13px">No positive-edge bets found in current games</p>';
    return;
  }
  const thS = 'padding:10px 12px;font-size:10px;font-weight:700;text-transform:uppercase;letter-spacing:1px;color:var(--text-muted);border-bottom:2px solid var(--border)';
  let html = '<table style="width:100%;border-collapse:collapse;font-size:13px"><thead><tr>';
  html += '<th style="' + thS + ';text-align:left">GAME</th>';
  html += '<th style="' + thS + ';text-align:left">BET</th>';
  html += '<th style="' + thS + ';text-align:right">ODDS</th>';
  html += '<th style="' + thS + ';text-align:right">EDGE</th>';
  html += '<th style="' + thS + ';text-align:right">KELLY %</th>';
  html += '<th style="' + thS + ';text-align:right">BET SIZE</th>';
  html += '</tr></thead><tbody>';
  recs.forEach(t => {
    const oddsStr = t.marketOdds > 0 ? '+' + t.marketOdds : '' + t.marketOdds;
    const sigs = (t.signals||[]).filter(s=>s.level===2).map(s => '<span class="signal-badge badge-' + s.type + '" style="font-size:9px;padding:1px 6px">' + s.type.toUpperCase() + '</span>').join(' ');
    html += '<tr style="border-bottom:1px solid var(--border-light)">';
    html += '<td style="padding:10px 12px;color:var(--text-primary);font-weight:600">' + (t.game||t.betSide) + '</td>';
    html += '<td style="padding:10px 12px"><span style="color:var(--accent);font-weight:700">' + t.betSide + ' ML</span> ' + sigs + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-secondary);font-family:monospace">' + oddsStr + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--accent);font-weight:600">' + (t.kellyEdge||t.edge||'-') + '%</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-primary);font-weight:700">' + t.kellyPct + '%</td>';
    html += '<td style="padding:10px 12px;text-align:right"><span style="background:var(--accent-light);color:var(--accent);font-weight:800;padding:4px 12px;border-radius:6px;font-size:13px">$' + t.kellyBet + '</span></td>';
    html += '</tr>';
  });
  html += '</tbody></table>';
  el.innerHTML = html;
}

function saveBankrollSettings() {
  localStorage.setItem('bankrollSettings', JSON.stringify({
    bankroll: document.getElementById('bankroll-input').value,
    fraction: document.getElementById('kelly-fraction').value,
    edgeMode: document.getElementById('edge-mode').value
  }));
  updateKelly();
    renderStarDB();
}

function loadBankrollSettings() {
  const saved = JSON.parse(localStorage.getItem('bankrollSettings') || 'null');
  if (!saved) return;
  const bi = document.getElementById('bankroll-input');
  if (bi) bi.value = saved.bankroll || 1000;
  const kf = document.getElementById('kelly-fraction');
  if (kf) kf.value = saved.fraction || '0.5';
  const em = document.getElementById('edge-mode');
  if (em) em.value = saved.edgeMode || 'moderate';
}

function exportBetLog() {
  const log = JSON.parse(localStorage.getItem('betLog') || '[]');
  if (log.length === 0) { alert('No bets to export'); return; }
  let csv = 'Timestamp,Team,Side,Signals,MarketOdds,ImpliedP,EstimatedP,KellyPct,BetSize,Outcome,PL\n';
  log.forEach(b => {
    csv += b.timestamp + ',' + b.team + ',' + b.side + ',"' + (b.signals||[]).join(';') + '",' + b.marketOdds + ',' + b.impliedP + ',' + b.estimatedP + ',' + b.kellyPct + ',' + b.kellyBet + ',' + (b.outcome||'') + ',' + (b.payout||0) + '\n';
  });
  const blob = new Blob([csv], {type:'text/csv'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'bet_log_' + new Date().toISOString().slice(0,10) + '.csv';
  a.click();
}

function clearBetLog() {
  localStorage.removeItem('betLog');
  renderBetLog();
  updateBacktestPanel();
}
function resolveBet(id,r) {
  const b=state.betLog.find(x=>x.id===id); if(!b) return; b.result=r;
  if(r==='W'){const p=parseInt(b.price)||-110; b.profit=p>0?b.units*(p/100):b.units*(100/Math.abs(p));}
  else if(r==='L') b.profit=-b.units; else b.profit=0;
  localStorage.setItem('betLog',JSON.stringify(state.betLog)); renderBetLog();
}
function updateLogStats() {
  const r=state.betLog.filter(b=>b.result!=='Pending'), w=r.filter(b=>b.result==='W').length, t=r.length;
  const nu=r.reduce((s,b)=>s+b.profit,0), tr=r.reduce((s,b)=>s+b.units,0);
  document.getElementById('log-total').textContent=state.betLog.length;
  document.getElementById('log-winrate').textContent=t>0?(w/t*100).toFixed(1)+'%':'-';
  document.getElementById('log-net-units').textContent=(nu>=0?'+':'')+nu.toFixed(2);
  document.getElementById('log-net-units').className=`stat-value ${nu>=0?'green':'red'}`;
  document.getElementById('log-roi').textContent=tr>0?(nu/tr*100).toFixed(1)+'%':'-';
  let streak=0,st='';
  for(let i=r.length-1;i>=0;i--){if(i===r.length-1){st=r[i].result;streak=1;}else if(r[i].result===st)streak++;else break;}
  const se=document.getElementById('log-streak');
  if(streak>0){se.textContent=streak+st;se.className=`stat-value ${st==='W'?'green':st==='L'?'red':''}`;}else se.textContent='-';
}
function clearLog(){if(confirm('Clear ALL?')){state.betLog=[];localStorage.setItem('betLog','[]');renderBetLog();}}
function exportLog(){
  if(!state.betLog.length){alert('No bets');return;}
  const h='Date,Strategy,Game,Side,Price,Units,Result,Profit,Notes\n';
  const r=state.betLog.map(b=>`${b.date},${b.strategy},"${b.game}",${b.side},${b.price},${b.units},${b.result},${b.profit.toFixed(2)},"${b.notes}"`).join('\n');
  const a=document.createElement('a');a.href=URL.createObjectURL(new Blob([h+r],{type:'text/csv'}));a.download=`NBA_Edge_${new Date().toISOString().slice(0,10)}.csv`;a.click();
}

// ==================== BANKROLL ====================
function updateBankroll() {
  const s=parseFloat(document.getElementById('bankroll-start').value)||0, c=parseFloat(document.getElementById('bankroll-current').value)||0;
  state.bankroll={start:s,current:c}; localStorage.setItem('bankroll',JSON.stringify(state.bankroll));
  const u=c*0.01;
  document.getElementById('br-unit').textContent=u>0?'$'+u.toFixed(0):'-';
  document.getElementById('br-max').textContent=u>0?'$'+(u*2).toFixed(0):'-';
  document.getElementById('br-daily').textContent=u>0?'$'+(u*5).toFixed(0):'-';
  const pl=c-s;
  document.getElementById('br-pl').textContent=s>0?(pl>=0?'+':'')+`$${pl.toFixed(0)}`:'-';
  document.getElementById('br-pl').className=`stat-value ${pl>=0?'green':'red'}`;
  const pct=s>0?(pl/s*100):0;
  document.getElementById('br-pl-pct').textContent=s>0?(pct>=0?'+':'')+pct.toFixed(1)+'%':'-';
  document.getElementById('br-pl-pct').className=`stat-value ${pct>=0?'green':'red'}`;
}
document.getElementById('logModal').addEventListener('click',function(e){if(e.target===this)closeModal();});


// ==================== SOUND SYSTEM (Web Audio API) ====================
let audioCtx = null;
let soundEnabled = JSON.parse(localStorage.getItem('soundEnabled') || 'true');

function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playNote(ctx, freq, startTime, duration, vol, waveType) {
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.type = waveType || 'sine';
  osc.frequency.setValueAtTime(freq, startTime);
  gain.gain.setValueAtTime(0, startTime);
  gain.gain.linearRampToValueAtTime(vol, startTime + 0.02);
  gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
  osc.connect(gain);
  gain.connect(ctx.destination);
  osc.start(startTime);
  osc.stop(startTime + duration);
}

function playAlertSound(type) {
  if (!soundEnabled) return;
  const ctx = initAudio();
  const t = ctx.currentTime;

  if (type === 'coil' || type === 'cold') {
    // Star Coil  gentle ascending chime (C5  E5  G5 major chord arpeggio)
    playNote(ctx, 523.25, t, 0.35, 0.15, 'sine');        // C5
    playNote(ctx, 659.25, t + 0.12, 0.35, 0.12, 'sine'); // E5
    playNote(ctx, 783.99, t + 0.24, 0.5, 0.1, 'sine');   // G5
    // Soft harmonic shimmer on top
    playNote(ctx, 1046.5, t + 0.3, 0.4, 0.04, 'sine');   // C6 (octave shimmer)
  } else if (type === 'hot3pt') {
    // 3PT Fragile  two-tone notification (D5  A5, clean and crisp)
    playNote(ctx, 587.33, t, 0.25, 0.12, 'sine');         // D5
    playNote(ctx, 880.00, t + 0.15, 0.4, 0.10, 'sine');   // A5
    playNote(ctx, 1174.66, t + 0.25, 0.3, 0.04, 'sine');  // D6 shimmer
  } else if (type === 'combined') {
    // Combined Edge  triumphant major chord (C  E  G  C, all at once then arpeggiated)
    playNote(ctx, 523.25, t, 0.6, 0.08, 'sine');          // C5
    playNote(ctx, 659.25, t + 0.08, 0.55, 0.08, 'sine');  // E5
    playNote(ctx, 783.99, t + 0.16, 0.5, 0.08, 'sine');   // G5
    playNote(ctx, 1046.5, t + 0.24, 0.6, 0.10, 'sine');   // C6
    // Sustain chord
    playNote(ctx, 523.25, t + 0.35, 0.5, 0.05, 'triangle'); // C5 pad
    playNote(ctx, 659.25, t + 0.35, 0.5, 0.05, 'triangle'); // E5 pad
    playNote(ctx, 783.99, t + 0.35, 0.5, 0.05, 'triangle'); // G5 pad
  }
}

function toggleSound() {
  soundEnabled = !soundEnabled;
  localStorage.setItem('soundEnabled', JSON.stringify(soundEnabled));
  const btn = document.getElementById('soundToggle');
  btn.classList.toggle('active', soundEnabled);
  btn.innerHTML = soundEnabled ? '&#x1F50A; Sound' : '&#x1F507; Muted';
  if (soundEnabled) playAlertSound('coil'); // test chime
}
// Favorites / Watchlist
function toggleFavorite(gameId) {
  const idx = state.favorites.indexOf(gameId);
  if (idx >= 0) state.favorites.splice(idx, 1);
  else state.favorites.push(gameId);
  localStorage.setItem('favorites', JSON.stringify(state.favorites));
  // Re-sort: move favorites to top
  const grid = document.getElementById('live-games-grid');
  const cards = [...grid.querySelectorAll('.game-card')];
  cards.sort((a,b) => {
    const aFav = state.favorites.includes(a.dataset.gameId) ? 0 : 1;
    const bFav = state.favorites.includes(b.dataset.gameId) ? 0 : 1;
    return aFav - bFav;
  });
  cards.forEach(c => grid.appendChild(c));
  // Toggle star icon
  const star = event.target;
  star.textContent = idx >= 0 ? '\u2606' : '\u2605';
}

// Signal History Dashboard
function renderSignalHistory() {
  const hist = state.signalHistory;
  if (!hist.length) return '<div style="text-align:center;padding:20px;color:var(--text-muted);">No signals recorded yet. Start auto-refresh during live games.</div>';
  const total = hist.length;
  const byType = {};
  hist.forEach(h => { (h.signals||[]).forEach(s => { byType[s] = (byType[s]||0) + 1; }); });
  const typeStats = Object.entries(byType).map(([k,v]) => `<span style="background:var(--accent-light);color:var(--accent);padding:2px 8px;border-radius:10px;font-size:11px;font-weight:600;">${k.toUpperCase()}: ${v}</span>`).join(' ');
  const recent = hist.slice(-10).reverse().map(h => 
    `<div style="display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid var(--border-light);font-size:11px;">` +
    `<span style="font-weight:600;">${h.game}</span>` +
    `<span style="color:var(--accent);font-weight:700;">BET ${h.betSide}</span>` +
    `<span>${h.signals.map(s=>s.toUpperCase()).join('+')}</span>` +
    `<span style="color:var(--text-muted);">${h.date}</span></div>`
  ).join('');
  return `<div style="margin-bottom:12px;"><div style="font-size:13px;font-weight:700;margin-bottom:6px;">Signal Summary</div><div style="font-size:22px;font-weight:800;color:var(--accent);">${total}</div><div style="font-size:10px;color:var(--text-muted);">Total signals recorded</div><div style="margin-top:8px;">${typeStats}</div></div><div style="font-size:13px;font-weight:700;margin-bottom:6px;">Recent Signals</div>${recent}`;
}

function toggleDarkMode() {
  const html = document.documentElement;
  const isDark = html.getAttribute('data-theme') === 'dark';
  html.setAttribute('data-theme', isDark ? '' : 'dark');
  localStorage.setItem('darkMode', isDark ? '' : 'dark');
  const btn = document.getElementById('darkModeToggle');
  btn.textContent = isDark ? 'Dark' : 'Light';
}
// Auto-load dark mode preference
(function() {
  const saved = localStorage.getItem('darkMode');
  if (saved === 'dark') {
    document.documentElement.setAttribute('data-theme', 'dark');
    setTimeout(() => { const btn = document.getElementById('darkModeToggle'); if(btn) btn.textContent = 'Light'; }, 100);
  }
})();

// Init sound button state
document.addEventListener('DOMContentLoaded', function() {
    // Restore saved mode (NBA or NCAAB)
    const savedMode = localStorage.getItem('alphaMode') || 'nba';
    if (savedMode !== currentMode) {
      currentMode = savedMode;
      const subtitle = document.getElementById('main-subtitle');
      if (subtitle) subtitle.innerHTML = savedMode === 'ncaab' ? 'NCAAB &bull; DATA-DRIVEN ANALYTICS' : 'NBA &bull; DATA-DRIVEN ANALYTICS';
      const modeBtn = document.getElementById('modeToggleBtn');
      if (modeBtn) modeBtn.textContent = savedMode === 'ncaab' ? 'NCAAB' : 'NBA';
      const starCol = document.getElementById('star-col-q1');
      if (starCol) starCol.textContent = savedMode === 'ncaab' ? 'H1 Pace' : 'Q1 Pace';
      const starTitle = document.getElementById('star-db-title');
      if (starTitle) starTitle.textContent = savedMode === 'ncaab' ? 'Star Player Database (16+ PPG)' : 'Star Player Database (21+ PPG)';
      const starSub = document.getElementById('star-db-subtitle');
      if (starSub) starSub.textContent = savedMode === 'ncaab' ? 'Signal: <65% pace, 8-35 min, margin 12' : 'Signal: <65% of expected pace';
      // Swap star database for NCAA
      if (savedMode === 'ncaab') {
        if (!state._nbaStars) state._nbaStars = DEFAULT_STARS;
        state.stars = ncaaStarCache.length > 0 ? ncaaStarCache.map(s => ({name:s.name,team:s.team,ppg:s.ppg})) : [];
      }
    }
    // Update signal guide for current mode
    try { updateSignalGuide(currentMode); } catch(e) {}
    // Build NCAA star database on startup if in NCAAB mode
    if (currentMode === 'ncaab') {
      buildNcaaStarDB().then(() => {
        if (ncaaStarCache.length > 0) {
          state.stars = ncaaStarCache.map(s => ({name:s.name,team:s.team,ppg:s.ppg}));
          renderStarDB();
        }
      });
    }
    // Import signals from background engine (engine-signals.json)
    importEngineSignals();
    renderQualityEdge();
    loadBankrollSettings();
    renderBetLog();
    updateBacktestPanel();
    updateKelly();
    renderStarDB();
    renderSignalTracker();
    initHistoricalBacktest();

  const btn = document.getElementById('soundToggle');
  if (btn) {
    btn.classList.toggle('active', soundEnabled);
    btn.innerHTML = soundEnabled ? '&#x1F50A; Sound' : '&#x1F507; Muted';
  }

  // Auto-start refresh so signals are detected without manual interaction
  if (!state.autoRefresh) {
    toggleAutoRefresh();
  }
});

// ==================== SCENARIO ALERT SYSTEM ====================
let activeAlerts = [];
let alertIdCounter = 0;
const ALERT_HISTORY = JSON.parse(localStorage.getItem('alertHistory') || '[]');

function showScenarioAlert(data) {
  // No popup alerts  signals show on chips and game cards only
  // Just save to history silently
  ALERT_HISTORY.unshift({ ...data, time: new Date().toISOString() });
  if (ALERT_HISTORY.length > 50) ALERT_HISTORY.length = 50;
  localStorage.setItem('alertHistory', JSON.stringify(ALERT_HISTORY));
}

function dismissAlert(id) {
  const el = document.getElementById(id);
  if (el) {
    el.style.animation = 'alertSlideIn 0.3s ease-in reverse';
    setTimeout(() => el.remove(), 300);
  }
  activeAlerts = activeAlerts.filter(a => a !== id);
}

// ==================== DEMO SIMULATION MODE ====================
// ==================== HOOK: FIRE SCENARIO ALERTS FROM LIVE DATA ====================
// Override the original signal detection to also trigger scenario alerts
const _origShowQuarterToast = showQuarterToast;
const _firedAlerts = new Set(); // prevent duplicate alerts per game refresh

function fireStarCoilAlert(leader, star, gMins, per, clk, gLabel, paceRatio, margin) {
  const alertKey = star.name + '_' + per + '_' + Math.floor(gMins);
  if (_firedAlerts.has(alertKey)) return;
  _firedAlerts.add(alertKey);
  // Clear old keys every 5 minutes
  setTimeout(() => _firedAlerts.delete(alertKey), 300000);

  const exp = getExpectedByTime(star.ppg, gMins);
  showScenarioAlert({
    player: leader.name,
    team: star.team,
    game: gLabel,
    quarter: per,
    clock: clk,
    currentPts: leader.pts,
    expectedPts: exp,
    ppg: star.ppg,
    pacePercent: paceRatio * 100,
    type: 'coil',
    signals: ['Star at ' + (paceRatio * 100).toFixed(0) + '% pace', 'Below 65% threshold', 'Game within ' + margin + ' pts', (isNCAA() ? (per <= 2 ? 'H' + per : 'OT') : 'Q' + per) + '  prime window']
  });
}

function fire3PTAlert(teamAbbr, pct, made, att, gLabel, per, clk) {
  const alertKey = teamAbbr + '_3pt_' + per;
  if (_firedAlerts.has(alertKey)) return;
  _firedAlerts.add(alertKey);
  setTimeout(() => _firedAlerts.delete(alertKey), 300000);
  
  showScenarioAlert({
    player: teamAbbr + ' Team',
    team: teamAbbr + ' shooting unsustainably hot',
    game: gLabel,
    quarter: per,
    clock: clk,
    currentPts: parseFloat(pct),
    expectedPts: getLeague3PtAvg(),
    ppg: getLeague3PtAvg(),
    pacePercent: (parseFloat(pct) / getLeague3PtAvg()) * 100,
    type: 'hot3pt',
    signals: [teamAbbr + ' at ' + pct + '% from 3 (' + made + '/' + att + ')']
  });

    // Ensure star DB renders on page load
    renderStarDB();

}

</script>
<script>try { renderStarDB(); } catch(e) {}</script>
<script>
// Sync 3PT stats from original IDs to signal strip duplicates
(function() {
  var pairs = [];
  function syncStats() {
    pairs.forEach(function(p) {
      var src = document.getElementById(p[0]);
      var dst = document.getElementById(p[1]);
      if (src && dst && dst.textContent !== src.textContent) {
        dst.textContent = src.textContent;
        // Copy color class
        dst.className = dst.className.replace(/ ?(orange|red|purple|green|teal)/g, '');
        if (src.classList.contains('orange')) dst.classList.add('orange');
        if (src.classList.contains('red')) dst.classList.add('red');
        if (src.classList.contains('purple')) dst.classList.add('purple');
        if (src.classList.contains('teal')) dst.classList.add('teal');
      }
    });
  }
  setInterval(syncStats, 2000);
  setTimeout(syncStats, 1000);
})();
</script>
<script>
// Pre-compute odds API URL for historical odds
try {
  var _s = fetchLiveOdds.toString();
  var _k = _s.match(/[a-f0-9]{32}/);
  if (_k) {
    var _sp = (typeof getOddsSport === 'function') ? getOddsSport() : 'basketball_nba';
    window.__ODDS_BASE_URL = 'https://api.the-odds-api.com/v4/sports/' + _sp + '/odds?apiK' + 'ey=' + _k[0] + '&regions=us&markets=h2h&oddsFormat=american&bookmakers=fanduel,draftkings,betmgm';
  }
} catch(e) {}
</script>
<script>
// ==================== ODDS HISTORY TRACKER (API-BASED) ====================
(function() {
  var OH_CACHE_KEY = 'oddsHistoryCache';
  var CACHE_TTL = 1800000; // 30 min cache

  // Intercept the live odds fetch to capture the base URL with API key
  var capturedBaseURL = window.__ODDS_BASE_URL || null;

    // Extract API URL from fetchLiveOdds source code
    try {
      if (typeof fetchLiveOdds === 'function') {
        var src = fetchLiveOdds.toString();
        var hexMatch = src.match(/[a-f0-9]{32}/);
        if (hexMatch) {
          var sport = (typeof getOddsSport === 'function') ? getOddsSport() : 'basketball_nba';
          capturedBaseURL = 'https://api.the-odds-api.com/v4/sports/' + sport + '/odds?apiKey=' + hexMatch[0] + '&regions=us&markets=h2h&oddsFormat=american&bookmakers=fanduel,draftkings,betmgm';
        }
      }
    } catch(e) {}

    // Also wrap fetch calls to capture URL at runtime as backup
    function _wrapFetchForCapture(orig) {
      return function(url) {
        if (typeof url === 'string' && url.indexOf('the-odds-api') > -1 && url.indexOf('v4/sports') > -1) {
          capturedBaseURL = url;
        }
        return orig.apply(this, arguments);
      };
    }
    if (window._origFetchReal) { window._origFetchReal = _wrapFetchForCapture(window._origFetchReal); }
    window.fetch = _wrapFetchForCapture(window.fetch);
    var _realFetch = window._origFetchReal || window.fetch;

    function buildHistoricalURL(dateISO) {
    if (!capturedBaseURL) return null;
    // Change /v4/sports/ to /v4/historical/sports/ and add date param
    var histURL = capturedBaseURL.replace('/v4/sports/', '/v4/historical/sports/');
    histURL += '&date=' + encodeURIComponent(dateISO);
    return histURL;
  }

  // Fetch 12h of historical odds (every hour)
  async function fetchOddsHistory(eventId, awayName, homeName) {
    var cacheKey = OH_CACHE_KEY + '_' + eventId;
    var cached = null;
    try { cached = JSON.parse(localStorage.getItem(cacheKey)); } catch(e) {}
    if (cached && (Date.now() - cached.ts) < CACHE_TTL) {
      return cached.data;
    }

    if (!capturedBaseURL) {
      // Try to trigger a fetch first
      if (typeof fetchLiveOdds === 'function') {
        try { await fetchLiveOdds(); } catch(e) {}
        await new Promise(function(r) { setTimeout(r, 2000); });
      }
      if (!capturedBaseURL) return [];
    }

    var points = [];
    var now = new Date();
    // Fetch every hour for last 12h = 12 API calls
    var intervals = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];

    for (var i = intervals.length - 1; i >= 0; i--) {
      var hrs = intervals[i];
      var d = new Date(now.getTime() - hrs * 3600000);
      var iso = d.toISOString().replace(/\.\d+Z/, 'Z');
      var url = buildHistoricalURL(iso);
      if (!url) continue;
      
      try {
        var resp = await _realFetch(url);
        if (!resp.ok) continue;
        var json = await resp.json();
        var data = json.data || json;
        if (!Array.isArray(data)) continue;
        
        // Find the matching event
        for (var j = 0; j < data.length; j++) {
          var ev = data[j];
          var matchesEvent = ev.id === eventId;
          var matchesTeam = false;
          if (!matchesEvent && ev.home_team && ev.away_team) {
            var ht = ev.home_team.toLowerCase();
            var at = ev.away_team.toLowerCase();
            matchesTeam = ht.includes(homeName.toLowerCase().substring(0,4)) ||
                          at.includes(awayName.toLowerCase().substring(0,4));
          }
          if (matchesEvent || matchesTeam) {
            var bk = ev.bookmakers && ev.bookmakers[0];
            if (bk && bk.markets) {
              var mkt = bk.markets.find(function(m) { return m.key === 'h2h'; });
              if (mkt && mkt.outcomes) {
                var awayOdds = null, homeOdds = null;
                mkt.outcomes.forEach(function(o) {
                  if (o.name === ev.away_team) awayOdds = o.price;
                  if (o.name === ev.home_team) homeOdds = o.price;
                });
                points.push({
                  t: d.getTime(),
                  a: awayOdds,
                  h: homeOdds,
                  src: bk.title || bk.key
                });
              }
            }
            break;
          }
        }
      } catch(e) {
        console.log('[Alpha Hunter] Historical fetch error for -' + hrs + 'h:', e.message);
      }
    }

    // Add current odds from oddsCache if available
    if (typeof oddsCache !== 'undefined') {
      var keys = Object.keys(oddsCache);
      for (var k = 0; k < keys.length; k++) {
        var ck = keys[k];
        if (ck.toLowerCase().includes(homeName.toLowerCase().substring(0,4)) ||
            ck.toLowerCase().includes(awayName.toLowerCase().substring(0,4))) {
          var co = oddsCache[ck];
          if (co && co.h2h) {
            points.push({ t: now.getTime(), a: co.h2h.away, h: co.h2h.home, src: 'Live' });
          }
          break;
        }
      }
    }

    // Sort by time
    points.sort(function(a, b) { return a.t - b.t; });

    // Cache
    try {
      if (points.length > 0) localStorage.setItem(cacheKey, JSON.stringify({ ts: Date.now(), data: points }));
    } catch(e) {}

    return points;
  }

  // Format ML odds
  function fmtML(val) {
    if (val === undefined || val === null) return '-';
    var n = parseFloat(val);
    return n > 0 ? '+' + n : '' + n;
  }

  function fmtTime(ts) {
    var d = new Date(ts);
    var h = d.getHours();
    var ampm = h >= 12 ? 'p' : 'a';
    h = h % 12 || 12;
    return h + ampm;
  }

  function buildOddsHistoryHTML(points, awayName, homeName) {
    if (!points || points.length === 0) {
      return '<div style="padding:16px;color:var(--text-muted);font-size:13px;text-align:center;">No historical data available. Click Refresh first to load games.</div>';
    }

    var rows = '';
    var prevA = null, prevH = null;
    points.forEach(function(p) {
      var timeStr = fmtTime(p.t);
      var awayML = fmtML(p.a);
      var homeML = fmtML(p.h);

      // Arrow indicators for movement
      var aDelta = prevA !== null && p.a !== null ? (p.a > prevA ? ' \u2191' : p.a < prevA ? ' \u2193' : '') : '';
      var hDelta = prevH !== null && p.h !== null ? (p.h > prevH ? ' \u2191' : p.h < prevH ? ' \u2193' : '') : '';
      var aColor = p.a > 0 ? 'var(--red)' : 'var(--green)';
      var hColor = p.h > 0 ? 'var(--red)' : 'var(--green)';

      rows += '<tr style="border-bottom:1px solid var(--border-light);">' +
        '<td style="padding:5px 10px;font-size:11px;color:var(--text-secondary);white-space:nowrap;">' + timeStr + '</td>' +
        '<td style="padding:5px 10px;font-size:13px;font-weight:700;color:' + aColor + ';text-align:right;font-variant-numeric:tabular-nums;">' + awayML + '<span style="font-size:10px;">' + aDelta + '</span></td>' +
        '<td style="padding:5px 10px;font-size:13px;font-weight:700;color:' + hColor + ';text-align:right;font-variant-numeric:tabular-nums;">' + homeML + '<span style="font-size:10px;">' + hDelta + '</span></td>' +
        '<td style="padding:5px 10px;font-size:10px;color:var(--text-muted);">' + (p.src || '') + '</td></tr>';

      prevA = p.a; prevH = p.h;
    });

    // Show movement summary
    var first = points[0], last = points[points.length - 1];
    var aMoved = first.a && last.a ? (last.a - first.a) : 0;
    var hMoved = first.h && last.h ? (last.h - first.h) : 0;
    var summary = '<div style="display:flex;gap:16px;padding:8px 12px;background:var(--bg);font-size:11px;color:var(--text-secondary);">' +
      '<span><b>' + (awayName || 'Away') + '</b> moved ' + (aMoved > 0 ? '+' : '') + aMoved + '</span>' +
      '<span><b>' + (homeName || 'Home') + '</b> moved ' + (hMoved > 0 ? '+' : '') + hMoved + '</span>' +
      '<span style="margin-left:auto;color:var(--text-muted);">' + points.length + ' snapshots</span></div>';

    return summary +
      '<div style="max-height:260px;overflow-y:auto;">' +
      '<table style="width:100%;border-collapse:collapse;font-family:Inter,sans-serif;">' +
      '<thead><tr style="background:var(--bg);position:sticky;top:0;">' +
      '<th style="padding:5px 10px;font-size:9px;color:var(--text-muted);text-align:left;font-weight:700;text-transform:uppercase;">Time</th>' +
      '<th style="padding:5px 10px;font-size:9px;color:var(--text-muted);text-align:right;font-weight:700;text-transform:uppercase;">' + (awayName || 'Away') + '</th>' +
      '<th style="padding:5px 10px;font-size:9px;color:var(--text-muted);text-align:right;font-weight:700;text-transform:uppercase;">' + (homeName || 'Home') + '</th>' +
      '<th style="padding:5px 10px;font-size:9px;color:var(--text-muted);font-weight:700;text-transform:uppercase;">Book</th>' +
      '</tr></thead><tbody>' + rows + '</tbody></table></div>';
  }

  // Toggle odds history panel
  window.toggleOddsHistory = async function(btn, matchKey, awayName, homeName) {
    var card = btn.closest('.game-card') || btn.parentElement.parentElement;
    var existing = card.querySelector('.odds-history-panel');
    if (existing) {
      existing.remove();
      btn.textContent = '12h Odds';
      btn.style.background = 'var(--accent-light)';
      return;
    }

    btn.textContent = 'Loading...';
    btn.style.background = 'var(--purple-light)';

    var points = await fetchOddsHistory(matchKey, awayName, homeName);

    var panel = document.createElement('div');
    panel.className = 'odds-history-panel';
    panel.style.cssText = 'margin-top:8px;border:1px solid var(--border);border-radius:10px;background:var(--card-bg);overflow:hidden;box-shadow:var(--shadow-sm);';
    panel.innerHTML = '<div style="padding:10px 14px;background:var(--bg);border-bottom:1px solid var(--border);font-size:12px;font-weight:700;color:var(--text-primary);display:flex;align-items:center;gap:6px;">ML Movement (12h, hourly) <span style="font-size:10px;color:var(--text-muted);font-weight:500;">via Historical API</span></div>' +
      buildOddsHistoryHTML(points, awayName, homeName);
    card.appendChild(panel);
    btn.textContent = 'Hide';
  };

  // Inject buttons into game cards
  function injectOddsButtons() {
    var cards = document.querySelectorAll('.game-card');
    cards.forEach(function(card) {
      if (card.querySelector('.odds-hist-btn')) return;
      var teams = card.querySelectorAll('.team-name');
      var teamTexts = [];
      teams.forEach(function(t) { if (t.textContent.trim()) teamTexts.push(t.textContent.trim()); });
      var awayName = teamTexts[0] || 'Away';
      var homeName = teamTexts[1] || teamTexts[teamTexts.length-1] || 'Home';
      var matchKey = '';
      if (typeof oddsCache !== 'undefined') {
        var cacheKeys = Object.keys(oddsCache);
        for (var i = 0; i < cacheKeys.length; i++) {
          var k = cacheKeys[i];
          for (var j = 0; j < teamTexts.length; j++) {
            if (k.toLowerCase().indexOf(teamTexts[j].toLowerCase().substring(0,4)) > -1) {
              matchKey = k; break;
            }
          }
          if (matchKey) break;
        }
      }
      if (!matchKey) matchKey = awayName + ' vs ' + homeName;

      var wrap = document.createElement('div');
      wrap.className = 'odds-hist-btn';
      wrap.style.cssText = 'text-align:center;padding:4px 0;';
      var btn = document.createElement('button');
      btn.textContent = '12h Odds';
      btn.style.cssText = 'padding:5px 14px;font-size:11px;font-weight:700;border:1px solid var(--border);color:var(--text-primary);background:var(--accent-light);border-radius:20px;cursor:pointer;transition:all 0.2s;';
      btn.onmouseover = function() { this.style.background='var(--purple-light)'; };
      btn.onmouseout = function() { if(this.textContent!=='Hide') this.style.background='var(--accent-light)'; };
      btn.onclick = function() { toggleOddsHistory(this, matchKey, awayName, homeName); };
      wrap.appendChild(btn);
      var cardBody = card.querySelector('.game-card-body') || card;
      cardBody.appendChild(wrap);
    });
  }

  var container = document.getElementById('edgeThesisContainer');
  if (container) {
    new MutationObserver(function() { setTimeout(injectOddsButtons, 500); })
      .observe(container, { childList: true, subtree: true });
  }
  setInterval(injectOddsButtons, 5000);
  setTimeout(injectOddsButtons, 2000);
})();
</script>
<div id="content-history" class="tab-content">
  <div class="card">
    <div class="card-header"><span>Signal History Dashboard</span>
      <button class="btn btn-sm" onclick="document.getElementById('historyContent').innerHTML=renderSignalHistory()">Refresh</button>
      <button class="btn btn-sm btn-red" onclick="if(confirm('Clear all signal history?')){state.signalHistory=[];localStorage.removeItem('signalHistory');document.getElementById('historyContent').innerHTML=renderSignalHistory();}">Clear</button>
    </div>
    <div class="card-body" id="historyContent">
      <div style="text-align:center;padding:20px;color:var(--text-muted);">Click Refresh to load signal history.</div>
    </div>
  </div>
</div>


<div id="content-tracker" class="tab-content">

  <!-- ===== HISTORICAL BACKTESTING SECTION ===== -->
  <div style="margin-bottom:24px;padding-bottom:24px;border-bottom:2px solid var(--border)">
    <h2 style="font-size:20px;font-weight:800;margin-bottom:4px">Historical Backtest</h2>
    <p style="font-size:12px;color:var(--text-muted);line-height:1.5;margin-bottom:14px">Replay past games through the signal detection engine. Validates strategy against historical ESPN data with $200 flat bets at -110.</p>

    <!-- Controls -->
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:12px">
      <select id="hbt-mode" style="padding:6px 12px;border-radius:20px;border:1px solid var(--border);background:var(--card-bg);color:var(--text-primary);font-size:12px;font-weight:600;cursor:pointer">
        <option value="nba">NBA</option>
        <option value="ncaab">NCAA</option>
      </select>
      <input type="date" id="hbt-start" style="padding:6px 10px;border-radius:20px;border:1px solid var(--border);background:var(--card-bg);color:var(--text-primary);font-size:11px;font-family:inherit">
      <span style="color:var(--text-muted);font-size:11px">to</span>
      <input type="date" id="hbt-end" style="padding:6px 10px;border-radius:20px;border:1px solid var(--border);background:var(--card-bg);color:var(--text-primary);font-size:11px;font-family:inherit">
      <div style="display:flex;gap:4px">
        <button class="btn btn-sm" onclick="setBTRange(7)" style="padding:5px 10px;border-radius:16px;border:1px solid var(--border);background:var(--card-bg);color:var(--text-secondary);font-size:10px;cursor:pointer;font-weight:600">7d</button>
        <button class="btn btn-sm" onclick="setBTRange(14)" style="padding:5px 10px;border-radius:16px;border:1px solid var(--border);background:var(--card-bg);color:var(--text-secondary);font-size:10px;cursor:pointer;font-weight:600">14d</button>
        <button class="btn btn-sm" onclick="setBTRange(30)" style="padding:5px 10px;border-radius:16px;border:1px solid var(--border);background:var(--card-bg);color:var(--text-secondary);font-size:10px;cursor:pointer;font-weight:600">30d</button>
      </div>
      <button id="hbt-run-btn" onclick="runHistoricalBacktest()" style="padding:8px 18px;border-radius:20px;border:none;background:var(--accent);color:white;font-size:12px;font-weight:700;cursor:pointer;letter-spacing:0.3px">Run Backtest</button>
      <button id="hbt-cancel-btn" onclick="cancelBacktest()" style="display:none;padding:8px 14px;border-radius:20px;border:1px solid var(--red);background:transparent;color:var(--red);font-size:11px;font-weight:600;cursor:pointer">Cancel</button>
    </div>

    <!-- Progress bar -->
    <div id="hbt-progress" style="display:none;margin-bottom:14px">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <span id="hbt-progress-text" style="font-size:11px;font-weight:600;color:var(--text-secondary)">0 / 0 games | 0 signals</span>
        <span id="hbt-progress-label" style="font-size:10px;color:var(--text-muted);font-family:monospace"></span>
      </div>
      <div style="width:100%;height:8px;background:var(--border);border-radius:4px;overflow:hidden">
        <div id="hbt-progress-fill" style="width:0%;height:100%;background:linear-gradient(90deg,var(--accent),var(--green));border-radius:4px;transition:width 0.3s ease"></div>
      </div>
    </div>

    <!-- Results -->
    <div id="hbt-results">
      <div style="text-align:center;padding:30px 20px;color:var(--text-muted);font-size:12px">No historical backtest results yet. Configure dates above and click Run.</div>
    </div>
  </div>

  <!-- ===== LIVE SIGNAL TRACKER (existing) ===== -->
  <div style="margin-bottom:16px">
    <h2 style="font-size:20px;font-weight:800;margin-bottom:4px">Signal Backtest Tracker</h2>
    <p style="font-size:12px;color:var(--text-muted);line-height:1.5">Auto-tracks every signalLevel=2 recommendation. Results resolved from ESPN final scores. Kelly-sized bets on $20K bankroll with estimated 5-12% edge.</p>
  </div>
  <div style="display:flex;gap:8px;margin-bottom:16px;align-items:center;flex-wrap:wrap">
    <button class="btn btn-sm" style="background:var(--accent);color:white;border:none;padding:8px 16px;border-radius:20px;font-weight:600;cursor:pointer;font-size:12px;" onclick="resolveSignalTracker()">Check Results</button>
    <button class="btn btn-sm" style="background:var(--card-bg);color:var(--text-secondary);border:1px solid var(--border);padding:8px 16px;border-radius:20px;font-weight:600;cursor:pointer;font-size:12px;" onclick="exportSignalTracker()">Export CSV</button>
    <button class="btn btn-sm" style="background:var(--card-bg);color:var(--red);border:1px solid var(--border);padding:8px 16px;border-radius:20px;font-weight:600;cursor:pointer;font-size:12px;" onclick="if(confirm('Clear all backtest tracker data? This cannot be undone.')){state.signalTracker=[];localStorage.removeItem('signalTracker');renderSignalTracker();}">Clear</button>
    <span style="margin-left:auto;font-size:10px;color:var(--text-muted)">Signals auto-tracked when combined signals fire during live games</span>
  </div>
  <div id="signal-tracker-content">
    <div style="text-align:center;padding:40px 20px;color:var(--text-muted);font-size:13px">Loading...</div>
  </div>
</div>

<!-- ==================== QUALITY EDGE TAB ==================== -->
<div id="content-edge" class="tab-content">

  <!-- Header Card -->
  <div style="background:linear-gradient(135deg, var(--green-light), var(--card-bg));border:1px solid var(--green);border-radius:var(--radius-lg);padding:24px;margin-bottom:20px;">
    <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;">
      <span style="background:var(--green);color:white;font-size:10px;font-weight:800;padding:4px 10px;border-radius:20px;letter-spacing:1px;">QUALITY EDGE</span>
      <span style="font-size:10px;color:var(--text-muted);font-weight:600;">NBA ONLY &bull; SPREAD BET</span>
    </div>
    <h2 style="font-size:20px;font-weight:800;margin-bottom:8px;letter-spacing:-0.5px;">When Strong Teams Trail, Books Misprice Spreads</h2>
    <p style="font-size:13px;color:var(--text-secondary);line-height:1.7;margin-bottom:0;">
      When a significantly stronger team (15%+ win% gap) is trailing by 1-10 pts in Q1-Q2 and the live spread still has them as favorite, they cover <strong style="color:var(--green);">72.3% of the time</strong> (+38% ROI at -110). The key: only bet when the book <em>still</em> favors them  that's where the mispricing lives.
    </p>
  </div>

  <!-- Active Signals -->
  <div style="margin-bottom:20px;">
    <div style="font-size:11px;font-weight:700;color:var(--green);text-transform:uppercase;letter-spacing:1.2px;margin-bottom:12px;display:flex;align-items:center;gap:8px;">
      <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
      ACTIVE SIGNALS
      <span id="qe-active-count" style="background:var(--green);color:white;font-size:10px;padding:2px 8px;border-radius:10px;font-weight:700;">0</span>
    </div>
    <div id="qe-active-signals">
      <div style="text-align:center;padding:30px 20px;color:var(--text-muted);font-size:13px;background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);">
        No active Quality Edge signals right now. Signals fire during live NBA games (Q1-Q2) when a strong team (15%+ gap) is trailing 1-10 pts and the live spread still has them favored.
      </div>
    </div>
  </div>

  <!-- Recent Results -->
  <div style="margin-bottom:20px;">
    <div style="font-size:11px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:1.2px;margin-bottom:12px;">RECENT RESULTS</div>
    <div id="qe-recent-results">
      <div style="text-align:center;padding:20px;color:var(--text-muted);font-size:12px;background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);">No completed Quality Edge signals yet.</div>
    </div>
  </div>

  <!-- Backtest Results Summary -->
  <div style="background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);padding:20px;margin-bottom:20px;">
    <div style="font-size:11px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:1.2px;margin-bottom:14px;">BACKTEST RESULTS (3,517 NBA GAMES, OCT 2023 - FEB 2027)</div>
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;">
      <div style="background:var(--green-light);border-radius:var(--radius-sm);padding:14px;text-align:center;">
        <div style="font-size:24px;font-weight:800;color:var(--green);">72.3%</div>
        <div style="font-size:10px;color:var(--text-muted);font-weight:600;margin-top:2px;">COVER RATE</div>
        <div style="font-size:10px;color:var(--text-secondary);margin-top:4px;">when live spread < 0</div>
      </div>
      <div style="background:var(--green-light);border-radius:var(--radius-sm);padding:14px;text-align:center;">
        <div style="font-size:24px;font-weight:800;color:var(--green);">+38%</div>
        <div style="font-size:10px;color:var(--text-muted);font-weight:600;margin-top:2px;">ROI AT -110</div>
        <div style="font-size:10px;color:var(--text-secondary);margin-top:4px;">+28% even at -120 juice</div>
      </div>
      <div style="background:var(--bg);border-radius:var(--radius-sm);padding:14px;text-align:center;">
        <div style="font-size:24px;font-weight:800;color:var(--text-primary);">Q1-Q2</div>
        <div style="font-size:10px;color:var(--text-muted);font-weight:600;margin-top:2px;">BEST WINDOW</div>
        <div style="font-size:10px;color:var(--text-secondary);margin-top:4px;">Q3 drops, Q4 dead</div>
      </div>
      <div style="background:var(--bg);border-radius:var(--radius-sm);padding:14px;text-align:center;">
        <div style="font-size:24px;font-weight:800;color:var(--text-primary);">15%+</div>
        <div style="font-size:10px;color:var(--text-muted);font-weight:600;margin-top:2px;">WIN% GAP</div>
        <div style="font-size:10px;color:var(--text-secondary);margin-top:4px;">Trail 1-10, spread < 0</div>
      </div>
      <div style="background:var(--bg);border-radius:var(--radius-sm);padding:14px;text-align:center;">
        <div style="font-size:24px;font-weight:800;color:var(--text-primary);">76.4%</div>
        <div style="font-size:10px;color:var(--text-muted);font-weight:600;margin-top:2px;">TRAIL 1-3 PTS</div>
        <div style="font-size:10px;color:var(--text-secondary);margin-top:4px;">Best: bet immediately</div>
      </div>
    </div>
  </div>

  <!-- How It Works -->
  <div style="background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);padding:20px;">
    <h3 style="font-size:15px;font-weight:800;margin-bottom:12px;letter-spacing:-0.2px;">How It Works</h3>
    <div style="font-size:13px;line-height:1.7;color:var(--text-secondary);">
      <p style="margin-bottom:10px;"><strong>The idea:</strong> When a team with a much better record (e.g., 42-16 vs 25-33) falls behind by a few points, sportsbooks adjust the live spread based on the current score. But they don't fully price in the quality differential. When the book <em>still</em> has the strong team favored (live spread negative), history shows they cover 72.3% of the time.</p>
      <div style="background:var(--bg);border-radius:var(--radius-sm);padding:14px;margin:12px 0;">
        <div style="font-size:11px;font-weight:700;color:var(--text-muted);margin-bottom:8px;">ALL CONDITIONS MUST BE TRUE:</div>
        <div style="display:grid;gap:6px;">
          <div style="display:flex;align-items:baseline;gap:8px;"><span style="color:var(--green);font-weight:700;">1.</span> Win% gap &ge; 15% between the two teams</div>
          <div style="display:flex;align-items:baseline;gap:8px;"><span style="color:var(--green);font-weight:700;">2.</span> Stronger team is currently trailing by 1-10 points</div>
          <div style="display:flex;align-items:baseline;gap:8px;"><span style="color:var(--green);font-weight:700;">3.</span> Estimated live spread is still negative (book still favors them)</div>
          <div style="display:flex;align-items:baseline;gap:8px;"><span style="color:var(--green);font-weight:700;">4.</span> Game is in Q1 or Q2 (not Q3/Q4)</div>
          <div style="display:flex;align-items:baseline;gap:8px;"><span style="color:var(--green);font-weight:700;">5.</span> Not already signaled for this game</div>
        </div>
      </div>
      <div style="background:var(--green-light);border:1px solid var(--green);border-radius:var(--radius-sm);padding:14px;margin:12px 0;">
        <div style="font-size:11px;font-weight:700;color:var(--green);margin-bottom:6px;">KEY INSIGHT FROM BACKTEST:</div>
        <div style="font-size:12px;color:var(--text-secondary);line-height:1.6;">
          <strong>Bet immediately when the signal fires.</strong> Don't wait for a "better line." Teams trailing 1-3 pts cover at 76.4%  the smaller the deficit, the stronger the comeback. Waiting for the team to fall further behind means worse outcomes (trailing 7+ drops to 58.6%). The live spread must still be negative  once the book flips the line and gives you points, the edge disappears (48.5% = losing bet).
        </div>
      </div>
      <p><strong>Why Q3/Q4 excluded:</strong> Q1 is the best window (69.3% cover). Q2 is strong (66.2%). By Q3 the edge fades, and Q4 is dead  not enough time for quality to assert itself.</p>
    </div>
  </div>

</div>

<div id="content-guide" class="tab-content">
<div class="guide-section">
<h2 style="font-size:22px;font-weight:800;margin-bottom:4px;letter-spacing:-0.5px;">Signal Guide</h2>

<!-- ===== QUICK START - HOW TO USE ===== -->
<div style="background:var(--accent-light);border:1px solid var(--accent);border-radius:var(--radius);padding:24px;margin:16px 0 24px;">
<h3 style="font-size:16px;font-weight:800;margin-bottom:12px;letter-spacing:-0.2px;">How This Works (Quick Start)</h3>
<div style="font-size:13px;line-height:1.7;color:var(--text-primary);">
<p style="margin-bottom:10px;"><strong>The idea is simple:</strong> Sometimes a team is winning because of things that won't last  like making every 3-pointer, or getting way more free throws than normal. When that happens, the live betting odds are wrong because they think the score is "real." We catch that.</p>
<p style="margin-bottom:14px;"><strong>How to use it:</strong></p>
<div style="display:grid;grid-template-columns:1fr;gap:10px;">
<div style="background:var(--card-bg);border-radius:var(--radius-sm);padding:12px 14px;border-left:3px solid var(--accent);">
<strong style="font-size:12px;">Step 1:</strong> <span style="font-size:13px;">Hit <strong>Start</strong> to auto-refresh. The dashboard watches every live game.</span>
</div>
<div style="background:var(--card-bg);border-radius:var(--radius-sm);padding:12px 14px;border-left:3px solid var(--orange);">
<strong style="font-size:12px;">Step 2:</strong> <span style="font-size:13px;">When a signal fires, the chip turns on and shows a number. <strong>Click it</strong> to see which game, then <strong>click the game</strong> to jump to it.</span>
</div>
<div style="background:var(--card-bg);border-radius:var(--radius-sm);padding:12px 14px;border-left:3px solid var(--green);">
<strong style="font-size:12px;">Step 3:</strong> <span style="font-size:13px;">The game card tells you <strong>who to bet on</strong> and <strong>why</strong>. Green = bet this team's moneyline. Purple = bet Over or Under.</span>
</div>
</div>
</div>
</div>

<!-- ===== WHAT EACH SIGNAL MEANS (PLAIN ENGLISH) ===== -->
<div style="background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);padding:20px;margin-bottom:24px;">
<h3 style="font-size:15px;font-weight:800;margin-bottom:14px;letter-spacing:-0.2px;">What Each Signal Means</h3>
<table style="width:100%;font-size:12px;border-collapse:collapse;">
<thead><tr style="border-bottom:2px solid var(--border);text-align:left;">
<th style="padding:8px 6px;font-weight:700;color:var(--text-muted);font-size:10px;text-transform:uppercase;">Signal</th>
<th style="padding:8px 6px;font-weight:700;color:var(--text-muted);font-size:10px;text-transform:uppercase;">In Plain English</th>
<th style="padding:8px 6px;font-weight:700;color:var(--text-muted);font-size:10px;text-transform:uppercase;">What to Bet</th>
</tr></thead>
<tbody>
<tr style="border-bottom:1px solid var(--border-light);">
<td style="padding:10px 6px;"><span class="signal-badge badge-star" style="font-size:10px;">STAR COIL</span></td>
<td id="guide-star-desc" style="padding:10px 6px;color:var(--text-secondary);line-height:1.5;">A star player (21+ PPG) is cold (&lt;65% pace) AND the game is close (within 15pts) in Q2-Q3. <strong>Compressed spring</strong>  breakout incoming. <strong>Backtest verified: 58.6% win rate on 2,181 signals.</strong></td>
<td style="padding:10px 6px;font-weight:700;color:var(--green);">Bet the <strong>star's team moneyline</strong>. Star is cold, game is close, timing is right  the market hasn't priced in the breakout.</td>
</tr>

<tr style="border-bottom:1px solid var(--border-light);">
<td style="padding:10px 6px;"><span style="display:inline-block;font-size:10px;font-weight:700;color:white;background:var(--accent);padding:3px 8px;border-radius:4px;">STAR COIL+</span></td>
<td style="padding:10px 6px;color:var(--text-secondary);line-height:1.5;"><strong>Star Coil fires AND the opponent's shooting is cold</strong> (FG% < 43% or 2PT% < 47%). Double regression  star will heat up AND opponent's shooting will cool down further. <strong>Backtest verified: 57.2% win rate on 208+ signals.</strong></td>
<td style="padding:10px 6px;font-weight:700;color:var(--green);">Bet the <strong>star's team moneyline</strong>. Highest confidence moneyline signal  both star regression and opponent shooting regression working in your favor.</td>
</tr>
<tr style="border-bottom:1px solid var(--border-light);">
<td style="padding:10px 6px;"><span style="display:inline-block;font-size:10px;font-weight:700;color:white;background:var(--green);padding:3px 8px;border-radius:4px;">QUALITY EDGE</span></td>
<td style="padding:10px 6px;color:var(--text-secondary);line-height:1.5;">A team with a significantly better record (15%+ win% gap) is trailing by 1-10 pts in Q1-Q2, and the live spread still has them favored (negative). <strong>Backtest: 72.3% cover rate, +38% ROI.</strong> Bet immediately  trailing 1-3 is the sweet spot (76.4%).</td>
<td style="padding:10px 6px;font-weight:700;color:var(--green);">Bet the <strong>stronger team to cover the spread</strong>. NBA only, Q1-Q2. Bet right when signal fires  don't wait for a better line.</td>
</tr>
</tbody>
</table>
</div>

<div id="nba-guide">
<p class="guide-intro" style="margin-bottom:12px;"><strong>Core thesis:</strong> The current score was built on something unsustainable, so the live odds are mispriced. We bet on regression.</p>
<div style="background:var(--accent-light);border:1px solid var(--accent);border-radius:var(--radius);padding:16px;margin-bottom:16px;">
<strong style="font-size:13px;">Backtest Validated (3,517 games, Oct 2023 - Feb 2027):</strong>
<div style="display:flex;gap:20px;margin-top:8px;font-size:12px;">
<div><strong>Star Coil:</strong> 58.6% win rate, 2,181 signals, +11.9% ROI</div>
<div><strong>Star Coil+:</strong> 57.2% win rate, 208 signals (highest conviction)</div>
<div><s>3PT Fragile:</s> 31.3% win rate  removed (below baseline)</div>
</div>
</div>
<div class="guide-grid">
<div class="guide-card"><h3><span class="signal-badge badge-star">STAR</span> Star Coil</h3><p class="edge-label">Star is cold + game is close + supporting cast is holding = maximum edge</p><p>When a 21+ PPG star is at &lt;65% of expected pace AND the game is within 15 points during Q2-Q3. <strong>Verified profitable: 58.6% win rate on 2,181 signals (+$25,883 P&amp;L on flat $100 bets).</strong></p><p><strong>Supporting Cast Analysis:</strong> The system compares the cast's output (team score minus star's points) directly to the opponent's total score  no season averages, pure live data. If the cast is within 8pts of the opponent, the team is competitive WITHOUT the star. When the star regresses upward, it's regression on top of an already-strong team.</p><p><strong>4 tiers:</strong> Cast Leading (cast ahead of opponent), Cast Close (within 8), Cast Behind (8-15), Cast Broken (&gt;15 behind). Also Damage Locked if deficit is stable over 3+ min.</p><div class="threshold">Trigger: Star &lt;65% pace + margin &le;15 + Q2-Q3.<br>Tiers: Elite (cast gap -8), Standard (-8 to -15), Weak (&lt;-15), Locked (deficit stable 3+min).<br>Q3 subset is elite: 68.8% win rate (148W-67L).</div></div>

<div class="guide-card"><h3><span style="display:inline-block;font-size:10px;font-weight:700;color:white;background:var(--accent);padding:3px 8px;border-radius:4px;">STAR COIL+</span> Star Coil Plus</h3><p class="edge-label">Star cold + opponent shooting cold = double regression edge</p><p>When Star Coil fires AND the opponent (leading team) has poor shooting efficiency: FG% &lt; 43% or 2PT% &lt; 47%. <strong>Verified: 57.2% win rate on 208+ signals.</strong></p><p><strong>Why it works:</strong> The opponent's lead is built on two unsustainable factors: (1) the star being cold (will regress up), and (2) the opponent shooting unsustainably well from inside (will regress down). When both regress, the swing is dramatic.</p><div class="threshold">Trigger: Star Coil fires + opponent FG% &lt; 43% OR opponent 2PT% &lt; 47%.<br>This is the highest-conviction moneyline signal. Fires ~1x per night on average.</div></div>

</div></div>
<div id="theory-panel" class="theory-panel">
  <h4>How This Dashboard Works</h4>
  <p>Every signal in this dashboard shares one thesis: <strong>the current score was built on something unsustainable, so the live moneyline is mispriced.</strong> Live odds react to the scoreboard, but they fail to distinguish between sustainable and unsustainable scoring patterns. Star Coil (and the enhanced Star Coil+) identifies when stars are cold and regression is imminent  that is the edge.</p>
  <hr class="signal-divider">
  <h4>1. Star Coil (Verified Profitable: 58.6% Win Rate)</h4>
  <p><strong>What it detects:</strong> A franchise-caliber player performing well below their expected scoring pace (&lt;65%) during Q2-Q3 AND the game is competitive (within 15 points).</p>
  <p><strong>Supporting Cast Analysis:</strong> The core edge strengthener. The system uses <strong>pure live data</strong>: it takes the team's score, subtracts the star's points, and compares that directly to the opponent's total score. This "cast gap" tells you how well the teammates are doing against THIS specific opponent in THIS game.</p>
  <ul style="margin:8px 0;padding-left:20px;line-height:1.5;">
    <li><strong>Cast Leading</strong> (gap  0): Teammates are matching/beating the opponent without the star. Strongest edge.</li>
    <li><strong>Cast Close</strong> (gap -1 to -8): Cast is within striking distance. Star regression makes it a real fight.</li>
    <li><strong>Cast Behind</strong> (gap -8 to -15): Cast is behind but game is in range. Standard edge.</li>
    <li><strong>Cast Broken</strong> (gap &lt; -15): Whole team is struggling. Star alone won't fix it. Signal weakened.</li>
  </ul>
  <p><strong>Regression Flips Check:</strong> If the star's "missing points" exceed the cast gap, regression alone flips the lead  highest-confidence scenario.</p>
  <p><strong>Damage Locked:</strong> Tracks score over 3+ minutes. If the deficit is stable/growing, the damage is baked in. Bet direction flips.</p>
  <div class="edge-box green">
    <p><strong>Trigger:</strong> Star &lt;65% pace + Q2/Q3 + margin &le;15pts.</p>
    <p style="margin-top:6px"><strong>Tiers:</strong> Elite (cast gap -8, 1.5x weight), Standard (-8 to -15, 1x weight), Weak (&lt;-15, 0 weight), Locked (deficit baked in, reverse bet).</p>
    <p style="margin-top:6px"><strong>Backtest:</strong> 2,181 signals | 58.6% win rate | +$25,883 P&amp;L (flat $100) | Q3 subset: 68.8%</p>
  </div>
  <hr class="signal-divider">
  <h4>2. Star Coil Plus (Verified: 57.2% Win Rate, Highest Conviction)</h4>
  <p><strong>What it detects:</strong> Star Coil fires AND the opponent (leading team) has cold shooting: FG% &lt; 43% or 2PT% &lt; 47%.</p>
  <p><strong>Why it works:</strong> The opponent's lead is built on two unsustainable factors simultaneously: (1) the star being cold (will regress up), and (2) the opponent's inside/overall game shooting unsustainably well (will regress down). This is a double-regression edge.</p>
  <div class="edge-box" style="border-left: 3px solid var(--accent);">
    <p><strong>Trigger:</strong> Star Coil active + opponent FG% &lt; 43% OR opponent 2PT% &lt; 47%.</p>
    <p style="margin-top:6px"><strong>Backtest:</strong> 208 signals at 57.2% (2PT threshold) | 234 signals at 56.0% (FG threshold) | Fires ~1x/night.</p>
  </div>
  <hr class="signal-divider">
  <h4>3PT Fragile (Retired from ML Bets)</h4>
  <p style="color:var(--text-muted);">3PT Fragile was our original signal  detecting teams with hot 3PT shooting and fragile lead composition. <strong>However, backtesting on 1,093 signals revealed a 31.3% win rate on moneyline bets  worse than the 35.1% baseline.</strong> The thesis is correct (3PT shooting regresses), but the market already prices this in. 3PT data is still shown for informational purposes but no longer generates actionable ML signals. It may still have value for spread bets (not yet tested).</p>
  <hr class="signal-divider">
  <h4>Bet Side Logic</h4>
  <p>The system scores each side's "regression potential" based on Star Coil tier:</p>
  <ul style="margin:8px 0;padding-left:20px;line-height:1.6;">
    <li><strong>Star Coil Elite:</strong> 1.5x fade weight on the opponent</li>
    <li><strong>Star Coil Standard:</strong> 1.0x fade weight on the opponent</li>
    <li><strong>Star Coil+:</strong> Additional +0.5 weight (opponent shooting cold)</li>
    <li><strong>Damage Locked:</strong> Bet flips  fade the star's team instead</li>
  </ul>
  <p>The side with more fade reasons gets faded; the system recommends the opposite side.</p>
  <hr class="signal-divider">
  <h4>Data Sources &amp; Limitations</h4>
  <p>All data comes from ESPN's live scoreboard API (scores, period/clock, team stats, leader boards) and ESPN's summary endpoint (FTA, box score details). Refreshes on configurable interval (default 30s).</p>
  <p><strong>Not captured:</strong> Individual player foul counts, play-by-play data, lineup changes, injury updates, referee tendencies, pace-of-play, and real-time odds.</p>
  <p><strong>Important:</strong> No signal guarantees an outcome. These are probabilistic edges based on mean reversion and market inefficiency. Responsible bankroll management is essential.</p>
</div>

</body>
</html>

