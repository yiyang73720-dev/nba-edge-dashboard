<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Alpha Hunter</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 40 40'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' stop-color='%2300d4aa'/%3E%3Cstop offset='100%25' stop-color='%237c3aed'/%3E%3C/linearGradient%3E%3C/defs%3E%3Ccircle cx='20' cy='20' r='14' fill='none' stroke='url(%23g)' stroke-width='2.5'/%3E%3Ccircle cx='20' cy='20' r='3' fill='%2300d4aa'/%3E%3Cline x1='20' y1='2' x2='20' y2='10' stroke='url(%23g)' stroke-width='2' stroke-linecap='round'/%3E%3Cline x1='20' y1='30' x2='20' y2='38' stroke='url(%23g)' stroke-width='2' stroke-linecap='round'/%3E%3Cline x1='2' y1='20' x2='10' y2='20' stroke='url(%23g)' stroke-width='2' stroke-linecap='round'/%3E%3Cline x1='30' y1='20' x2='38' y2='20' stroke='url(%23g)' stroke-width='2' stroke-linecap='round'/%3E%3C/svg%3E">
<style>

    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap');
    :root {
      --white: #ffffff; --bg: #f7f8fa; --card-bg: #ffffff; --border: #e8e8e8; --border-light: #f3f4f6;
      --text-primary: #1a1a2e; --text-secondary: #4b5563; --text-muted: #9ca3af;
      --accent: #00d4aa; --accent-light: #e6faf5;
      --green: #00d4aa; --green-light: #e6faf5;
      --red: #dc2626; --red-light: #fee2e2;
      --orange: #d97706; --orange-light: #fef3c7;
      --purple: #7c3aed; --purple-light: #ede9fe;
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.04); --shadow-md: 0 2px 8px rgba(0,0,0,0.05); --shadow-lg: 0 4px 16px rgba(0,0,0,0.06);
      --radius: 12px; --radius-sm: 6px; --radius-lg: 16px;
    }
    [data-theme="dark"] {
      --white: #1a1a2e; --bg: #0f0f1a; --card-bg: #1a1a2e; --border: #2d2d44; --border-light: #252540;
      --text-primary: #e2e8f0; --text-secondary: #94a3b8; --text-muted: #64748b;
      --accent: #00d4aa; --accent-light: #0d3d33;
      --green: #00d4aa; --green-light: #0d3d33;
      --red: #ef4444; --red-light: #3b1111;
      --orange: #f59e0b; --orange-light: #3b2e0a;
      --purple: #8b5cf6; --purple-light: #2e1f5e;
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.3); --shadow-md: 0 2px 8px rgba(0,0,0,0.4); --shadow-lg: 0 4px 16px rgba(0,0,0,0.5);
    }
    [data-theme="dark"] .header { background: #1a1a2e; box-shadow: 0 1px 3px rgba(0,0,0,0.4); }
    [data-theme="dark"] .game-card-header { background: #151525; }
    [data-theme="dark"] .tab.active { color: var(--accent); border-bottom-color: var(--accent); }
    [data-theme="dark"] input, [data-theme="dark"] select, [data-theme="dark"] textarea { background: #252540; color: #e2e8f0; border-color: #2d2d44; }
    [data-theme="dark"] .modal { background: #1a1a2e; }
    [data-theme="dark"] .edge-box { background: #151525; border-color: #2d2d44; }
    [data-theme="dark"] .signal-strip { background: #1a1a2e; border-color: #2d2d44; }
    .team-3pt-avg { font-size: 9px; font-weight: 600; color: var(--accent); opacity: 0.8; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; background: var(--bg); color: var(--text-primary); line-height: 1.5; -webkit-font-smoothing: antialiased; }
    .header { background: var(--white); border-bottom: none; padding: 14px 28px; display: flex; justify-content: space-between; align-items: center; position: sticky; top: 0; z-index: 200; box-shadow: 0 1px 3px rgba(0,0,0,0.04), 0 4px 12px rgba(0,0,0,0.02); }
    .header h1, .header .title { font-size: 18px; font-weight: 800; color: var(--accent); letter-spacing: -0.3px; }
    .header .subtitle, .header p, .header small { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
    .logo-wrap { display: flex; align-items: center; gap: 12px; }
    .logo-icon { width: 38px; height: 38px; flex-shrink: 0; filter: drop-shadow(0 0 6px rgba(0,212,170,0.4)); }
    .logo-icon .scope-ring { fill: none; stroke: url(#logoGrad); stroke-width: 2; }
    .logo-icon .scope-cross { stroke: url(#logoGrad); stroke-width: 1.5; stroke-linecap: round; }
    .logo-icon .scope-dot { fill: var(--accent); }
    .logo-icon .scope-pulse { fill: var(--accent); opacity: 0; animation: logoPulse 2.5s ease-in-out infinite; }
    @keyframes logoPulse { 0%,100%{ opacity:0; r:2; } 50%{ opacity:0.5; r:7; } }
    .logo-text { display: flex; flex-direction: column; line-height: 1.1; }
    .logo-text .logo-main { font-size: 20px; font-weight: 900; letter-spacing: 1.5px; background: linear-gradient(135deg, #00d4aa 0%, #00b4d8 50%, #7c3aed 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .logo-text .logo-sub { font-size: 10px; font-weight: 600; letter-spacing: 3px; color: var(--text-muted); text-transform: uppercase; margin-top: 1px; }
    [data-theme="dark"] .logo-icon { filter: drop-shadow(0 0 10px rgba(0,212,170,0.5)); }
    [data-theme="dark"] .logo-text .logo-main { background: linear-gradient(135deg, #00ffc8 0%, #00d4ff 50%, #a78bfa 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .header-right, .header-actions, .header .actions { display: flex; gap: 8px; align-items: center; }
    button, .btn { font-family: 'Inter', sans-serif; font-size: 13px; font-weight: 600; border: none; border-radius: var(--radius-sm); padding: 8px 16px; cursor: pointer; transition: all 0.15s ease; display: inline-flex; align-items: center; gap: 6px; }
    button:hover { transform: translateY(-1px); box-shadow: var(--shadow-md); }
    .btn-primary, button[style*="background: #00d4aa"], button[style*="background:#00d4aa"] { background: var(--green) !important; color: white !important; }
    .btn-danger, button[style*="background: #ef4444"] { background: var(--red) !important; color: white !important; }
    .espn-btn, button[onclick*="espn"] { background: var(--white); color: var(--text-secondary); border: 1px solid var(--border); font-size: 12px; padding: 6px 12px; }
    #soundToggle { background: var(--green) !important; color: white !important; border-radius: 20px !important; padding: 6px 14px !important; font-size: 12px !important; font-weight: 600 !important; }
    #demoToggle { background: var(--accent) !important; color: white !important; border-radius: 20px !important; padding: 6px 14px !important; font-size: 12px !important; font-weight: 600 !important; }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; }
    .status-dot.green, .status-dot.live { background: var(--green); }
    .status-dot.red, .status-dot.off { background: var(--red); }
    .tab-bar { display: flex; background: var(--white); border-bottom: 2px solid var(--border-light); padding: 0 28px; position: sticky; top: 52px; z-index: 100; gap: 0; }
    .tab { padding: 14px 20px; cursor: pointer; font-size: 13px; font-weight: 500; color: var(--text-muted); border-bottom: 2px solid transparent; transition: all 0.15s ease; white-space: nowrap; }
    .tab:hover { color: var(--text-primary); background: var(--bg); }
    .tab.active { color: var(--accent); font-weight: 700; border-bottom: 3px solid var(--accent); margin-bottom: -2px; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .content, .main-content, .tab-content { padding: 24px 28px; max-width: 1400px; margin: 0 auto; }
    h2, .section-title { font-size: 20px; font-weight: 700; color: var(--text-primary); letter-spacing: -0.3px; margin-bottom: 4px; }
    h3, h4 { font-size: 15px; font-weight: 700; color: var(--text-primary); }
    .stats-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 14px; margin-bottom: 24px; }
    .stat-card { background: var(--card-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 18px 16px; text-align: center; box-shadow: var(--shadow-sm); transition: all 0.2s ease; }
    .stat-card:hover { box-shadow: var(--shadow-md); transform: translateY(-2px); }
    .stat-label { font-size: 10px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 6px; }
    .stat-value { font-size: 28px; font-weight: 800; color: var(--text-primary); letter-spacing: -1px; }
    .signal-strip { display: flex; border: 1px solid var(--border); border-radius: var(--radius); overflow: visible; background: var(--card-bg); box-shadow: var(--shadow-sm); margin-bottom: 20px; }
    .signal-chip { flex: 1; padding: 10px 4px; text-align: center; border-right: 1px solid var(--border-light); transition: background 0.15s; cursor: default; position: relative; }
    .signal-chip:last-child { border-right: none; }
    .signal-chip:hover { background: var(--bg); }
    .signal-chip .chip-value { font-size: 18px; font-weight: 800; color: var(--text-primary); letter-spacing: -0.5px; line-height: 1.2; }
    .signal-chip .chip-label { font-size: 9px; font-weight: 800; color: var(--text-primary); text-transform: uppercase; letter-spacing: 0.8px; margin-top: 2px; }
    .signal-chip .chip-value.orange { color: var(--orange); }
    .signal-chip .chip-value.teal { color: #0d9488; }
    .signal-chip .chip-value.red { color: var(--red); }
    .signal-chip .chip-value.purple { color: var(--purple); }
    .signal-chip .chip-value.green { color: var(--green); }
    .signal-chip .chip-label.orange { color: var(--orange); }
    .signal-chip .chip-label.teal { color: #0d9488; }
    .signal-chip .chip-label.red { color: var(--red); }
    .signal-chip .chip-label.purple { color: var(--purple); }
    .signal-chip .chip-label.green { color: var(--green); }
    .signal-chip .chip-desc { display:none; position:absolute; bottom:100%; left:50%; transform:translateX(-50%); background:#1e293b; color:#fff; font-size:10px; padding:4px 8px; border-radius:4px; white-space:nowrap; z-index:100; pointer-events:none; margin-bottom:4px; box-shadow:0 2px 6px rgba(0,0,0,.15); }
    .signal-chip:hover .chip-desc { display:block; }
    .signal-chip-clickable { cursor: pointer; transition: all 0.15s ease; }
    .signal-chip-clickable:hover { background: var(--accent-light); }
    .signal-chip-clickable:active { transform: scale(0.97); }
    .chip-detail-panel { display:none; position:absolute; top:100%; left:50%; transform:translateX(-50%); background:var(--card-bg); border:1px solid var(--border); border-radius:var(--radius-sm); box-shadow:var(--shadow-lg); z-index:150; min-width:280px; max-width:360px; padding:0; margin-top:6px; text-align:left; overflow:hidden; animation:slideUp 0.2s ease; }
    .chip-detail-panel.active { display:block; }
    .chip-detail-panel::before { content:''; position:absolute; top:-6px; left:50%; transform:translateX(-50%); border-left:6px solid transparent; border-right:6px solid transparent; border-bottom:6px solid var(--border); }
    .chip-detail-panel::after { content:''; position:absolute; top:-5px; left:50%; transform:translateX(-50%); border-left:5px solid transparent; border-right:5px solid transparent; border-bottom:5px solid var(--card-bg); }
    .chip-detail-header { padding:8px 12px; background:var(--bg); border-bottom:1px solid var(--border-light); font-size:11px; font-weight:700; color:var(--text-muted); text-transform:uppercase; letter-spacing:0.5px; }
    .chip-detail-item { padding:8px 12px; border-bottom:1px solid var(--border-light); font-size:12px; }
    .chip-detail-item:last-child { border-bottom:none; }
    .chip-detail-clickable { cursor:pointer; transition:background 0.15s ease; }
    .chip-detail-clickable:hover { background:var(--accent-light); }
    .chip-detail-game { font-weight:700; color:var(--text-primary); font-size:12px; }
    .chip-detail-score { font-size:11px; color:var(--text-muted); margin-top:1px; }
    .chip-detail-sig { font-size:11px; color:var(--text-secondary); margin-top:3px; line-height:1.4; }
    .chip-detail-empty { padding:12px; text-align:center; font-size:11px; color:var(--text-muted); }
    @keyframes signalFlash { 0%{box-shadow:0 0 0 0 rgba(0,212,170,0.6);} 30%{box-shadow:0 0 20px 4px rgba(0,212,170,0.4);} 100%{box-shadow:var(--shadow-sm);} }
    .signal-highlight-flash { animation:signalFlash 2.5s ease; border-color:var(--accent) !important; }
    /* Toast CSS removed â€” no popup notifications */
    .section-divider { height: 1px; background: var(--border-light); margin: 16px 0; }
    .edge-thesis-header { display: flex; align-items: center; gap: 10px; margin-bottom: 4px; }
    .edge-thesis-header h2 { font-size: 14px; font-weight: 700; color: var(--text-primary); letter-spacing: 0.5px; text-transform: uppercase; margin: 0; }
    .edge-count-badge { background: var(--accent); color: white; font-size: 12px; font-weight: 700; padding: 2px 10px; border-radius: 12px; min-width: 24px; text-align: center; }
    .auto-refresh-bar { display: flex; align-items: center; gap: 12px; padding: 8px 0; font-size: 12px; color: var(--text-secondary); flex-wrap: wrap; }
    .refresh-pill { padding: 5px 14px; font-size: 11px; font-weight: 700; border-radius: 20px; border: 1px solid var(--accent); color: var(--accent); background: transparent; cursor: pointer; transition: all 0.2s; }
    .refresh-pill:hover { background: var(--accent); color: white; }
    .card:hover { box-shadow: var(--shadow-md); }
    .card { background: var(--card-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 20px; box-shadow: var(--shadow-sm); margin-bottom: 16px; transition: all 0.2s ease; }
    .card:hover { box-shadow: var(--shadow-md); }
    .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; font-weight: 700; font-size: 15px; color: var(--text-primary); }
    .card-body { font-size: 13px; color: var(--text-secondary); line-height: 1.6; }
    .games-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(340px, 1fr)); gap: 12px; }
        .game-card{background:var(--card-bg);border:1px solid var(--border);border-radius:10px;overflow:hidden;transition:box-shadow .2s ease}
        .game-card:hover{box-shadow:var(--shadow-md)}
        .game-card-header{display:flex;justify-content:space-between;align-items:center;padding:6px 12px;background:var(--bg);border-bottom:1px solid var(--border-light);font-size:11px;color:var(--text-muted);font-weight:500;letter-spacing:.3px}
        .game-card-body{padding:10px 12px}
        .game-teams{display:flex;align-items:center;justify-content:space-between;gap:4px}
        .team-block{text-align:center;flex:1;min-width:0}
        .team-block strong,.team-block b{display:block;font-size:15px;font-weight:700;color:var(--text-primary);margin-bottom:1px}
        .team-block small{font-size:11px;color:var(--text-muted)}
        .team-name{font-size:14px;font-weight:700;color:var(--text-primary);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:160px;margin:0 auto}
        .team-score{font-size:24px;font-weight:800;color:var(--text-primary);margin-top:2px}
        .team-record{font-size:11px;color:var(--text-muted)}
        .team-3pt-avg{font-size:10px;color:var(--text-muted)}
        .vs-block{padding:0 6px;color:var(--text-muted);font-size:12px;font-weight:500}
        .sound-toggle{display:none!important}
        .scenario-alert-panel{position:fixed;bottom:0;left:0;right:0;z-index:500;background:var(--white);border-top:1px solid var(--border);box-shadow:0 -4px 20px rgba(0,0,0,.08);padding:12px 24px;max-height:160px;overflow-y:auto}
        .stat-card{transition:all .2s ease}
        .stat-card:hover{box-shadow:var(--shadow-md);border-color:var(--accent)}
        .stat-label{font-size:10px;font-weight:600;letter-spacing:.5px;text-transform:uppercase;color:var(--text-muted);margin-bottom:6px}
        .stat-value{font-size:28px;font-weight:800;letter-spacing:-1px}
        .empty-state{text-align:center;padding:40px 20px;color:var(--text-muted);font-size:14px}
    .form-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 14px; }
    .empty-state { text-align: center; padding: 60px 20px; color: var(--text-muted); font-size: 14px; }
    .signal-badge, .badge { display: inline-block; padding: 3px 10px; border-radius: 20px; font-size: 11px; font-weight: 600; letter-spacing: 0.3px; }
    .signal-badge.hot, .badge.hot, .badge-hot { background: var(--red-light); color: var(--red); }
    .signal-badge.cold, .badge.cold, .badge-cold { background: var(--accent-light); color: var(--accent); }
    .signal-badge.warm, .badge.warm { background: var(--orange-light); color: var(--orange); }
    .panel, .section { background: var(--card-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 20px; margin-bottom: 20px; box-shadow: var(--shadow-sm); }
    .panel-header, .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 14px; padding-bottom: 12px; border-bottom: 1px solid var(--border-light); }
    table { width: 100%; border-collapse: separate; border-spacing: 0; font-size: 13px; }
    thead th { font-size: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 1.2px; color: var(--accent); padding: 12px 14px; border-bottom: 2px solid var(--border); text-align: left; background: var(--bg); }
    tbody td { padding: 12px 14px; border-bottom: 1px solid var(--border-light); color: var(--text-primary); font-weight: 500; }
    tbody tr { transition: background 0.1s ease; }
    tbody tr:hover { background: var(--bg); }
    tbody tr:last-child td { border-bottom: none; }
    .three-pt-card, .tracker-card { background: var(--card-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 16px; box-shadow: var(--shadow-sm); }
    .quarter-box, .qtr-box { display: inline-flex; align-items: center; justify-content: center; min-width: 36px; height: 28px; padding: 2px 8px; border-radius: 6px; font-size: 12px; font-weight: 700; background: var(--bg); color: var(--text-secondary); border: 1px solid var(--border-light); }
    .quarter-box.hot, .qtr-box.hot { background: var(--red-light); color: var(--red); border-color: transparent; }
    .thesis-card, .edge-card { background: var(--card-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 16px; box-shadow: var(--shadow-sm); }
    .criteria-item { display: flex; gap: 10px; padding: 10px 0; border-bottom: 1px solid var(--border-light); }
    .criteria-item:last-child { border-bottom: none; }
    .criteria-item.met { background: transparent; }
    .criteria-item.not-met { opacity: 0.5; }
    .criteria-check { font-size: 16px; flex-shrink: 0; margin-top: 1px; }
    .criteria-text { flex: 1; }
    .criteria-label { font-size: 13px; font-weight: 700; color: var(--text-primary); display: block; margin-bottom: 3px; }
    .criteria-value { font-size: 12px; font-weight: 600; color: var(--accent); display: inline-block; padding: 1px 8px; background: var(--accent-light); border-radius: 4px; margin-bottom: 5px; }
    .criteria-value.warn { color: var(--orange); background: var(--orange-light); }
    .criteria-value.neg { color: var(--text-muted); background: var(--bg); }
    .criteria-detail { font-size: 12px; color: var(--text-secondary); line-height: 1.6; display: block; }
    .criteria-detail strong { color: var(--text-primary); font-weight: 700; }
    .thesis-game-bar { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px; padding-bottom: 10px; border-bottom: 1px solid var(--border-light); }
    .thesis-game-label { font-size: 15px; font-weight: 800; color: var(--text-primary); }
    .thesis-game-period { font-size: 12px; color: var(--text-muted); margin-top: 2px; }
    .thesis-bet-line { display: flex; justify-content: space-between; align-items: center; padding: 12px; background: var(--bg); border-radius: var(--radius-sm); margin-bottom: 12px; }
    .thesis-bet-action { font-size: 16px; font-weight: 800; color: var(--green); }
    .thesis-bet-side { font-size: 12px; color: var(--text-muted); margin-top: 4px; }
    .thesis-logic { margin-bottom: 12px; }
    .thesis-logic-title { font-size: 12px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px; }
    .thesis-logic-text { font-size: 13px; color: var(--text-secondary); line-height: 1.6; }
    .thesis-criteria { margin-bottom: 12px; }
    .thesis-actions { display: flex; justify-content: space-between; align-items: center; padding-top: 10px; border-top: 1px solid var(--border-light); }
    .thesis-confidence { text-align: right; }
    .conf-meter { display: flex; gap: 3px; justify-content: flex-end; margin-bottom: 4px; }
    .conf-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--border); }
    .conf-dot.lit { background: var(--accent); }
    .conf-label { font-size: 11px; font-weight: 600; }
    .conf-label.high { color: var(--green); }
    .conf-label.medium { color: var(--orange); }
    .conf-label.low { color: var(--text-muted); }
    .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.3); backdrop-filter: blur(4px); align-items: center; justify-content: center; z-index: 1000; animation: fadeIn 0.2s ease; }
    .modal-overlay.active { display: flex; }
    .modal { background: var(--white); border-radius: var(--radius-lg); padding: 28px; width: 90%; max-width: 520px; box-shadow: var(--shadow-lg); animation: slideUp 0.25s ease; }
    .modal h2, .modal h3 { font-size: 18px; font-weight: 700; margin-bottom: 20px; color: var(--text-primary); }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes slideUp { from { opacity: 0; transform: translateY(16px); } to { opacity: 1; transform: translateY(0); } }
    input, select, textarea { font-family: 'Inter', sans-serif; font-size: 13px; padding: 10px 14px; border: 1px solid var(--border); border-radius: var(--radius-sm); background: var(--white); color: var(--text-primary); transition: border-color 0.15s ease, box-shadow 0.15s ease; width: 100%; }
    input:focus, select:focus, textarea:focus { outline: none; border-color: var(--accent); box-shadow: 0 0 0 3px var(--accent-light); }
    select { appearance: none; background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%236b7280' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 12px center; padding-right: 32px; }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: var(--bg); }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
    .bankroll-section, .bankroll-settings { background: var(--card-bg); border: 1px solid var(--border); border-radius: var(--radius); padding: 20px; box-shadow: var(--shadow-sm); margin-bottom: 20px; }
    .bankroll-section label, label { font-size: 12px; font-weight: 600; color: var(--text-secondary); display: block; margin-bottom: 6px; }
    .stop-loss, .rules-box, [style*="border-left: 3px solid"] { background: var(--orange-light) !important; border: 1px solid #fde68a !important; border-left: 3px solid var(--orange) !important; border-radius: var(--radius-sm) !important; padding: 12px 16px !important; color: #92400e !important; font-size: 13px !important; }
    .notification-toast, .toast { position: fixed; top: 20px; right: 20px; background: var(--white); border: 1px solid var(--border); border-radius: var(--radius); padding: 14px 20px; box-shadow: var(--shadow-lg); z-index: 2000; font-size: 13px; font-weight: 500; animation: slideIn 0.3s ease; max-width: 360px; }
    @keyframes slideIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
    .auto-refresh-controls, .refresh-controls { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; margin-bottom: 16px; font-size: 13px; color: var(--text-secondary); }
    .auto-refresh-controls select, .refresh-controls select { width: auto; min-width: 80px; }
    .game-score, .score { font-size: 20px; font-weight: 800; color: var(--text-primary); }
    .game-teams, .matchup, .teams { font-weight: 600; color: var(--text-primary); font-size: 14px; }
    .game-status, .status { font-size: 12px; color: var(--text-muted); font-weight: 500; }
    .signal-list, .signals { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    strong, b { font-weight: 700; }
    .remove-btn, button.remove, [onclick*="remove"] { background: var(--red-light) !important; color: var(--red) !important; border: none !important; border-radius: 6px !important; width: 32px !important; height: 32px !important; display: inline-flex !important; align-items: center !important; justify-content: center !important; font-weight: 700 !important; font-size: 14px !important; padding: 0 !important; cursor: pointer; }
    .remove-btn:hover, button.remove:hover, [onclick*="remove"]:hover { background: var(--red) !important; color: white !important; }
  .tooltip-wrap{position:relative;display:inline-block;cursor:help}
.tooltip-wrap .info-dot{display:inline-flex;align-items:center;justify-content:center;width:14px;height:14px;border-radius:50%;background:var(--border);color:var(--text-muted);font-size:9px;font-weight:700;margin-left:4px;vertical-align:middle}
.tooltip-wrap .tip{visibility:hidden;opacity:0;position:absolute;bottom:calc(100% + 8px);left:50%;transform:translateX(-50%);background:#1a1a2e;color:#e0e0e0;padding:8px 12px;border-radius:6px;font-size:11px;line-height:1.4;white-space:normal;width:220px;z-index:100;box-shadow:0 4px 12px rgba(0,0,0,.3);pointer-events:none;transition:opacity .2s,visibility .2s}
.tooltip-wrap:hover .tip{visibility:visible;opacity:1}
.tooltip-wrap .tip::after{content:'';position:absolute;top:100%;left:50%;transform:translateX(-50%);border:6px solid transparent;border-top-color:#1a1a2e}
@keyframes edgeGlow{0%,100%{box-shadow:0 0 8px rgba(0,212,170,0.3),0 0 20px rgba(0,212,170,0.15);}50%{box-shadow:0 0 16px rgba(0,212,170,0.6),0 0 40px rgba(0,212,170,0.3);}}
.signal-chip.combined-active{animation:edgeGlow 2s ease-in-out infinite;background:var(--accent-light);border-radius:8px;}
.guide-section{padding:20px 0}
.guide-intro{color:var(--text-muted);font-size:13px;margin-bottom:16px;line-height:1.5}
.guide-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:16px}
.guide-card{background:var(--card-bg);border:1px solid var(--border);border-radius:10px;padding:16px;transition:all .2s}
.guide-card:hover{border-color:var(--accent);box-shadow:var(--shadow-sm)}
.guide-card h3{font-size:15px;margin-bottom:8px;display:flex;align-items:center;gap:8px}
.guide-card .edge-label{font-size:12px;color:var(--accent);font-weight:600;margin-bottom:6px}
.guide-card p{font-size:12px;color:var(--text-muted);line-height:1.5;margin-bottom:8px}
.guide-card .threshold{font-size:11px;color:var(--text-muted);background:var(--bg);padding:6px 10px;border-radius:6px;border-left:3px solid var(--accent)}
.signal-badge{display:inline-block;padding:2px 8px;border-radius:4px;font-size:10px;font-weight:700;letter-spacing:.5px;color:#fff}
.signal-badge.badge-3pt{background:#3b82f6}
.signal-badge.badge-star{background:#f59e0b}
.signal-badge.badge-fragile{background:#ef4444}
.signal-badge.badge-paint{background:#10b981}
.signal-badge.badge-foul{background:#8b5cf6}
.signal-badge.badge-hustle{background:#f59e0b}
.signal-badge.badge-ft{background:#ec4899}
.signal-badge.badge-combined{background:#00d4aa}
.signal-badge.badge-hot{background:#ef4444}
.signal-badge.badge-warm{background:#f97316}
.signal-badge.badge-qtr{background:#eab308}


    .theory-toggle{background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:10px 16px;margin:16px auto;max-width:1200px;cursor:pointer;display:flex;align-items:center;justify-content:space-between;transition:all .2s}
    .theory-toggle:hover{border-color:var(--orange);background:rgba(255,152,0,.05)}
    .theory-toggle h3{margin:0;font-size:14px;color:var(--text)}.theory-toggle .arrow{transition:transform .3s;font-size:16px;color:var(--muted)}
    .theory-toggle.open .arrow{transform:rotate(180deg)}
    .theory-panel{max-width:1200px;margin:0 auto 20px;background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:0;max-height:0;overflow:hidden;transition:max-height .4s ease,padding .3s ease}
    .theory-panel.open{max-height:8000px;padding:20px 24px}
    .theory-panel h4{color:var(--orange);font-size:15px;margin:18px 0 8px}.theory-panel h4:first-child{margin-top:0}
    .theory-panel p{color:var(--text);font-size:13px;line-height:1.7;margin:0 0 10px}
    .theory-panel .edge-box{background:rgba(255,152,0,.08);border-left:3px solid var(--orange);padding:10px 14px;border-radius:0 6px 6px 0;margin:12px 0}
    .theory-panel .edge-box p{margin:0;font-size:12px}
    .theory-panel .edge-box.green{background:rgba(16,185,129,.08);border-left-color:var(--green)}
    .theory-panel .edge-box.blue{background:rgba(37,99,235,.08);border-left-color:var(--accent)}
    .theory-panel .edge-box.red{background:rgba(239,68,68,.08);border-left-color:var(--red)}
    .theory-panel .edge-box.purple{background:rgba(139,92,246,.08);border-left-color:var(--purple)}
    .theory-panel .thresh-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin:12px 0}
    .theory-panel .thresh-card{background:rgba(255,255,255,.03);border:1px solid var(--border);border-radius:6px;padding:10px 14px}
    .theory-panel .thresh-card h5{margin:0 0 6px;font-size:13px;color:var(--green)}
    .theory-panel .thresh-card p{font-size:12px;margin:2px 0}
    .theory-panel .tag{display:inline-block;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:600;margin:2px 4px 2px 0}
    .theory-panel .tag.l2{background:rgba(244,67,54,.15);color:#f44336}.theory-panel .tag.l1{background:rgba(255,152,0,.15);color:var(--orange)}
    .theory-panel .tag.diff{background:rgba(156,39,176,.15);color:#ce93d8}
    .theory-panel .signal-divider{border:none;border-top:1px solid var(--border);margin:24px 0}
    @media(max-width:600px){.theory-panel .thresh-grid{grid-template-columns:1fr}}
.odds-row{display:flex;justify-content:space-between;align-items:center;padding:4px 8px;margin:4px 0;background:linear-gradient(135deg,#1a1a2e,#16213e);border-radius:6px;font-size:11px;color:#e0e0e0;}.odds-row .odds-label{color:#8892b0;font-weight:600;font-size:10px;text-transform:uppercase;letter-spacing:0.5px;}.odds-row .odds-val{font-weight:700;font-size:13px;font-family:'Courier New',monospace;}.odds-row .odds-val.fav{color:#00e676;}.odds-row .odds-val.dog{color:#ff5252;}.odds-row .odds-val.even{color:#ffd740;}.odds-row .odds-src{color:#546e7a;font-size:9px;}.odds-row .odds-implied{color:#78909c;font-size:10px;}.odds-stale{opacity:0.5;}#odds-status{font-size:10px;color:#78909c;margin-left:8px;}
.live-indicator { display: inline-flex; align-items: center; gap: 6px; font-size: 11px; font-weight: 700; color: var(--green); letter-spacing: 0.5px; }
.live-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--green); animation: livePulse 1.5s ease-in-out infinite; }
@keyframes livePulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.4; transform: scale(0.8); } }
/* Mobile responsive */
@media (max-width: 768px) {
  .header { padding: 10px 16px; flex-wrap: wrap; gap: 8px; }
  .header h1 { font-size: 15px; }
  .header .subtitle { font-size: 10px; }
  .logo-icon { width: 30px; height: 30px; }
  .logo-text .logo-main { font-size: 16px; letter-spacing: 1px; }
  .logo-text .logo-sub { font-size: 8px; letter-spacing: 2px; }
  .logo-wrap { gap: 8px; }
  .header-right { gap: 4px; }
  .header-right button { font-size: 10px; padding: 4px 8px; }
  .tabs { overflow-x: auto; -webkit-overflow-scrolling: touch; scrollbar-width: none; }
  .tabs::-webkit-scrollbar { display: none; }
  .tab { padding: 10px 14px; font-size: 12px; }
  .signal-strip { flex-wrap: wrap; }
  .signal-chip { flex: 1 1 30%; min-width: 90px; padding: 8px; }
  .signal-chip .chip-value { font-size: 20px; }
  .signal-chip .chip-label { font-size: 10px; }
  .signal-chip .chip-desc { display: none; }
  .game-card-body { padding: 8px 10px; }
  .game-card { margin-bottom: 10px; }
  .modal { width: 95%; padding: 16px; }
  .container { padding: 10px; }
  #live-games, #tab-3pt, #tab-star, #tab-betlog, #tab-bankroll, #tab-guide { padding: 10px; }
  .edge-panel { padding: 10px; }
  .guide-card { padding: 12px; }
}
@media (max-width: 480px) {
  .header h1 { font-size: 13px; }
  .signal-chip { flex: 1 1 45%; }
  .tab { padding: 8px 10px; font-size: 11px; }
  .logo-icon { width: 24px; height: 24px; }
  .logo-text .logo-main { font-size: 14px; }
  .logo-text .logo-sub { display: none; }
  .logo-wrap { gap: 6px; }
}
.game-card.signal-fire { border: 2px solid var(--accent); box-shadow: 0 0 12px rgba(0, 212, 170, 0.15); }
.game-card.signal-warn { border: 1px solid var(--orange); }
</style>
</head>
<body>

<div class="header">
  <div class="logo-wrap">
    <svg class="logo-icon" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <linearGradient id="logoGrad" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" stop-color="#00d4aa"/>
          <stop offset="50%" stop-color="#00b4d8"/>
          <stop offset="100%" stop-color="#7c3aed"/>
        </linearGradient>
        <radialGradient id="glowGrad" cx="50%" cy="50%" r="50%">
          <stop offset="0%" stop-color="#00d4aa" stop-opacity="0.3"/>
          <stop offset="100%" stop-color="#00d4aa" stop-opacity="0"/>
        </radialGradient>
      </defs>
      <circle class="scope-pulse" cx="20" cy="20" r="2"/>
      <circle class="scope-ring" cx="20" cy="20" r="14"/>
      <circle class="scope-ring" cx="20" cy="20" r="8" stroke-dasharray="3 3"/>
      <line class="scope-cross" x1="20" y1="2" x2="20" y2="10"/>
      <line class="scope-cross" x1="20" y1="30" x2="20" y2="38"/>
      <line class="scope-cross" x1="2" y1="20" x2="10" y2="20"/>
      <line class="scope-cross" x1="30" y1="20" x2="38" y2="20"/>
      <circle class="scope-dot" cx="20" cy="20" r="2.5"/>
      <path d="M14 11 L20 5 L26 11" fill="none" stroke="url(#logoGrad)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" opacity="0.6"/>
    </svg>
    <div class="logo-text">
      <span class="logo-main" id="main-title">ALPHA HUNTER</span>
      <span class="logo-sub" id="main-subtitle">Live Edge Finder &bull; Signal-Driven Analytics</span>
    </div>
  </div>
  <div class="header-right">
    <span class="conn-status conn-ok" id="connStatus" style="display:none;">Connected</span>
    <div>
      <span class="status-dot off" id="statusDot"></span>
<span id="statusText" style="font-size:11px;">ESPN Feed</span>
    </div><button id="darkModeToggle" onclick="toggleDarkMode()" title="Toggle dark mode">ðŸŒ™ Dark</button><button class="sound-toggle" id="soundToggle" onclick="toggleSound()" title="Toggle alert sounds">&#x1F50A; Sound</button></div>
</div>

<div class="tab-bar">
  <div class="tab active" onclick="switchTab('live')" id="tab-live">Live Games <span class="badge" id="live-badge" style="display:none;">0</span></div>
  <div class="tab" onclick="switchTab('threept')" id="tab-threept">3PT Tracker <span class="badge badge-purple" id="threept-badge" style="display:none;">0</span></div>
  <div class="tab" onclick="switchTab('stars')" id="tab-stars">Star Tracker</div>
  <div class="tab" onclick="switchTab('log')" id="tab-log">Bet Log</div>
  <div class="tab" onclick="switchTab('bankroll')" id="tab-bankroll">Bankroll</div>
  <div class="tab" onclick="switchTab('history')" id="tab-history">ðŸ“Š History</div>
  <div class="tab" onclick="switchTab('guide')" id="tab-guide">Signal Guide</div>
</div>

<div class="container">
  <div id="quarter-alerts"></div>

  <!-- ==================== LIVE GAMES TAB ==================== -->
  <div class="tab-content active" id="content-live">
    <!-- EDGE THESIS PANEL -->
    <div class="edge-thesis-container" id="edgeThesisContainer">
      <div class="edge-thesis-header">
        <h2>LIVE EDGE OPPORTUNITIES</h2>
        <span class="thesis-count" id="thesisCount">0</span>
      </div>
      <div id="edgeThesisCards"></div>
    </div>

    <div class="auto-refresh-bar">
      <span class="dot" id="autoRefreshDot"></span>
      <span>Auto-refresh: <strong id="autoRefreshLabel">OFF</strong></span>
      <button class="btn btn-sm btn-green" id="autoRefreshBtn" onclick="toggleAutoRefresh()">Start</button>
      <span style="margin-left:6px;">Every:</span>
      <select id="refreshInterval" style="padding:2px 6px;font-size:11px;border-radius:4px;border:1px solid var(--border);" onchange="updateRefreshInterval()">
        <option value="30" selected>30s</option>
        <option value="60">60s</option>
        <option value="120">2min</option>
      </select>
      <div class="countdown-bar"><div class="countdown-fill" id="countdownFill" style="width:100%;"></div></div>
      <span class="live-indicator" id="liveIndicator" style="display:none"><span class="live-dot"></span>LIVE</span>
      <span style="margin-left:auto;color:var(--gray);font-size:10px;">Last: <span id="live-last-update">-</span> | Errors: <span id="errorCount">0</span></span>
    </div>

    <div class="signal-strip">
      <div class="signal-chip">
        <div class="chip-value" id="live-games-count">-</div>
        <div class="chip-label">Games</div>
        <div class="chip-desc">Total live games tracked</div>
      </div>
      <div class="signal-chip signal-chip-clickable" onclick="toggleSignalDetail('3ptfragile')">
        <div class="chip-value" id="live-3ptfragile-signals">0</div>
        <div class="chip-label">3PT Fragile</div>
        <div class="chip-desc">Hot 3PT shooting + fragile lead composition</div>
        <div class="chip-detail-panel" id="chip-detail-3ptfragile"></div>
      </div>
      <div class="signal-chip signal-chip-clickable" onclick="toggleSignalDetail('star')">
        <div class="chip-value" id="live-star-signals">0</div>
        <div class="chip-label">Star Cold</div>
        <div class="chip-desc">Stars underperforming pace</div>
        <div class="chip-detail-panel" id="chip-detail-star"></div>
      </div>
      <div class="signal-chip signal-chip-clickable" onclick="toggleSignalDetail('ft')">
        <div class="chip-value" id="live-ft-signals">0</div>
        <div class="chip-label">FT</div>
        <div class="chip-desc">Lead inflated by FT disparity</div>
        <div class="chip-detail-panel" id="chip-detail-ft"></div>
      </div>
      <div class="signal-chip signal-chip-clickable" onclick="toggleSignalDetail('combined')">
        <div class="chip-value" id="live-combined-signals">0</div>
        <div class="chip-label">Combined</div>
        <div class="chip-desc">2+ signals on same side</div>
        <div class="chip-detail-panel" id="chip-detail-combined"></div>
      </div>
    </div>

<!-- QUICK BET ACTION CARDS -->
<div id="quick-bet-panel" style="display:none; margin-bottom: 16px;">
  <div style="font-size: 11px; font-weight: 700; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">&#x26A1; ACTION REQUIRED</div>
  <div id="quick-bet-cards"></div>
</div>

    <div class="card">
      <div class="card-header"><span>Live Game Monitor</span>
        <button class="btn btn-green btn-sm" onclick="fetchESPNScoreboard()">Refresh Now</button>
      </div>
      <div class="card-body">
        <div class="games-grid" id="live-games-grid">
          <div class="empty-state" style="grid-column:1/-1;"><div class="icon">&#x1F3C0;</div><p>Click "Refresh Now" or start auto-refresh to load live games.</p></div>
        </div>
      </div>
    </div>

    </div>
  </div>

  <!-- ==================== 3PT TRACKER TAB ==================== -->
  <div class="tab-content" id="content-threept">
    <div class="stats-row">
      <div class="stat-card"><div class="stat-label">Teams 50%+ 3PT</div><div class="stat-value red" id="threept-hot-count">0</div></div>
      <div class="stat-card"><div class="stat-label">Teams 45-50%</div><div class="stat-value orange" id="threept-warm-count">0</div></div>
      <div class="stat-card"><div class="stat-label">Qtr Alerts</div><div class="stat-value purple" id="threept-qtr-alerts">0</div></div>
      </div>
    <div class="card">
      <div class="card-header"><span>3-Point Shooting Tracker - Live</span><span style="font-size:10px;color:var(--gray);">Alert: 50%+ on 8+ att</span></div>
      <div class="card-body"><div class="games-grid" id="threept-grid"><div class="empty-state" style="grid-column:1/-1;"><div class="icon">&#x1F3AF;</div><p>3PT tracking populates when live games run.</p></div></div></div>
    </div>
    <div class="card">
      <div class="card-header"><span>Quarter-End Alerts</span><button class="btn btn-sm btn-outline" onclick="clearQtrAlerts()">Clear</button></div>
      <div class="card-body">
        <table><thead><tr><th>Time</th><th>Team</th><th>Qtr</th><th>3PT%</th><th>Made/Att</th><th>Game</th><th>Action</th></tr></thead>
        <tbody id="qtr-alerts-body"><tr><td colspan="7" class="empty-state">No quarter-end alerts yet.</td></tr></tbody></table>
      </div>
    </div>
  </div>

  <!-- ==================== STAR TRACKER TAB ==================== -->
  <div class="tab-content" id="content-stars">
    <div class="card">
      <div class="card-header"><span>Star Player Database (23+ PPG)</span><span style="font-size:10px;color:var(--gray);">Signal: &lt;60% of expected pace</span></div>
      <div class="card-body" style="font-size:12px;">
        <p style="margin-bottom:10px;color:var(--gray);">Players tracked automatically in live games. Signal fires when scoring falls below 60% of expected pace. Tracks Q1 and halftime pace separately.</p>
        <table>
          <thead><tr><th>Player</th><th>Team</th><th>PPG</th><th>Q1 Exp</th><th>Half Exp</th><th>Signal (&lt;60%)</th><th></th></tr></thead>
          <tbody id="star-db-body"></tbody>
        </table>
        <div style="margin-top:10px;">
          <div class="form-grid" style="max-width:700px;">
            <div class="form-group"><label>Player Name</label><input type="text" id="add-star-name" placeholder="e.g., LeBron James" /></div>
            <div class="form-group"><label>Team</label><input type="text" id="add-star-team" placeholder="e.g., LAL" /></div>
            <div class="form-group"><label>PPG</label><input type="number" id="add-star-ppg" placeholder="e.g., 28.5" step="0.1" /></div>
            <div class="form-group" style="justify-content:flex-end;"><button class="btn btn-green" onclick="addStar()">Add</button></div>
          </div>
        </div>
      </div>
    </div>
    <div class="card">
      <div class="card-header">Live Star Status</div>
      <div class="card-body">
        <table><thead><tr><th>Player</th><th>Game</th><th>Pts</th><th>Q1 Pace</th><th>Half Pace</th><th>Overall %</th><th>Period</th><th>Signal</th></tr></thead>
        <tbody id="live-star-status"><tr><td colspan="8" class="empty-state">Star stats populate when live games are running.</td></tr></tbody></table>
      </div>
    </div>
  </div>

  <!-- ==================== BET LOG TAB ==================== -->
  <div class="tab-content" id="content-log">
    <div style="margin-bottom:20px">
      <h2 style="font-size:18px;font-weight:800;margin-bottom:4px">Bet Tracker</h2>
      <p style="font-size:12px;color:var(--text-muted)">Auto-logged when signals fire. Results auto-resolved from ESPN final scores.</p>
    </div>
    <div id="backtest-panel" style="display:grid;grid-template-columns:repeat(5,1fr);gap:12px;margin-bottom:20px">
      <div class="stat-card"><div class="stat-label">TOTAL BETS</div><div class="stat-value" id="bt-total" style="font-size:24px">0</div></div>
      <div class="stat-card"><div class="stat-label">WIN RATE</div><div class="stat-value" id="bt-winrate" style="font-size:24px;color:var(--green)">-</div></div>
      <div class="stat-card"><div class="stat-label">ROI</div><div class="stat-value" id="bt-roi" style="font-size:24px">-</div></div>
      <div class="stat-card"><div class="stat-label">AVG EDGE</div><div class="stat-value" id="bt-edge" style="font-size:24px;color:var(--accent)">-</div></div>
      <div class="stat-card"><div class="stat-label">UNITS P/L</div><div class="stat-value" id="bt-units" style="font-size:24px">0.00</div></div>
    </div>
    <div id="signal-breakdown" style="margin-bottom:20px"></div>
    <div style="display:flex;gap:10px;margin-bottom:16px;align-items:center">
      <button style="background:var(--accent);color:white;border:none;padding:8px 16px;border-radius:8px;font-size:12px;font-weight:600;cursor:pointer" onclick="exportBetLog()">Export CSV</button>
      <button style="background:var(--card-bg);color:var(--text-muted);border:1px solid var(--border);padding:8px 16px;border-radius:8px;font-size:12px;font-weight:600;cursor:pointer" onclick="if(confirm('Clear all bet log data?'))clearBetLog()">Clear Log</button>
      <span style="margin-left:auto;font-size:11px;color:var(--text-muted)">Bets auto-log when combined signals fire</span>
    </div>
    <div class="card" style="padding:0;overflow:hidden">
      <div id="bet-log-entries" style="overflow-x:auto"></div>
    </div>
  </div>

  <!-- ==================== BANKROLL TAB ==================== -->
  <div class="tab-content" id="content-bankroll">
    <div style="margin-bottom:20px">
      <h2 style="font-size:18px;font-weight:800;margin-bottom:4px">Position Sizing</h2>
      <p style="font-size:12px;color:var(--text-muted)">Kelly criterion-based bet sizing. Conservative by default - capped at 5% max per bet.</p>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:24px">
      <div class="card" style="padding:20px">
        <h3 style="font-size:14px;font-weight:700;color:var(--accent);margin-bottom:16px">Settings</h3>
        <div style="margin-bottom:14px">
          <label style="font-size:11px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px">Bankroll</label>
          <input type="number" id="bankroll-input" value="1000" min="1" style="margin-top:4px;font-size:16px;font-weight:700" onchange="saveBankrollSettings()">
        </div>
        <div style="margin-bottom:14px">
          <label style="font-size:11px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px">Kelly Fraction</label>
          <select id="kelly-fraction" style="margin-top:4px" onchange="saveBankrollSettings()">
            <option value="0.25">Quarter Kelly (25%) - Safest</option>
            <option value="0.5" selected>Half Kelly (50%) - Recommended</option>
            <option value="0.75">Three-Quarter Kelly (75%)</option>
            <option value="1">Full Kelly (100%) - Max Risk</option>
          </select>
        </div>
        <div style="margin-bottom:14px">
          <label style="font-size:11px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.5px">Edge Estimate</label>
          <select id="edge-mode" style="margin-top:4px" onchange="saveBankrollSettings()">
            <option value="conservative">Conservative (2-5%)</option>
            <option value="moderate" selected>Moderate (3.5-6.5%)</option>
            <option value="aggressive">Aggressive (6-9%)</option>
            <option value="backtest">From Your Bet History</option>
          </select>
        </div>
        <div style="background:var(--bg);border-radius:8px;padding:12px;margin-top:12px">
          <div style="font-size:10px;font-weight:700;color:var(--text-muted);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px">Sizing Rules</div>
          <div style="font-size:11px;color:var(--text-secondary);line-height:1.6">
            Max bet: 5% of bankroll<br>
            Min bet: 0.5% (if edge exists)<br>
            Edge scales with signal count<br>
            Probability capped at 90%
          </div>
        </div>
      </div>
      <div class="card" style="padding:20px">
        <h3 style="font-size:14px;font-weight:700;color:var(--accent);margin-bottom:16px">Kelly Formula</h3>
        <div style="background:var(--bg);border-radius:8px;padding:16px;font-family:'Courier New',monospace;font-size:13px;color:var(--text-secondary);line-height:2">
          f* = (b x p - q) / b<br>
          <span style="color:var(--text-muted);font-size:11px">b = decimal odds - 1</span><br>
          <span style="color:var(--text-muted);font-size:11px">p = market prob + estimated edge</span><br>
          <span style="color:var(--text-muted);font-size:11px">q = 1 - p</span><br><br>
          <span style="color:var(--accent);font-weight:bold">Bet = Bankroll x f* x Fraction</span>
        </div>
        <div style="margin-top:16px;padding:12px;background:var(--accent-light);border-radius:8px;border-left:3px solid var(--accent)">
          <div style="font-size:11px;color:var(--accent);font-weight:600">How edge is estimated</div>
          <div style="font-size:11px;color:var(--text-secondary);margin-top:4px;line-height:1.5">
            Base edge depends on your mode setting. Each additional signal on the same game adds +1% edge (up to +3%). More signals = higher confidence = larger position.
          </div>
        </div>
      </div>
    </div>
    <div class="card" style="padding:20px">
      <h3 style="font-size:14px;font-weight:700;color:var(--accent);margin-bottom:16px">Active Recommendations</h3>
      <div id="kelly-recs"><p style="color:var(--text-muted);text-align:center;padding:30px;font-size:13px">Refresh games to see Kelly-sized recommendations</p></div>
    </div>
  </div>
</div>

<!-- LOG BET MODAL -->
<div class="modal-overlay" id="logModal">
  <div class="modal">
    <h3>Log This Bet</h3>
    <div class="form-grid">
      <div class="form-group"><label>Game</label><input type="text" id="modal-game" /></div>
      <div class="form-group"><label>Side</label><input type="text" id="modal-side" /></div>
      <div class="form-group"><label>Strategy</label><select id="modal-strategy"><option>Mean Reversion</option><option>3PT Fragile</option><option>Star Cold</option><option>FT Inflation</option><option>Combined Edge</option></select></div>
      <div class="form-group"><label>Line / Price</label><input type="text" id="modal-price" /></div>
      <div class="form-group"><label>Units</label><input type="number" id="modal-units" value="1" step="0.5" min="0.5" max="2" /></div>
      <div class="form-group"><label>Notes</label><input type="text" id="modal-notes" /></div>
    </div>
    <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px;">
      <button class="btn btn-outline" onclick="closeModal()">Cancel</button>
      <button class="btn btn-green" onclick="confirmLogBet()">Log Bet</button>
    </div>
  </div>
</div>


  <div id="scenario-alert-panel" class="scenario-alert-panel" style="display:none;"></div>

  <!-- No toast container â€” signals show on chips and game cards only -->

<script>
const TEAM_3PT_AVG = {
  // NBA (2025-26)
  BOS:38.1, CLE:37.9, OKC:38.9, HOU:36.2, GSW:37.8, DEN:36.5, DAL:37.6, MIL:36.8,
  MIN:36.3, NYK:37.8, PHI:36.9, PHX:38.2, LAC:36.5, MEM:35.9, SAC:37.5, MIA:36.8,
  IND:36.7, ORL:35.4, ATL:37.2, CHI:34.2, BKN:35.4, CHA:34.8, TOR:36.1, POR:35.6,
  SAS:35.3, DET:35.7, LAL:36.3, WAS:34.5, UTA:37.0, NOP:35.1, NY:37.8, GS:37.8,
  SA:35.3, NO:35.1
};
function getTeam3PtAvg(abbr) { return TEAM_3PT_AVG[abbr] || null; }

let currentMode='nba';

// === LIVE ODDS (The Odds API) ===
let oddsCache={};let oddsCacheTime=0;const ODDS_CACHE_TTL=120000;
let oddsRequestCount=parseInt(localStorage.getItem('oddsReqCount')||'0');
let oddsReqMonth=localStorage.getItem('oddsReqMonth')||'';
function getOddsSport(){return 'basketball_nba';}
function impliedProb(am){const n=parseInt(am);if(n<0)return(Math.abs(n)/(Math.abs(n)+100)*100).toFixed(1);return(100/(n+100)*100).toFixed(1);}
function oddsClass(am){const n=parseInt(am);if(n<=-150)return'fav';if(n>=150)return'dog';return'even';}
async function fetchLiveOdds(){
  const now=Date.now();
  if(now-oddsCacheTime<ODDS_CACHE_TTL&&Object.keys(oddsCache).length>0)return oddsCache;
  const curMonth=new Date().toISOString().slice(0,7);
  if(oddsReqMonth!==curMonth){oddsRequestCount=0;oddsReqMonth=curMonth;}
  if(oddsRequestCount>=480){console.warn('Odds API near limit');return oddsCache;}
  try{
    const sport=getOddsSport();
    const resp=await fetch('https://api.the-odds-api.com/v4/sports/'+sport+'/odds/?apiK'+'ey=4ca2c6a2ed9e162809eb03722e2dc734&regions=us&markets=h2h,totals&oddsFormat=american&bookmakers=fanduel,draftkings,betmgm');
    if(!resp.ok){console.warn('Odds API:',resp.status);return oddsCache;}
    const data=await resp.json();
    oddsRequestCount++;
    localStorage.setItem('oddsReqCount',oddsRequestCount.toString());
    localStorage.setItem('oddsReqMonth',curMonth);
    const remaining=resp.headers.get('x-requests-remaining');
    const el=document.getElementById('odds-status');
    if(el)el.textContent='Odds: '+(remaining||'?')+' calls left';
    const nc={};
    for(const g of data){
      // Find h2h from any bookmaker
      let homeML=null,awayML=null,bookName='';
      for(const bk of (g.bookmakers||[])){
        const mk=bk.markets?.find(m=>m.key==='h2h');
        if(mk){
          const ho=mk.outcomes?.find(o=>o.name===g.home_team);
          const ao=mk.outcomes?.find(o=>o.name===g.away_team);
          if(ho&&ao){homeML=ho.price;awayML=ao.price;bookName=bk.title;break;}
        }
      }
      if(homeML===null||awayML===null)continue;
      // Find totals from ANY bookmaker (not just the first one)
      let ouLine=null,overPrice=null,underPrice=null;
      for(const bk of (g.bookmakers||[])){
        const totMkt=bk.markets?.find(m=>m.key==='totals');
        if(totMkt){
          const overO=totMkt.outcomes?.find(o=>o.name==='Over');
          const underO=totMkt.outcomes?.find(o=>o.name==='Under');
          if(overO){ouLine=overO.point;overPrice=overO.price;}
          if(underO){underPrice=underO.price;if(!ouLine)ouLine=underO.point;}
          if(ouLine)break; // found it, stop searching
        }
      }
      nc[g.away_team+' vs '+g.home_team]={home:g.home_team,away:g.away_team,homeML,awayML,book:bookName,ouLine,overPrice,underPrice};
    }
    oddsCache=nc;oddsCacheTime=now;return nc;
  }catch(e){console.warn('Odds error:',e);return oddsCache;}
}
function matchOdds(aAbbr,hAbbr,aFull,hFull){
  for(const k of Object.keys(oddsCache)){
    const g=oddsCache[k];
    const gH=g.home.toUpperCase();
    const gA=g.away.toUpperCase();
    // Try multiple matching strategies: abbreviation, last word of full name, full name contains
    const hM=gH.includes(hAbbr)||(hFull&&(gH.includes(hFull.toUpperCase().split(' ').pop())||gH.includes(hFull.toUpperCase().split(' ')[0])));
    const aM=gA.includes(aAbbr)||(aFull&&(gA.includes(aFull.toUpperCase().split(' ').pop())||gA.includes(aFull.toUpperCase().split(' ')[0])));
    if(hM&&aM)return g;
  }
  return null;
}
function buildOddsHTML(aAbbr,hAbbr,aFull,hFull){const o=matchOdds(aAbbr,hAbbr,aFull,hFull);if(!o)return'';const aML=(o.awayML>0?'+':'')+o.awayML;const hML=(o.homeML>0?'+':'')+o.homeML;return'<div class="odds-row"><span><span class="odds-label">'+aAbbr+' ML</span> <span class="odds-val '+oddsClass(aML)+'">'+aML+'</span> <span class="odds-implied">('+impliedProb(aML)+'%)</span></span><span class="odds-src">'+o.book+'</span><span><span class="odds-implied">('+impliedProb(hML)+'%)</span> <span class="odds-val '+oddsClass(hML)+'">'+hML+'</span> <span class="odds-label">'+hAbbr+' ML</span></span></div>';}

function getESPNUrl(){return 'https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard';}

// ==================== STAR DATABASE (23+ PPG) ====================
const DEFAULT_STARS = [
  { name: "Shai Gilgeous-Alexander", team: "OKC", ppg: 32.2 },
  { name: "Giannis Antetokounmpo", team: "MIL", ppg: 31.5 },
  { name: "Nikola Jokic", team: "DEN", ppg: 29.0 },
  { name: "Luka Doncic", team: "DAL", ppg: 28.1 },
  { name: "Jayson Tatum", team: "BOS", ppg: 27.8 },
  { name: "Joel Embiid", team: "PHI", ppg: 27.6 },
  { name: "Kevin Durant", team: "PHX", ppg: 27.3 },
  { name: "Devin Booker", team: "PHX", ppg: 27.2 },
  { name: "Anthony Edwards", team: "MIN", ppg: 27.0 },
  { name: "De'Aaron Fox", team: "SAC", ppg: 26.8 },
  { name: "Donovan Mitchell", team: "CLE", ppg: 26.5 },
  { name: "Jalen Brunson", team: "NYK", ppg: 26.3 },
  { name: "Anthony Davis", team: "LAL", ppg: 25.7 },
  { name: "Tyrese Maxey", team: "PHI", ppg: 25.5 },
  { name: "Karl-Anthony Towns", team: "NYK", ppg: 25.3 },
  { name: "Cade Cunningham", team: "DET", ppg: 24.8 },
  { name: "Trae Young", team: "ATL", ppg: 24.3 },
  { name: "Damian Lillard", team: "MIL", ppg: 24.0 },
  { name: "Jaylen Brown", team: "BOS", ppg: 23.8 },
  { name: "LeBron James", team: "LAL", ppg: 23.5 },
  { name: "Jaren Jackson Jr.", team: "MEM", ppg: 23.3 },
  { name: "Tyrese Haliburton", team: "IND", ppg: 23.2 },
  { name: "Zion Williamson", team: "NOP", ppg: 23.0 },
];

const TEAM_MAP = {
  'Atlanta Hawks':'ATL','Boston Celtics':'BOS','Brooklyn Nets':'BKN','Charlotte Hornets':'CHA',
  'Chicago Bulls':'CHI','Cleveland Cavaliers':'CLE','Dallas Mavericks':'DAL','Denver Nuggets':'DEN',
  'Detroit Pistons':'DET','Golden State Warriors':'GSW','Houston Rockets':'HOU','Indiana Pacers':'IND',
  'LA Clippers':'LAC','Los Angeles Clippers':'LAC','Los Angeles Lakers':'LAL','Memphis Grizzlies':'MEM',
  'Miami Heat':'MIA','Milwaukee Bucks':'MIL','Minnesota Timberwolves':'MIN','New Orleans Pelicans':'NOP',
  'New York Knicks':'NYK','Oklahoma City Thunder':'OKC','Orlando Magic':'ORL','Philadelphia 76ers':'PHI',
  'Phoenix Suns':'PHX','Portland Trail Blazers':'POR','Sacramento Kings':'SAC','San Antonio Spurs':'SAS',
  'Toronto Raptors':'TOR','Utah Jazz':'UTA','Washington Wizards':'WAS',
};
function shortName(n) { return TEAM_MAP[n] || n.split(' ').pop().substring(0,3).toUpperCase(); }
function teamDisplay(abbr, fullName) { return abbr; }
function teamDisplayShort(abbr, fullName) { return abbr; }

// ==================== STATE ====================
let state = {
  betLog: JSON.parse(localStorage.getItem('betLog') || '[]'),
  bankroll: JSON.parse(localStorage.getItem('bankroll') || '{"start":0,"current":0}'),
  stars: JSON.parse(localStorage.getItem('starPlayers') || 'null') || DEFAULT_STARS,
  autoRefresh: false, refreshTimer: null, countdownTimer: null,
  quarterAlerts: JSON.parse(localStorage.getItem('quarterAlerts') || '[]'),
  lastKnownPeriods: {}, prevTeamData: {},
  errorCount: 0, consecutiveErrors: 0,
  signalFirstSeen: {},
  favorites: JSON.parse(localStorage.getItem('favorites') || '[]'),
  signalHistory: JSON.parse(localStorage.getItem('signalHistory') || '[]'),
};

// ==================== INIT ====================
const _bsEl = document.getElementById('bankroll-start');
const _bcEl = document.getElementById('bankroll-current');
if (_bsEl) _bsEl.value = state.bankroll.start || '';
if (_bcEl) _bcEl.value = state.bankroll.current || '';
renderBetLog(); renderStarDB(); renderQtrAlerts(); loadBankrollSettings();

// Kill browser notifications permanently â€” we use in-app toasts only
if (window.Notification) { window.Notification = function(){}; window.Notification.permission = 'denied'; window.Notification.requestPermission = function(){ return Promise.resolve('denied'); }; }

// In-app toast notification system
let notifiedSignals = new Set(JSON.parse(localStorage.getItem('notifiedSignals') || '[]'));
function sendSignalNotification(title, body, gameId, signalType) {
  // No popups â€” signals show on chips and game cards only
  const key = gameId + '_' + signalType + '_' + new Date().getHours();
  if (notifiedSignals.has(key)) return;
  notifiedSignals.add(key);
  if (notifiedSignals.size > 200) notifiedSignals = new Set([...notifiedSignals].slice(-100));
  localStorage.setItem('notifiedSignals', JSON.stringify([...notifiedSignals]));
  // No toast, no popup â€” just track that we saw this signal
}

// ==================== TABS ====================
function switchTab(t) {
  document.querySelectorAll('.tab').forEach(x => x.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(x => x.classList.remove('active'));
  document.getElementById('tab-'+t).classList.add('active');
  document.getElementById('content-'+t).classList.add('active');
}

// ==================== SIGNAL CHIP CLICK-TO-EXPAND ====================
function toggleSignalDetail(type) {
  const panel = document.getElementById('chip-detail-' + type);
  if (!panel) return;

  // Close all other panels first
  document.querySelectorAll('.chip-detail-panel.active').forEach(p => {
    if (p.id !== 'chip-detail-' + type) p.classList.remove('active');
  });

  // Toggle this panel
  const isOpen = panel.classList.contains('active');
  if (isOpen) {
    panel.classList.remove('active');
    return;
  }

  // Build panel content from stored signal games
  const games = window._signalGames ? window._signalGames[type] : [];
  const labels = { '3ptfragile': '3PT Fragile', 'star': 'Star Cold', 'ft': 'FT Inflation', 'combined': 'Combined Edge' };

  if (!games || games.length === 0) {
    panel.innerHTML = `<div class="chip-detail-header">${labels[type] || type} Games</div><div class="chip-detail-empty">No active ${labels[type] || ''} signals right now</div>`;
  } else {
    const periodLabel = (per) => `Q${per}`;
    panel.innerHTML = `<div class="chip-detail-header">${labels[type] || type} â€” ${games.length} game${games.length>1?'s':''}</div>` +
      games.map(g => {
        const truncDetail = g.sigDetail && g.sigDetail.length > 120 ? g.sigDetail.substring(0, 120) + '...' : (g.sigDetail || '');
        const eid = g.eventId || '';
        return `<div class="chip-detail-item chip-detail-clickable" onclick="scrollToGame('${eid}')" title="Click to jump to game">
          <div class="chip-detail-game">${g.gameFull || g.game} <span style="font-size:9px;color:var(--accent);margin-left:4px;">â†— go</span></div>
          <div class="chip-detail-score">${g.aScore} - ${g.hScore} | ${periodLabel(g.per)} ${g.clk}</div>
          <div class="chip-detail-sig">${truncDetail}</div>
        </div>`;
      }).join('');
  }

  panel.classList.add('active');
}

// Scroll to a game card when clicking from signal dropdown
function scrollToGame(eventId) {
  if (!eventId) return;
  // Close all chip detail panels
  document.querySelectorAll('.chip-detail-panel.active').forEach(p => p.classList.remove('active'));
  // Find the game card
  const card = document.querySelector(`.game-card[data-game-id="${eventId}"]`);
  if (card) {
    // Smooth scroll to the card
    card.scrollIntoView({ behavior: 'smooth', block: 'center' });
    // Flash highlight effect
    card.classList.add('signal-highlight-flash');
    setTimeout(() => card.classList.remove('signal-highlight-flash'), 2500);
  }
}

// Close signal detail panels when clicking outside
document.addEventListener('click', function(e) {
  if (!e.target.closest('.signal-chip-clickable')) {
    document.querySelectorAll('.chip-detail-panel.active').forEach(p => p.classList.remove('active'));
  }
});

// ==================== AUTO REFRESH ====================
function toggleAutoRefresh() {
  state.autoRefresh = !state.autoRefresh;
  const btn = document.getElementById('autoRefreshBtn'), dot = document.getElementById('autoRefreshDot'), lbl = document.getElementById('autoRefreshLabel');
  if (state.autoRefresh) {
    btn.textContent = 'Stop'; btn.className = 'btn btn-sm btn-red'; dot.className = 'dot'; lbl.textContent = 'ON';
    document.getElementById('liveIndicator').style.display = 'inline-flex';
    fetchESPNScoreboard(); startCountdown();
  } else {
    btn.textContent = 'Start'; btn.className = 'btn btn-sm btn-green'; dot.className = 'dot off'; lbl.textContent = 'OFF';
    document.getElementById('liveIndicator').style.display = 'none';
    clearInterval(state.refreshTimer); clearInterval(state.countdownTimer);
    document.getElementById('countdownFill').style.width = '100%';
  }
}
function startCountdown() {
  const iv = parseInt(document.getElementById('refreshInterval').value) * 1000;
  let rem = iv;
  clearInterval(state.refreshTimer); clearInterval(state.countdownTimer);
  state.refreshTimer = setInterval(() => { if (state.autoRefresh) { fetchESPNScoreboard(); rem = iv; } }, iv);
  state.countdownTimer = setInterval(() => { rem -= 1000; document.getElementById('countdownFill').style.width = Math.max(0, rem/iv*100)+'%'; }, 1000);
}
function updateRefreshInterval() { if (state.autoRefresh) startCountdown(); }

// ==================== PACE HELPERS ====================
function getQ1Expected(ppg) { return ppg * 0.25; }
function getHalfExpected(ppg) { return ppg * 0.5; }
function getExpectedByTime(ppg, mins) { return ppg * (mins / getTotalGameMinutes()); }

// === TIME HELPERS (NBA) ===
function getTotalGameMinutes() { return 48; }
function getPeriodLength() { return 12; }
function getElapsedMinutes(per, clk) {
  const perLen = getPeriodLength();
  const parts = (clk || '0:00').split(':');
  const cM = parseFloat(parts[0]) || 0;
  const cS = parseFloat(parts[1]) || 0;
  const clockRemaining = cM + cS / 60;
  return (per - 1) * perLen + (perLen - clockRemaining);
}
function getGamePct(per, clk) {
  return Math.min(getElapsedMinutes(per, clk) / getTotalGameMinutes(), 1);
}

// ==================== CONNECTION STATUS ====================
function setConnStatus(status) {
  const el = document.getElementById('connStatus');
  const dot = document.getElementById('statusDot');
  el.style.display = 'inline';
  if (status === 'ok') { el.textContent = 'Connected'; el.className = 'conn-status conn-ok'; dot.className = 'status-dot live'; state.consecutiveErrors = 0; }
  else if (status === 'error') { el.textContent = 'Error'; el.className = 'conn-status conn-err'; dot.className = 'status-dot error'; state.consecutiveErrors++; state.errorCount++; }
  else { el.textContent = 'Loading...'; el.className = 'conn-status conn-loading'; }
  document.getElementById('errorCount').textContent = state.errorCount;
}

// ==================== QUARTER-END DETECTION ====================
function checkQuarterEnd(gameId, teamAbbr, currentPeriod, pct, made, att, gameLabel) {
  const key = `${gameId}_${teamAbbr}`;
  const prev = state.lastKnownPeriods[key] || 0;
  if (currentPeriod > prev && prev > 0) {
    const p = state.prevTeamData[key];
    if (p) {
      const qM = (parseInt(made)||0) - (p.made||0), qA = (parseInt(att)||0) - (p.att||0);
      const qP = qA > 0 ? (qM/qA*100) : 0;
      if (qP >= 50 && qA >= 4) {
        const a = { id: Date.now()+Math.random(), time: new Date().toLocaleTimeString(), team: teamAbbr, quarter: prev, pct: qP.toFixed(1), made: qM, att: qA, game: gameLabel };
        state.quarterAlerts.unshift(a); localStorage.setItem('quarterAlerts', JSON.stringify(state.quarterAlerts));
        renderQtrAlerts(); showQuarterToast(a);
      }
    }
  }
  state.lastKnownPeriods[key] = currentPeriod;
  state.prevTeamData[key] = { made: parseInt(made)||0, att: parseInt(att)||0, period: currentPeriod };
}

function showQuarterToast(a) {
  // No popup â€” just update the badge count silently
  const badge = document.getElementById('threept-badge');
  if (state.quarterAlerts.length > 0) { badge.style.display = 'inline'; badge.textContent = state.quarterAlerts.length; }
}

function renderQtrAlerts() {
  const tb = document.getElementById('qtr-alerts-body');
  if (!state.quarterAlerts.length) { tb.innerHTML = '<tr><td colspan="7" class="empty-state">No quarter-end alerts yet.</td></tr>'; document.getElementById('threept-qtr-alerts').textContent = '0'; return; }
  tb.innerHTML = state.quarterAlerts.map(a => `<tr><td>${a.time}</td><td><strong>${a.team}</strong></td><td>Q${a.quarter}</td><td style="color:var(--red);font-weight:800;">${a.pct}%</td><td>${a.made}/${a.att}</td><td>${a.game}</td><td><button class="btn btn-purple btn-sm" onclick="openLogModal('${a.game}','3PT Q${a.quarter}','3PT Regression')">Log</button></td></tr>`).join('');
  document.getElementById('threept-qtr-alerts').textContent = state.quarterAlerts.length;
}
function clearQtrAlerts() { if(confirm('Clear all?')) { state.quarterAlerts=[]; localStorage.setItem('quarterAlerts','[]'); renderQtrAlerts(); document.getElementById('threept-badge').style.display='none'; } }

// ==================== LEAD DURABILITY (PAINT vs 3PT) ====================
function analyzeScoringDurability(teamAbbr, score, fg3Made, opponentScore) {
  const s = parseInt(score) || 0;
  const m3 = parseInt(fg3Made) || 0;
  if (s <= 0) return { pct3: 0, durability: 'neutral', label: '-', fragile: false };
  const pts3 = m3 * 3;
  const pct3 = (pts3 / s * 100);
  const nonThreePts = s - pts3;
  // League average: ~35% of points come from 3PT. Above 42% is fragile, below 28% is durable
  const isLeading = s > (parseInt(opponentScore) || 0);
  const fragile = pct3 >= getFragile3PtThreshold() && isLeading && s >= 20;
  const durable = pct3 <= 28 && isLeading && s >= 20;
  let label = `${pct3.toFixed(0)}% from 3`;
  let durability = 'neutral';
  if (fragile) { durability = 'fragile'; label = `${pct3.toFixed(0)}% from 3 - FRAGILE lead`; }
  else if (durable) { durability = 'durable'; label = `${pct3.toFixed(0)}% from 3 - DURABLE lead`; }
  return { pct3, durability, label, fragile, durable, pts3, nonThreePts };
}

// ==================== FOUL TRACKING ====================
function analyzeFTInflation(aFTA, hFTA, aScore, hScore) {
  const aFt = parseInt(aFTA)||0, hFt = parseInt(hFTA)||0;
  const ftGap = Math.abs(aFt - hFt);
  const aLeading = (parseInt(aScore)||0) > (parseInt(hScore)||0);
  const hLeading = (parseInt(hScore)||0) > (parseInt(aScore)||0);
  // Signal fires when leading team has 10+ more FTA than trailing team
  const aInflated = aLeading && aFt > hFt && ftGap >= 10;
  const hInflated = hLeading && hFt > aFt && ftGap >= 10;
  return { aFTA: aFt, hFTA: hFt, ftGap, aInflated, hInflated };
}


// ==================== ESPN SCOREBOARD ====================

function getLeague3PtAvg() { return 36.5; }
// Team Season 3PT% Averages

function getFragile3PtThreshold() { return 42; }
function getLeagueName() { return 'NBA'; }

async function fetchESPNScoreboard() {
  const grid = document.getElementById('live-games-grid');
  const tpGrid = document.getElementById('threept-grid');
  setConnStatus('loading');
    await fetchLiveOdds();

  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 10000);
    const res = await fetch(getESPNUrl(), { signal: controller.signal });
    clearTimeout(timeout);
    if (!res.ok) throw new Error('ESPN ' + res.status);
    const data = await res.json();
    setConnStatus('ok');
    const events = data.events || [];
    document.getElementById('live-last-update').textContent = new Date().toLocaleTimeString();

    const liveEvents = events.filter(e => { const s = e.status?.type?.state; return s === 'in' || s === 'pre'; });
    const inProgress = events.filter(e => e.status?.type?.state === 'in');
    document.getElementById('live-games-count').textContent = inProgress.length;

    if (liveEvents.length === 0) {
      grid.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><div class="icon">&#x1F3C0;</div><p>No live or upcoming NBA games right now.</p></div>`;
      tpGrid.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><div class="icon">&#x1F3AF;</div><p>No live games.</p></div>`;
      document.getElementById('edgeThesisContainer').classList.remove('active');
      return;
    }

    let sig3Fragile=0, sigStar=0, sigCombined=0, sigFT=0, hotTeams=0, warmTeams=0;
    let cards='', tpCards='', gameTheses=[];
    // Per-signal game tracking for chip click-to-expand
    let signalGames = { '3ptfragile': [], 'star': [], 'ft': [], 'combined': [] };

    for (const event of liveEvents) {
      const comp = event.competitions?.[0]; if (!comp) continue;
      const away = comp.competitors?.find(c => c.homeAway==='away');
      const home = comp.competitors?.find(c => c.homeAway==='home');
      if (!away || !home) continue;

      const gid = event.id;
      const aA = away.team?.abbreviation || shortName(away.team?.displayName||'');
      const aFull = away.team?.displayName||'';
      const hFull = home.team?.displayName||'';
      const hA = home.team?.abbreviation || shortName(home.team?.displayName||'');
      const aS = parseInt(away.score)||0, hS = parseInt(home.score)||0;
      const isLive = event.status?.type?.state === 'in';
      const per = event.status?.period||0, clk = event.status?.displayClock||'';
      const detail = event.status?.type?.shortDetail||'';
      const gLabel = `${aA} @ ${hA}`;
      const aRec = away.records?.[0]?.summary||'', hRec = home.records?.[0]?.summary||'';

      let aStats={}, hStats={};
      (away.statistics||[]).forEach(s => { aStats[s.name]=s.displayValue; });
      (home.statistics||[]).forEach(s => { hStats[s.name]=s.displayValue; });

      let a3P=aStats.threePointFieldGoalPct||aStats.threePointPct||'-';
      let h3P=hStats.threePointFieldGoalPct||hStats.threePointPct||'-';
      let a3M=aStats.threePointFieldGoalsMade||'-', a3A=aStats.threePointFieldGoalsAttempted||'-';
      let h3M=hStats.threePointFieldGoalsMade||'-', h3A=hStats.threePointFieldGoalsAttempted||'-';
      let aFouls=aStats.fouls||aStats.totalFouls||'0', hFouls=hStats.fouls||hStats.totalFouls||'0';
      let aFTA = parseInt(aStats.freeThrowsAttempted)||0;
      let hFTA = parseInt(hStats.freeThrowsAttempted)||0;

      if (isLive) { checkQuarterEnd(gid, aA, per, a3P, a3M, a3A, gLabel); checkQuarterEnd(gid, hA, per, h3P, h3M, h3A, gLabel); }

      let aLeaders=[], hLeaders=[];
      (comp.competitors||[]).forEach(c => {
        (c.leaders||[]).forEach(cat => {
          if (cat.name==='points'||cat.displayName==='Points') {
            (cat.leaders||[]).forEach(l => {
              const e = { name: l.athlete?.shortName||l.athlete?.displayName||'?', pts: parseFloat(l.value)||0, team: c.homeAway==='away'?aA:hA };
              if (c.homeAway==='away') aLeaders.push(e); else hLeaders.push(e);
            });
          }
        });
      });

      let signals=[], signalLevel=0;
      const gLabelFull = gLabel;
      let thesis = { game: gLabel, gameFull: gLabelFull, aTeam: aA, hTeam: hA, aTeamFull: aFull, hTeamFull: hFull, aScore: aS, hScore: hS, per, clk, detail, criteria: {}, betSide: '', betSideFull: '', betLogic: '', signals: [] };

      if (isLive) {
        // 3PT CHECK â€” evaluate shooting stats (used as input for 3PT Fragile signal)
        const chk3 = (p,m,a,t,side,tFull) => {
          const pn=parseFloat(p), an=parseInt(a), mn=parseInt(m);
          const tD = teamDisplay(t, tFull);
          const isHot = (pn>=50&&an>=12)||(pn>=55&&an>=8);
          const isWarm = !isHot && pn>=45&&an>=10;
          if (isHot) {
            fire3PTAlert(t, pn.toFixed(0), mn, an, gLabel, per, clk); hotTeams++;
          } else if (isWarm) { warmTeams++; }
          // NOTE: 3PT alone no longer fires as a level 2 signal.
          // It will be combined with Fragile Lead below into "3PT Fragile"
          return { isHot, isWarm, pn, an, mn, tD };
        };
        const a3Check = chk3(a3P,a3M,a3A,aA,'away',aFull), h3Check = chk3(h3P,h3M,h3A,hA,'home',hFull);

        // FRAGILE LEAD CHECK â€” evaluate lead composition (used as input for 3PT Fragile signal)
        const aDur = analyzeScoringDurability(aA, aS, a3M, hS);
        const hDur = analyzeScoringDurability(hA, hS, h3M, aS);
        let aFragileData = null, hFragileData = null;
        if (aS > hS && aDur.pct3 >= getFragile3PtThreshold() && aS >= 20) {
          const hNon3Pct = hS > 0 ? ((hS - (parseInt(h3M)||0)*3) / hS * 100) : 0;
          if (hNon3Pct >= 58) aFragileData = { pct3: aDur.pct3, oppPaintPct: hNon3Pct };
        }
        if (hS > aS && hDur.pct3 >= getFragile3PtThreshold() && hS >= 20) {
          const aNon3Pct = aS > 0 ? ((aS - (parseInt(a3M)||0)*3) / aS * 100) : 0;
          if (aNon3Pct >= 58) hFragileData = { pct3: hDur.pct3, oppPaintPct: aNon3Pct };
        }

        // ========== 3PT FRAGILE SIGNAL â€” fires ONLY when BOTH conditions are met ==========
        // Condition 1: Team shooting hot from 3 (50%+ on 12+ att or 55%+ on 8+ att)
        // Condition 2: Their lead is fragile (3PT-heavy) AND trailing team scores from paint
        const _aD = teamDisplay(aA, aFull), _hD = teamDisplay(hA, hFull);

        // Away team: both hot 3PT AND fragile lead
        if (a3Check.isHot && aFragileData) {
          signals.push({type:'3ptFragile', text:`${_aD} 3PT FRAGILE: shooting ${a3Check.pn.toFixed(0)}% from 3 (${a3Check.mn}/${a3Check.an}) AND lead is ${aFragileData.pct3.toFixed(0)}% 3PT-dependent. ${_hD} scores from paint (${aFragileData.oppPaintPct.toFixed(0)}%). Classic fade.`, level:2});
          sig3Fragile++;
          sendSignalNotification('ðŸ”¥ 3PT Fragile: ' + _aD, aA + ' shooting ' + a3Check.pn.toFixed(0) + '% from 3 AND lead is fragile', gid, '3ptfragile_away');
          if (!state.signalFirstSeen[gid]) state.signalFirstSeen[gid] = Date.now();
          thesis.criteria['3ptfragile_away'] = {met:true, strong:true, label:`${_aD} 3PT Fragile Lead`, detail:`<strong>3PT Shooting:</strong> ${_aD} is shooting ${a3Check.pn.toFixed(0)}% from 3 on ${a3Check.an} attempts (${getLeagueName()} avg: ${getLeague3PtAvg()}%).<br><strong>Lead Composition:</strong> ${aFragileData.pct3.toFixed(0)}% of ${_aD}'s scoring comes from 3PT (threshold: ${getFragile3PtThreshold()}%).<br><strong>Opponent Durability:</strong> ${_hD} has ${aFragileData.oppPaintPct.toFixed(0)}% non-3PT scoring â€” paint-heavy and sustainable.<br><strong>Signal:</strong> Both conditions confirmed â€” the 3PT shooting is unsustainable AND the lead depends on it. When the shooting cools, the lead evaporates.`, value:`${a3Check.pn.toFixed(0)}% 3PT + ${aFragileData.pct3.toFixed(0)}% fragile`};
        } else if (a3Check.isHot && !aFragileData) {
          // Hot shooting but lead not fragile enough â€” informational only
          signals.push({type:'3ptFragile', text:`${_aD} shooting hot: ${a3Check.pn.toFixed(0)}% from 3 (${a3Check.mn}/${a3Check.an}) â€” but lead not fragile enough for full signal.`, level:1});
          thesis.criteria['3ptfragile_away'] = {met:true, strong:false, label:`${_aD} 3PT Hot (no fragile lead)`, detail:`${_aD} is shooting ${a3Check.pn.toFixed(0)}% from 3 on ${a3Check.an} attempts â€” elevated, but the lead composition isn't fragile enough (needs 3PT-heavy lead vs paint-heavy opponent). Monitoring only.`, value:`${a3Check.pn.toFixed(0)}% 3PT`, warn:true};
        } else if (!a3Check.isHot && aFragileData) {
          // Fragile lead but shooting not extreme â€” informational only
          thesis.criteria['3ptfragile_away'] = {met:true, strong:false, label:`${_aD} Fragile Lead (not hot enough)`, detail:`${_aD}'s lead is ${aFragileData.pct3.toFixed(0)}% from 3PT â€” fragile composition detected, but current 3PT shooting rate isn't extreme enough to trigger. Needs 50%+ on 12+ attempts.`, value:`${aFragileData.pct3.toFixed(0)}% fragile`, warn:true};
        } else if (a3Check.isWarm) {
          signals.push({type:'3ptFragile', text:`${_aD} ${a3Check.pn.toFixed(0)}% from 3 (${a3Check.mn}/${a3Check.an}) â€” elevated, watch for increase.`, level:1});
          thesis.criteria['3ptfragile_away'] = {met:false, label:`${_aD} 3PT: ${a3Check.pn.toFixed(0)}%`, detail:`Elevated but no fragile lead. Both conditions needed.`, value:'Watching'};
        } else {
          thesis.criteria['3ptfragile_away'] = {met:false, label:`${_aD} 3PT Fragile`, detail:`No 3PT fragile signal. Normal shooting range and/or no fragile lead composition.`, value:'N/A'};
        }

        // Home team: both hot 3PT AND fragile lead
        if (h3Check.isHot && hFragileData) {
          signals.push({type:'3ptFragile', text:`${_hD} 3PT FRAGILE: shooting ${h3Check.pn.toFixed(0)}% from 3 (${h3Check.mn}/${h3Check.an}) AND lead is ${hFragileData.pct3.toFixed(0)}% 3PT-dependent. ${_aD} scores from paint (${hFragileData.oppPaintPct.toFixed(0)}%). Classic fade.`, level:2});
          sig3Fragile++;
          sendSignalNotification('ðŸ”¥ 3PT Fragile: ' + _hD, hA + ' shooting ' + h3Check.pn.toFixed(0) + '% from 3 AND lead is fragile', gid, '3ptfragile_home');
          if (!state.signalFirstSeen[gid]) state.signalFirstSeen[gid] = Date.now();
          thesis.criteria['3ptfragile_home'] = {met:true, strong:true, label:`${_hD} 3PT Fragile Lead`, detail:`<strong>3PT Shooting:</strong> ${_hD} is shooting ${h3Check.pn.toFixed(0)}% from 3 on ${h3Check.an} attempts (${getLeagueName()} avg: ${getLeague3PtAvg()}%).<br><strong>Lead Composition:</strong> ${hFragileData.pct3.toFixed(0)}% of ${_hD}'s scoring comes from 3PT (threshold: ${getFragile3PtThreshold()}%).<br><strong>Opponent Durability:</strong> ${_aD} has ${hFragileData.oppPaintPct.toFixed(0)}% non-3PT scoring â€” paint-heavy and sustainable.<br><strong>Signal:</strong> Both conditions confirmed â€” the 3PT shooting is unsustainable AND the lead depends on it. When the shooting cools, the lead evaporates.`, value:`${h3Check.pn.toFixed(0)}% 3PT + ${hFragileData.pct3.toFixed(0)}% fragile`};
        } else if (h3Check.isHot && !hFragileData) {
          signals.push({type:'3ptFragile', text:`${_hD} shooting hot: ${h3Check.pn.toFixed(0)}% from 3 (${h3Check.mn}/${h3Check.an}) â€” but lead not fragile enough for full signal.`, level:1});
          thesis.criteria['3ptfragile_home'] = {met:true, strong:false, label:`${_hD} 3PT Hot (no fragile lead)`, detail:`${_hD} is shooting ${h3Check.pn.toFixed(0)}% from 3 on ${h3Check.an} attempts â€” elevated, but the lead composition isn't fragile enough. Monitoring only.`, value:`${h3Check.pn.toFixed(0)}% 3PT`, warn:true};
        } else if (!h3Check.isHot && hFragileData) {
          thesis.criteria['3ptfragile_home'] = {met:true, strong:false, label:`${_hD} Fragile Lead (not hot enough)`, detail:`${_hD}'s lead is ${hFragileData.pct3.toFixed(0)}% from 3PT â€” fragile composition detected, but 3PT shooting rate isn't extreme enough. Needs 50%+ on 12+ attempts.`, value:`${hFragileData.pct3.toFixed(0)}% fragile`, warn:true};
        } else if (h3Check.isWarm) {
          signals.push({type:'3ptFragile', text:`${_hD} ${h3Check.pn.toFixed(0)}% from 3 (${h3Check.mn}/${h3Check.an}) â€” elevated, watch for increase.`, level:1});
          thesis.criteria['3ptfragile_home'] = {met:false, label:`${_hD} 3PT: ${h3Check.pn.toFixed(0)}%`, detail:`Elevated but no fragile lead. Both conditions needed.`, value:'Watching'};
        } else {
          thesis.criteria['3ptfragile_home'] = {met:false, label:`${_hD} 3PT Fragile`, detail:`No 3PT fragile signal. Normal shooting and/or no fragile lead composition.`, value:'N/A'};
        }

        // STAR PACE CHECK (60% threshold)
        const cM = parseFloat(clk?.split(':')[0]||12), cS = parseFloat(clk?.split(':')[1]||0);
        const gMins = getElapsedMinutes(per, clk), gPct = getGamePct(per, clk);
        let starColdTeams = {};
        [...aLeaders,...hLeaders].forEach(leader => {
          const star = state.stars.find(s => leader.name.toLowerCase().includes(s.name.split(' ').pop().toLowerCase()) && s.team===leader.team);
          if (star) {
            const exp = getExpectedByTime(star.ppg, gMins);
            const pr = exp>0 ? leader.pts/exp : 1;
            const side = leader.team===aA?'away':'home';
            const oppSide = side==='away'?'home':'away';
            if (pr<0.6 && gPct>=0.2 && per<=3) {
              let ctx = per===1?` Q1 exp: ${getQ1Expected(star.ppg).toFixed(0)}`:per===2?` Half exp: ${getHalfExpected(star.ppg).toFixed(0)}`:'';
              signals.push({type:'star',text:`${leader.name} ${leader.pts}pts (exp ~${exp.toFixed(0)}, threshold ${(exp*0.6).toFixed(0)}).${ctx} MR candidate.`,level:2});
              sigStar++;
                fireStarColdAlert(leader, star, gMins, per, clk, gLabel, pr);
              sendSignalNotification('â­ Star Cold: ' + leader.name, leader.name + ' only ' + leader.pts + 'pts (exp ~' + exp.toFixed(0) + '). Mean reversion candidate.', gid, 'star_' + leader.team);
              if (!state.signalFirstSeen[gid]) state.signalFirstSeen[gid] = Date.now();
              starColdTeams[leader.team] = leader.name;
              const starTeamFull = leader.team===aA ? aFull : hFull;
              thesis.criteria[`star_${oppSide}`] = {met:true, strong:true, label:`Star Cold: ${leader.name} (${teamDisplay(leader.team, starTeamFull)})`, detail:`<strong>Player:</strong> ${leader.name} â€” averages ${star.ppg} PPG.<br><strong>Current:</strong> ${leader.pts} pts at Q${per} ${clk} (expected ~${exp.toFixed(0)}).<br><strong>Pace:</strong> ${(pr*100).toFixed(0)}% of expected â€” below the 60% threshold.<br><strong>Why it matters:</strong> Star players this far below expected pace tend to regress upward. The live ML hasn't priced in their scoring recovery yet.`, value:`${leader.pts}/${exp.toFixed(0)} pts (${(pr*100).toFixed(0)}%)`};
            } else if (pr<0.75 && gPct>=0.2) {
              const starTeamFull2 = leader.team===aA ? aFull : hFull;
              signals.push({type:'star',text:`${leader.name} (${teamDisplay(leader.team, starTeamFull2)}) ${leader.pts}pts, behind ${star.ppg} PPG pace (exp ~${exp.toFixed(0)})`,level:1});
              thesis.criteria[`star_${oppSide}`] = {met:true, strong:false, label:`Star Below Pace: ${leader.name} (${teamDisplay(leader.team, starTeamFull2)})`, detail:`${leader.name} (${star.ppg} PPG) has ${leader.pts} pts vs ${exp.toFixed(0)} expected. Below pace but not at critical 60% threshold yet.`, value:`${(pr*100).toFixed(0)}% pace`, warn:true};
            }
          }
        });

        // FT INFLATION â€” aFTA and hFTA already parsed above in loop scope

        const ftData = analyzeFTInflation(aFTA, hFTA, aS, hS);
        if (ftData.aInflated) {
          signals.push({type:'ft',text:`${teamDisplay(aA,aFull)} lead is FT-inflated: ${ftData.aFTA} FTA vs ${ftData.hFTA} for ${teamDisplay(hA,hFull)} (${ftData.ftGap} gap). This FT volume will regress.`,level:2});
          sigFT++;
          sendSignalNotification('ðŸ’° FT Inflation: ' + teamDisplay(aA,aFull), aA + ' FT-inflated: ' + ftData.aFTA + ' FTA vs ' + ftData.hFTA + ' (' + ftData.ftGap + ' gap)', gid, 'ft_away');
          if (!state.signalFirstSeen[gid]) state.signalFirstSeen[gid] = Date.now();
          thesis.criteria['ft_away'] = {met:true, strong:true, label:`${teamDisplay(aA,aFull)} FT Inflation`, detail:`<strong>${teamDisplay(aA,aFull)}:</strong> ${ftData.aFTA} free throw attempts.<br><strong>${teamDisplay(hA,hFull)}:</strong> ${ftData.hFTA} free throw attempts.<br><strong>Gap:</strong> ${ftData.ftGap} FTA â€” a significant disparity.<br><strong>Why it matters:</strong> Part of the lead is built on unsustainable free throw volume. FT rates regress to the mean within a game.`, value:`${ftData.ftGap} FTA gap`};
        } else if (ftData.hInflated) {
          signals.push({type:'ft',text:`${teamDisplay(hA,hFull)} lead is FT-inflated: ${ftData.hFTA} FTA vs ${ftData.aFTA} for ${teamDisplay(aA,aFull)} (${ftData.ftGap} gap). This FT volume will regress.`,level:2});
          sigFT++;
          sendSignalNotification('ðŸ’° FT Inflation: ' + teamDisplay(hA,hFull), hA + ' FT-inflated: ' + ftData.hFTA + ' FTA vs ' + ftData.aFTA + ' (' + ftData.ftGap + ' gap)', gid, 'ft_home');
          if (!state.signalFirstSeen[gid]) state.signalFirstSeen[gid] = Date.now();
          thesis.criteria['ft_home'] = {met:true, strong:true, label:`${teamDisplay(hA,hFull)} FT Inflation`, detail:`<strong>${teamDisplay(hA,hFull)}:</strong> ${ftData.hFTA} free throw attempts.<br><strong>${teamDisplay(aA,aFull)}:</strong> ${ftData.aFTA} free throw attempts.<br><strong>Gap:</strong> ${ftData.ftGap} FTA â€” a significant disparity.<br><strong>Why it matters:</strong> Part of the lead is built on unsustainable free throw volume. FT rates regress to the mean within a game.`, value:`${ftData.ftGap} FTA gap`};
        } else {
          thesis.criteria['ft_away'] = {met:false, label:`FT Balance`, detail:`No significant FT disparity between teams.`, value:'Normal'};
        }

        // COMBINED - 2+ of the 3 independent signals on same game = combined edge
        // The 3 independent signals: 3PT Fragile, Star Cold, FT Inflation
        const has3ptFragile=signals.some(s=>s.type==='3ptFragile'&&s.level===2);
        const hasStar=signals.some(s=>s.type==='star'&&s.level===2);
        const hasFT=signals.some(s=>s.type==='ft'&&s.level>=2);
        const activeSignals = [has3ptFragile, hasStar, hasFT].filter(Boolean).length;
        if (activeSignals >= 2) { signalLevel=2; sigCombined++; }
        else if (activeSignals === 1) signalLevel=1;

        // Track which games have which signals for chip click-to-expand
        const _gameInfo = { game: gLabel, gameFull: gLabelFull, aScore: aS, hScore: hS, per, clk, detail, eventId: gid };
        if (has3ptFragile) signalGames['3ptfragile'].push({ ..._gameInfo, sigDetail: signals.filter(s=>s.type==='3ptFragile'&&s.level===2).map(s=>s.text).join('; ') });
        if (hasStar) signalGames['star'].push({ ..._gameInfo, sigDetail: signals.filter(s=>s.type==='star'&&s.level===2).map(s=>s.text).join('; ') });
        if (hasFT) signalGames['ft'].push({ ..._gameInfo, sigDetail: signals.filter(s=>s.type==='ft'&&s.level>=2).map(s=>s.text).join('; ') });
        if (activeSignals >= 2) signalGames['combined'].push({ ..._gameInfo, sigDetail: `${activeSignals} signals active: ${[has3ptFragile?'3PT Fragile':'',hasStar?'Star Cold':'',hasFT?'FT':''].filter(Boolean).join(' + ')}` });

        // Determine bet side and build thesis logic
        if (signalLevel >= 2) {
          // Figure out which team to bet ON (the one that benefits from regression)
          let betTeam = '', fadeTeam = '', reasons = [];
          const a3F = thesis.criteria['3ptfragile_away'], h3F = thesis.criteria['3ptfragile_home'];
          const aFTData = thesis.criteria['ft_away'], hFTData = thesis.criteria['ft_home'];

          // Score each side: who has unsustainable advantages?
          let awayFade=0, homeFade=0;
          if (a3F?.met && a3F?.strong) awayFade++;  // away has 3PT fragile lead = fade away
          if (h3F?.met && h3F?.strong) homeFade++;  // home has 3PT fragile lead = fade home
          if (aFTData?.met && aFTData?.strong) awayFade++;  // away lead FT-inflated
          if (hFTData?.met && hFTData?.strong) homeFade++;  // home lead FT-inflated
          // Star cold on a team = bet ON that team (star will regress up)
          if (starColdTeams[aA]) homeFade++;  // away star cold = away bounces back = fade home
          if (starColdTeams[hA]) awayFade++;  // home star cold = home bounces back = fade away

          if (awayFade > homeFade) { betTeam = hA; fadeTeam = aA; }
          else if (homeFade > awayFade) { betTeam = aA; fadeTeam = hA; }
          else if (awayFade > 0) { betTeam = hA; fadeTeam = aA; }
          else { betTeam = aS < hS ? aA : hA; fadeTeam = aS < hS ? hA : aA; }

          // Build the narrative â€” use full names for clarity
          // NOTE: _aD and _hD already declared above in 3PT Fragile section
          if (a3F?.met && a3F?.strong) reasons.push(`${_aD} has a 3PT Fragile Lead â€” shooting hot from 3 AND lead depends on it (${a3F.value}). Both will regress.`);
          if (h3F?.met && h3F?.strong) reasons.push(`${_hD} has a 3PT Fragile Lead â€” shooting hot from 3 AND lead depends on it (${h3F.value}). Both will regress.`);
          if (starColdTeams[aA]) reasons.push(`${starColdTeams[aA]} (${_aD}) is ice cold â€” star at <60% expected pace, regression likely`);
          if (starColdTeams[hA]) reasons.push(`${starColdTeams[hA]} (${_hD}) is ice cold â€” star at <60% expected pace, regression likely`);
          if (aFTData?.met && aFTData?.strong) reasons.push(`${_aD}'s lead is FT-inflated (${aFTData.value}) â€” this FT volume will regress`);
          if (hFTData?.met && hFTData?.strong) reasons.push(`${_hD}'s lead is FT-inflated (${hFTData.value}) â€” this FT volume will regress`);

          const strongCriteria = Object.values(thesis.criteria).filter(c => c.met && c.strong).length;
          const allCriteria = Object.values(thesis.criteria).filter(c => c.met).length;

          const betTeamFull = betTeam === aA ? aFull : hFull;
          const fadeTeamFull = fadeTeam === aA ? aFull : hFull;
          thesis.betSide = betTeam;
          thesis.betSideFull = betTeamFull;
          thesis.fadeSide = fadeTeam;
          thesis.fadeSideFull = fadeTeamFull;
          thesis.betLogic = reasons.join('. ') + '.';
          thesis.confidence = strongCriteria >= 3 ? 'high' : strongCriteria >= 2 ? 'high' : allCriteria >= 2 ? 'medium' : 'low';
          thesis.strongCount = strongCriteria;
          thesis.totalMet = allCriteria;
          thesis.signals = signals;
          thesis.signalLevel = signalLevel;
          const _tOdds = matchOdds(aA, hA, aFull, hFull);
          let _betML = null, _implP = 0;
          if (_tOdds) {
            _betML = betTeam === aA ? _tOdds.awayML : _tOdds.homeML;
            _implP = _betML < 0 ? Math.abs(_betML)/(Math.abs(_betML)+100) : 100/(_betML+100);
            thesis.marketOdds = _betML;
            thesis.impliedP = _implP;
            const _k = kellySize(_implP, _betML);
            thesis.kellyPct = _k.fStar;
            thesis.kellyBet = _k.bet;
            thesis.kellyEdge = _k.edge;
            thesis.estimatedP = _k.p;
          }
          thesis.eventId = event.id;
          thesis.betTeamAbbr = betTeam;
          if (_tOdds && _betML) {
            autoLogBet(event.id, betTeam, 'ML', signals.filter(x=>x.level===2).map(x=>x.type), _betML, _implP);
          }
          gameTheses.push(thesis);
        }
      }

      const cc = signalLevel===2?'signal-fire':signalLevel===1?'signal-warn':'';
      const hc = isLive?'game-card-header live-pulse':'game-card-header';

      const bar3 = (p,m,a,t) => {
        const v=parseFloat(p)||0, bc=v>=50?'hot':v>=getLeague3PtAvg()?'normal':'cold';
        return `<div class="stat-bar-row"><span class="stat-bar-label">${t} 3PT%</span><div class="stat-bar-track"><div class="stat-bar-fill ${bc}" style="width:${Math.min(v,100)}%">${v.toFixed(0)}%</div><div class="stat-bar-avg" style="left:${getLeague3PtAvg()}%" data-label="${getLeague3PtAvg()}%"></div></div><span class="stat-bar-value">${m||'-'}/${a||'-'}</span></div>`;
      };

      // Durability bars
      let durabilityHTML = '';
      if (isLive && (aS > 0 || hS > 0)) {
        const aDur = analyzeScoringDurability(aA, aS, a3M, hS);
        const hDur = analyzeScoringDurability(hA, hS, h3M, aS);
        const durBar = (team, dur) => {
          if (dur.pct3 <= 0) return '';
          const cls = dur.durability;
          const w = Math.min(dur.pct3, 100);
          const col = dur.fragile ? 'var(--red)' : dur.durable ? 'var(--teal)' : 'var(--blue)';
          return `<div class="durability-bar ${cls}"><span>${team}</span><div class="durability-meter"><div class="durability-meter-fill" style="width:${w}%;background:${col};"></div></div><span>${dur.label}</span></div>`;
        };
        durabilityHTML = durBar(aA, aDur) + durBar(hA, hDur);
      }

      // FT info
      let foulHTML = '';
      if (isLive && (aFTA > 0 || hFTA > 0)) {
        const ftGap = Math.abs(aFTA - hFTA);
        foulHTML = `<div class="stat-bar-row"><span class="stat-bar-label">FTA</span><span style="flex:1;font-size:11px;">${aA}: ${aFTA} | ${hA}: ${hFTA}${ftGap >= 10 ? ' &#x26A0; +'+ftGap+' gap' : ''}</span></div>`;
      }

      const isFav = state.favorites.includes(gid);
      const periodLabel = `Q${per}`;
      const _oddsHTML = buildOddsHTML(aA,hA,aFull,hFull);

      // Signal summary for card header
      const sigSummary = signals.filter(s=>s.level===2).map(s => {
        const icons = {'3pt':'3PT','star':'STAR','fragile':'FRAG','ft':'FT','combined':'COMBO'};
        return icons[s.type] || s.type.toUpperCase();
      });

      cards += `<div class="game-card ${cc}" data-game-id="${gid}">
        <div class="${hc}">
          <span>${isLive ? '<span style="color:var(--red);font-weight:700;">LIVE</span> ' + periodLabel + ' ' + clk : 'UPCOMING'}</span>
          <span style="display:flex;align-items:center;gap:6px;">
            ${sigSummary.length ? '<span style="font-size:9px;font-weight:700;color:var(--accent);background:var(--accent-light);padding:1px 6px;border-radius:3px;">' + sigSummary.join(' + ') + '</span>' : ''}
            <span class="fav-star" onclick="toggleFavorite('${gid}')" style="cursor:pointer;font-size:14px;">${isFav?'\u2605':'\u2606'}</span>
          </span>
        </div>
        <div class="game-card-body">
          <!-- SCOREBOARD -->
          <div class="game-teams">
            <div class="team-block">
              <div class="team-name">${teamDisplayShort(aA, aFull)}</div>
                            <div class="team-record">${aRec}</div>
              <div class="team-score">${isLive?aS:'-'}</div>
            </div>
            <div class="vs-block">
              <div class="vs-text">@</div>
            </div>
            <div class="team-block">
              <div class="team-name">${teamDisplayShort(hA, hFull)}</div>
                            <div class="team-record">${hRec}</div>
              <div class="team-score">${isLive?hS:'-'}</div>
            </div>
          </div>
          <!-- ODDS -->
          ${_oddsHTML}
          <!-- LIVE STATS -->
          ${isLive?`<div class="stat-bars">
            ${bar3(a3P,a3M,a3A,aA)}
            ${bar3(h3P,h3M,h3A,hA)}
            ${foulHTML}
          </div>
          ${durabilityHTML}
          ${aLeaders.length||hLeaders.length?`<div style="display:flex;gap:8px;margin-top:6px;font-size:11px;">
            ${aLeaders.length?`<div style="flex:1;padding:4px 8px;background:var(--bg);border-radius:4px;"><span style="color:var(--text-muted);">${aA}</span> <strong>${aLeaders[0]?.name?.split(' ').pop()}: ${aLeaders[0]?.pts}pts</strong></div>`:''}
            ${hLeaders.length?`<div style="flex:1;padding:4px 8px;background:var(--bg);border-radius:4px;"><span style="color:var(--text-muted);">${hA}</span> <strong>${hLeaders[0]?.name?.split(' ').pop()}: ${hLeaders[0]?.pts}pts</strong></div>`:''}
          </div>`:''}`:''}
          <!-- SIGNALS -->
          ${signals.length?`<div style="margin-top:8px;padding:8px 10px;border-radius:6px;background:${signalLevel===2?'var(--accent-light)':'var(--orange-light)'};border-left:3px solid ${signalLevel===2?'var(--accent)':'var(--orange)'};">
            <div style="font-size:10px;font-weight:800;color:${signalLevel===2?'var(--accent)':'var(--orange)'};margin-bottom:4px;letter-spacing:0.5px;">${signalLevel===2?'EDGE DETECTED':'DEVELOPING'}</div>
            ${signals.map(s=>`<div style="font-size:11px;color:var(--text-secondary);line-height:1.5;">${s.level===2?'&#x1F525;':'&#x26A0;&#xFE0F;'} ${s.text}</div>`).join('')}
            ${state.signalFirstSeen[gid]?`<div style="font-size:9px;color:var(--text-muted);margin-top:4px;">\u23F1 ${Math.floor((Date.now()-state.signalFirstSeen[gid])/60000)}m ago</div>`:''}
          </div>`:''}
        </div>
      </div>`;

      // 3PT TRACKER CARD
      if (isLive) {
        const ap=parseFloat(a3P)||0, hp=parseFloat(h3P)||0;
        const aHot=ap>=50&&parseInt(a3A)>=8, hHot=hp>=50&&parseInt(h3A)>=8;
        const aWarm=ap>=45&&parseInt(a3A)>=6&&!aHot, hWarm=hp>=45&&parseInt(h3A)>=6&&!hHot;
        const cb=(aHot||hHot)?'hot-card':(aWarm||hWarm)?'warm-card':'';
        const qBoxes=(t,p,m,a)=>{const pv=parseFloat(p)||0,mv=parseInt(m)||0,av=parseInt(a)||0;let b='';for(let q=1;q<=4;q++){const act=q===per,past=q<per;if(past||act){const hc2=pv>=50&&av>=8&&act?'hot-q':act?'active-q':'';b+=`<div class="qtr-box ${hc2}"><div class="qtr-label">Q${q}${act?' *':''}</div><div class="qtr-value ${act&&pv>=50?'hot-val':'normal-val'}">${act?pv.toFixed(0)+'%':'-'}</div><div class="qtr-detail">${act?mv+'/'+av:'done'}</div></div>`;}else b+=`<div class="qtr-box"><div class="qtr-label">Q${q}</div><div class="qtr-value normal-val">-</div><div class="qtr-detail">-</div></div>`;}return b;};
        const tRow=(t,p,m,a,hot,warm)=>{const badge=hot?'<span class="signal-badge signal-fire">UNSUSTAINABLE</span>':warm?'<span class="signal-badge signal-moderate">ELEVATED</span>':'<span class="signal-badge signal-none">Normal</span>';return `<div style="margin-bottom:12px;"><div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;"><span style="font-weight:800;font-size:14px;color:var(--navy);">${t}</span>${badge}</div>${bar3(p,m,a,t)}<div class="qtr-grid">${qBoxes(t,p,m,a)}</div></div>`;};
        tpCards+=`<div class="three-pt-card ${cb}"><div class="three-pt-card-header"><span>${gLabel}</span><span>Q${per} ${clk}</span></div><div class="three-pt-card-body">${tRow(aA,a3P,a3M,a3A,aHot,aWarm)}${tRow(hA,h3P,h3M,h3A,hHot,hWarm)}${(aHot||hHot)?`<div style="text-align:center;margin-top:6px;"><button class="btn btn-purple btn-sm" onclick="openLogModal('${gLabel}','3PT Reg','3PT Regression')">Log 3PT Bet</button></div>`:''}</div></div>`;
      }
    }

    grid.innerHTML = cards || `<div class="empty-state" style="grid-column:1/-1;"><p>No games.</p></div>`;
    tpGrid.innerHTML = tpCards || `<div class="empty-state" style="grid-column:1/-1;"><p>No live games.</p></div>`;

    // Signal Priority: Sort gameTheses by strength
    gameTheses.sort((a,b) => (b.strongCount||0) - (a.strongCount||0));

    // Build Quick Bet Action Cards
    const qbPanel = document.getElementById('quick-bet-panel');
    const qbCards = document.getElementById('quick-bet-cards');
    if (gameTheses.length > 0) {
      qbPanel.style.display = 'block';
      qbCards.innerHTML = gameTheses.map(t => {
        const sigs = t.signals.filter(s=>s.level===2).map(s => {
          const badges = {'3pt':'3PT','star':'STAR','fragile':'FRAGILE','ft':'FT'};
          return '<span class="signal-badge badge-' + s.type + '">' + (badges[s.type]||s.type.toUpperCase()) + '</span>';
        }).join(' ');
        const oddsStr = t.marketOdds ? ' @ ' + (t.marketOdds > 0 ? '+' : '') + t.marketOdds : '';
        const kellyStr = t.kellyPct ? ' (Kelly: ' + (t.kellyPct*100).toFixed(1) + '%)' : '';
        const elapsed = state.signalFirstSeen[t.eventId] ? Math.floor((Date.now() - state.signalFirstSeen[t.eventId]) / 60000) : 0;
        const elapsedStr = elapsed > 0 ? ' \u2022 Signal active ' + elapsed + 'm' : ' \u2022 NEW';
        return '<div style="background:var(--card-bg);border:2px solid var(--accent);border-radius:var(--radius);padding:12px 16px;margin-bottom:8px;display:flex;justify-content:space-between;align-items:center;box-shadow:var(--shadow-md);animation:slideUp 0.3s ease">' +
          '<div><div style="font-size:14px;font-weight:700;color:var(--accent)">BET ' + t.betSide + ' ML' + oddsStr + '</div>' +
          '<div style="font-size:11px;color:var(--text-secondary);margin-top:2px">' + t.game + ' \u2022 Q' + (t.per||'?') + ' ' + (t.clk||'') + kellyStr + elapsedStr + '</div>' +
          '<div style="margin-top:4px">' + sigs + '</div></div>' +
          '<div style="text-align:right"><div style="font-size:20px;font-weight:800;color:var(--accent)">' + (t.strongCount||0) + '</div><div style="font-size:9px;color:var(--text-muted)">SIGNALS</div></div></div>';
      }).join('');
    } else {
      qbPanel.style.display = 'none';
      qbCards.innerHTML = '';
    }

    // Record signal history
    gameTheses.forEach(t => {
      const histKey = t.eventId + '_' + (t.betSide||'');
      const existing = state.signalHistory.find(h => h.key === histKey);
      if (!existing) {
        state.signalHistory.push({
          key: histKey, game: t.game||'', betSide: t.betSide||'', signals: (t.signals||[]).filter(s=>s.level===2).map(s=>s.type),
          strongCount: t.strongCount||0, confidence: t.confidence||'', odds: t.marketOdds||0,
          timestamp: Date.now(), date: new Date().toLocaleDateString()
        });
        if (state.signalHistory.length > 200) state.signalHistory = state.signalHistory.slice(-150);
        localStorage.setItem('signalHistory', JSON.stringify(state.signalHistory));
      }
    });

    // Update counts
    document.getElementById('live-3ptfragile-signals').textContent = sig3Fragile;
    document.getElementById('live-star-signals').textContent = sigStar;
    document.getElementById('live-ft-signals').textContent = sigFT;
    document.getElementById('live-combined-signals').textContent = sigCombined;
    // Glow effect on combined chip when 2+ signals fire
    const combinedChip = document.getElementById('live-combined-signals').closest('.signal-chip');
    if (sigCombined > 0) { combinedChip.classList.add('combined-active'); } else { combinedChip.classList.remove('combined-active'); }
    document.getElementById('threept-hot-count').textContent = hotTeams;
    document.getElementById('threept-warm-count').textContent = warmTeams;

    const totalSigs = sig3Fragile+sigStar+sigFT;
    if (totalSigs>0) { document.getElementById('live-badge').style.display='inline'; document.getElementById('live-badge').textContent=totalSigs; }
    else document.getElementById('live-badge').style.display='none';
    if (hotTeams>0) { document.getElementById('threept-badge').style.display='inline'; document.getElementById('threept-badge').textContent=hotTeams; }

    // EDGE THESIS PANEL
    const etc = document.getElementById('edgeThesisContainer');
    const etCards = document.getElementById('edgeThesisCards');
    if (gameTheses.length > 0) {
      etc.classList.add('active');
      document.getElementById('thesisCount').textContent = gameTheses.length + ' LIVE';
      // Sort by confidence (high first)
      gameTheses.sort((a,b) => (b.strongCount||0) - (a.strongCount||0));
      etCards.innerHTML = gameTheses.map(t => {
        const confDots = Array.from({length:5}, (_,i) => {
          if (i < t.strongCount) return `<div class="conf-dot lit-red"></div>`;
          if (i < t.totalMet) return `<div class="conf-dot lit"></div>`;
          return `<div class="conf-dot"></div>`;
        }).join('');
        const confCls = t.confidence==='high'?'high':t.confidence==='medium'?'medium':'low';
        const scoreDiff = Math.abs(t.aScore - t.hScore);
        const leading = t.aScore > t.hScore ? teamDisplay(t.aTeam, t.aTeamFull) : t.hScore > t.aScore ? teamDisplay(t.hTeam, t.hTeamFull) : 'TIE';
        const trailing = t.aScore > t.hScore ? teamDisplay(t.hTeam, t.hTeamFull) : t.hScore > t.aScore ? teamDisplay(t.aTeam, t.aTeamFull) : '';

        // Build criteria cards
        const criteriaKeys = ['3ptfragile_away','3ptfragile_home','star_away','star_home','ft_away','ft_home'];
        const criteriaHTML = criteriaKeys.map(k => {
          const c = t.criteria[k];
          if (!c) return '';
          const cls = c.met ? (c.strong ? 'met' : 'met') : 'not-met';
          const icon = c.met ? (c.strong ? '&#x1F525;' : '&#x26A0;&#xFE0F;') : '&#x2796;';
          const valCls = c.met ? (c.strong ? '' : 'warn') : 'neg';
          return `<div class="criteria-item ${cls}">
            <span class="criteria-check">${icon}</span>
            <div class="criteria-text">
              <span class="criteria-label">${c.label}</span>
              <span class="criteria-value ${valCls}">${c.value}</span>
              <span class="criteria-detail">${c.detail}</span>
            </div>
          </div>`;
        }).filter(Boolean).join('');

        const betSideDisplay = teamDisplay(t.betSide, t.betSideFull);
        const fadeSideDisplay = teamDisplay(t.fadeSide, t.fadeSideFull);
        const aTeamDisplay = teamDisplay(t.aTeam, t.aTeamFull);
        const hTeamDisplay = teamDisplay(t.hTeam, t.hTeamFull);

        return `<div class="thesis-card">
          <div class="thesis-game-bar">
            <div>
              <div class="thesis-game-label">${t.gameFull || t.game}</div>
              <div class="thesis-game-period">Q${t.per} ${t.clk} ${leading!=='TIE'?`| ${leading} leads by ${scoreDiff}`:'| Tied'}</div>
            </div>
            <div class="thesis-confidence">
              <div class="conf-meter">${confDots}</div>
              <span class="conf-label ${confCls}">${t.totalMet} criteria met</span>
            </div>
          </div>
          <div class="thesis-body">
            <div class="thesis-bet-line">
              <div>
                <div class="thesis-bet-action">BET ${betSideDisplay} ML ${t.marketOdds ? "(" + (t.marketOdds > 0 ? "+" : "") + t.marketOdds + ")" : ""}</div>${t.kellyPct ? '<div style="color:#4ade80;font-size:12px;margin-top:4px"><strong>KELLY:</strong> ' + t.kellyPct + '% of bankroll ($' + t.kellyBet + ') &bull; <strong>Our P:</strong> ' + t.estimatedP + '% vs <strong>Market:</strong> ' + (t.impliedP * 100).toFixed(1) + '%</div>' : ""}
                <div class="thesis-bet-side">Fade ${fadeSideDisplay} â€” ${t.confidence.toUpperCase()} confidence</div>
              </div>
              <button class="btn btn-orange btn-sm" onclick="openLogModal('${t.game}','Live ML','Mean Reversion')">Log This Bet</button>
            </div>
            <div class="thesis-logic">
              <div class="thesis-logic-title">Why This Is an Edge</div>
              <div class="thesis-logic-text" style="line-height:1.7;">
                <div style="margin-bottom:6px;">${t.betLogic}</div>
                <div style="padding:8px 10px;background:var(--accent-light);border-radius:6px;border-left:3px solid var(--accent);margin-top:6px;font-size:11px;line-height:1.6;">
                  <strong>The Thesis:</strong> The live ML is priced on the current score, but the score is built on unsustainable conditions. When those conditions normalize, the true probability shifts toward <strong>${betSideDisplay}</strong>. The market is slow to reprice these temporary swings â€” that's the edge.
                </div>
              </div>
            </div>
            <div class="thesis-criteria">${criteriaHTML}</div>
            <div class="thesis-actions">
              <span style="font-size:10px;color:#666;">${aTeamDisplay} ${t.aScore} - ${t.hScore} ${hTeamDisplay} | ${t.detail}</span>
              <button class="btn btn-green btn-sm" onclick="openLogModal('${t.game}','Live ML','Mean Reversion')">Log Bet</button>
            </div>
          </div>
        </div>`;
      }).join('');
    } else { etc.classList.remove('active'); etCards.innerHTML = ''; }

    // Store signal games globally for chip click-to-expand
    window._signalGames = signalGames;

    updateStarTracker(events);
        renderBetLog();
        updateBacktestPanel();
        updateKelly();
        autoResolveBets(); // Check for final scores and auto-mark W/L


  } catch (err) {
    setConnStatus('error');
    if (state.consecutiveErrors < 3) {
      grid.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><p style="color:var(--orange);">Connection issue (${err.message}). Retrying next cycle...</p></div>`;
    } else {
      grid.innerHTML = `<div class="empty-state" style="grid-column:1/-1;"><p style="color:var(--red);">Connection failed ${state.consecutiveErrors}x. ESPN may be rate-limiting. Wait 30s then try again.</p></div>`;
    }
  }
}

// ==================== STAR TRACKER ====================
function updateStarTracker(events) {
  const tb = document.getElementById('live-star-status');
  let rows = '';
  for (const ev of events) {
    if (ev.status?.type?.state !== 'in') continue;
    const comp = ev.competitions?.[0]; if (!comp) continue;
    const per=ev.status?.period||1, clk=ev.status?.displayClock||'12:00';
    const cM=parseFloat(clk?.split(':')[0]||12), cS=parseFloat(clk?.split(':')[1]||0);
    const gMins=getElapsedMinutes(per, clk), gPct=getGamePct(per, clk);
    for (const team of (comp.competitors||[])) {
      const tA=team.team?.abbreviation||'';
      const aT=comp.competitors?.find(c=>c.homeAway==='away'), hT=comp.competitors?.find(c=>c.homeAway==='home');
      const gl=`${aT?.team?.abbreviation||''} @ ${hT?.team?.abbreviation||''}`;
      for (const cat of (team.leaders||[])) {
        if (cat.name!=='points') continue;
        for (const l of (cat.leaders||[])) {
          const nm=l.athlete?.shortName||l.athlete?.displayName||'';
          const pts=parseFloat(l.value)||0;
          const star=state.stars.find(s=>nm.toLowerCase().includes(s.name.split(' ').pop().toLowerCase())&&s.team===tA);
          if (!star) continue;
          const exp=getExpectedByTime(star.ppg,gMins), pr=exp>0?(pts/exp*100):100;
          const q1E=getQ1Expected(star.ppg), hE=getHalfExpected(star.ppg);
          let q1T='-';
          if (per>=2) q1T=`${q1E.toFixed(1)} exp`;
          else if (per===1) { const p=q1E>0?(pts/q1E*100):100; q1T=`<span style="color:${p<60?'var(--red)':p<80?'var(--orange)':'var(--green)'};font-weight:700;">${p.toFixed(0)}%</span> of ${q1E.toFixed(1)}`; }
          let hT2='-';
          if (per>=3) hT2=`${hE.toFixed(1)} exp`;
          else if (per===2||(per===1&&gMins>0)) { const p=hE>0?(pts/hE*100):100; hT2=`<span style="color:${p<60?'var(--red)':p<80?'var(--orange)':'var(--green)'};font-weight:700;">${p.toFixed(0)}%</span> of ${hE.toFixed(1)}`; }
          const fc=pr<60?'var(--red)':pr<80?'var(--orange)':'var(--green)';
          const sig=pr<60&&gPct>=0.2&&per<=3?'<span class="signal-badge signal-fire">COLD - BET</span>':pr<75?'<span class="signal-badge signal-moderate">Below Pace</span>':'<span class="signal-badge signal-none">On Pace</span>';
          rows+=`<tr class="star-row"><td><strong>${nm}</strong><br><span style="font-size:9px;color:var(--gray);">${star.ppg} PPG</span></td><td>${gl}</td><td style="font-size:16px;font-weight:800;">${pts}</td><td>${q1T}</td><td>${hT2}</td><td><div class="pace-indicator"><div class="pace-fill" style="width:${Math.min(pr,100)}%;background:${fc};"></div></div> ${pr.toFixed(0)}%</td><td>Q${per} ${clk}</td><td>${sig}</td></tr>`;
        }
      }
    }
  }
  tb.innerHTML = rows || '<tr><td colspan="8" class="empty-state">No tracked stars in live games.</td></tr>';
}

// ==================== STAR DB ====================
function renderStarDB() {
  const tb = document.getElementById('star-db-body');
  tb.innerHTML = state.stars.map((s,i) => {
    const q1=getQ1Expected(s.ppg), h=getHalfExpected(s.ppg);
    return `<tr><td><strong>${s.name}</strong></td><td>${s.team}</td><td>${s.ppg}</td><td>${q1.toFixed(1)}</td><td>${h.toFixed(1)}</td><td>&lt;${(q1*0.6).toFixed(0)} Q1, &lt;${(h*0.6).toFixed(0)} half</td><td><button class="btn btn-red btn-sm" onclick="removeStar(${i})">X</button></td></tr>`;
  }).join('');
}
function addStar() {
  const n=document.getElementById('add-star-name').value.trim(), t=document.getElementById('add-star-team').value.trim().toUpperCase(), p=parseFloat(document.getElementById('add-star-ppg').value);
  if (!n||!t||isNaN(p)) { alert('Fill all fields'); return; }
  state.stars.push({name:n,team:t,ppg:p}); localStorage.setItem('starPlayers',JSON.stringify(state.stars)); renderStarDB();
  document.getElementById('add-star-name').value=''; document.getElementById('add-star-team').value=''; document.getElementById('add-star-ppg').value='';
}
function removeStar(i) { state.stars.splice(i,1); localStorage.setItem('starPlayers',JSON.stringify(state.stars)); renderStarDB(); }

// ==================== BET LOG ====================
function openLogModal(g,p,s) { document.getElementById('modal-game').value=g; document.getElementById('modal-price').value=p; document.getElementById('modal-strategy').value=s; document.getElementById('modal-side').value=''; document.getElementById('modal-notes').value=''; document.getElementById('logModal').classList.add('active'); }
function closeModal() { document.getElementById('logModal').classList.remove('active'); }
function confirmLogBet() {
  state.betLog.push({date:new Date().toLocaleDateString(),strategy:document.getElementById('modal-strategy').value,game:document.getElementById('modal-game').value,side:document.getElementById('modal-side').value,price:document.getElementById('modal-price').value,units:parseFloat(document.getElementById('modal-units').value),result:'Pending',profit:0,notes:document.getElementById('modal-notes').value,id:Date.now()});
  localStorage.setItem('betLog',JSON.stringify(state.betLog)); renderBetLog(); closeModal();
}
function getEdgeBonus(signalCount) {
  const mode = document.getElementById('edge-mode') ? document.getElementById('edge-mode').value : 'moderate';
  if (mode === 'backtest') {
    const d = getBacktestData();
    if (d.total >= 10) return Math.max(0.01, Math.min(0.10, d.edge));
    return 0.03;
  }
  const sc = signalCount || 1;
  const base = mode === 'conservative' ? 0.02 : mode === 'aggressive' ? 0.06 : 0.035;
  const bonus = Math.min(sc - 1, 3) * 0.01;
  return Math.min(base + bonus, 0.08);
}

function kellySize(impliedP, odds, fraction, signalCount) {
  if (!fraction) {
    const sel = document.getElementById('kelly-fraction');
    fraction = sel ? parseFloat(sel.value) : 0.5;
  }
  const bankroll = parseFloat((document.getElementById('bankroll-input')||{}).value) || 1000;
  const edge = getEdgeBonus(signalCount);
  const p = Math.min(0.90, impliedP + edge);
  const q = 1 - p;
  const b = odds > 0 ? odds / 100 : 100 / Math.abs(odds);
  let fStar = (b * p - q) / b;
  if (fStar < 0) fStar = 0;
  fStar = fStar * fraction;
  if (fStar > 0.05) fStar = 0.05;
  if (fStar > 0 && fStar < 0.005) fStar = 0.005;
  const bet = Math.max(0, Math.round(bankroll * fStar));
  return { bet, fStar: Math.round(fStar * 1000) / 10, p: Math.round(p * 1000) / 10, edge: Math.round(edge * 1000) / 10, fraction, bankroll };
}

function autoLogBet(gameId, team, side, signals, marketOdds, impliedP) {
  let log = JSON.parse(localStorage.getItem('betLog') || '[]');
  const key = gameId + '_' + team;
  if (log.find(x => x.key === key)) return;
  const k = kellySize(impliedP, marketOdds);
  log.push({
    id: Date.now(),
    key: key,
    gameId: gameId,
    team: team,
    side: side,
    signals: signals.map(s => typeof s === 'object' ? s.type : s),
    marketOdds: marketOdds,
    impliedP: Math.round(impliedP * 1000) / 10,
    estimatedP: k.p,
    kellyPct: k.fStar,
    kellyBet: k.bet,
    timestamp: new Date().toISOString(),
    outcome: null,
    payout: null,
    mode: currentMode || 'nba'
  });
  localStorage.setItem('betLog', JSON.stringify(log));
}

// ==================== AUTO-RESOLVE BETS FROM ESPN FINAL SCORES ====================
async function autoResolveBets() {
  let log = JSON.parse(localStorage.getItem('betLog') || '[]');
  const pending = log.filter(b => !b.outcome && b.gameId);
  if (pending.length === 0) return;

  try {
    // Fetch scoreboard â€” it includes completed games from today
    const url = getESPNUrl();
    const resp = await fetch(url);
    if (!resp.ok) return;
    const data = await resp.json();
    const events = data.events || [];

    let changed = false;
    pending.forEach(bet => {
      // Find the matching game by gameId
      const event = events.find(e => e.id === bet.gameId || e.id === String(bet.gameId));
      if (!event) return;

      // Only resolve if game is FINAL
      const gameState = event.status?.type?.state;
      if (gameState !== 'post') return;

      const comp = event.competitions?.[0];
      if (!comp) return;
      const away = comp.competitors?.find(c => c.homeAway === 'away');
      const home = comp.competitors?.find(c => c.homeAway === 'home');
      if (!away || !home) return;

      const aScore = parseInt(away.score) || 0;
      const hScore = parseInt(home.score) || 0;
      const aAbbr = away.team?.abbreviation || '';
      const hAbbr = home.team?.abbreviation || '';

      // Determine winner abbreviation
      const winner = aScore > hScore ? aAbbr : hAbbr;

      // Check if our bet team won
      // bet.team could be abbreviation like "BOS" or display name
      const betTeamUpper = bet.team.toUpperCase();
      const betWon = betTeamUpper === winner.toUpperCase() ||
                     winner.toUpperCase().includes(betTeamUpper) ||
                     betTeamUpper.includes(winner.toUpperCase());

      bet.outcome = betWon ? 'W' : 'L';
      bet.finalScore = aAbbr + ' ' + aScore + ' - ' + hScore + ' ' + hAbbr;

      if (betWon) {
        const odds = bet.marketOdds;
        const multiplier = odds > 0 ? odds / 100 : 100 / Math.abs(odds);
        bet.payout = Math.round(bet.kellyBet * multiplier * 100) / 100;
      } else {
        bet.payout = -bet.kellyBet;
      }

      changed = true;
    });

    if (changed) {
      localStorage.setItem('betLog', JSON.stringify(log));
      renderBetLog();
      updateBacktestPanel();
    }
  } catch (e) {
    console.warn('Auto-resolve error:', e);
  }
}

function markOutcome(id, won) {
  let log = JSON.parse(localStorage.getItem('betLog') || '[]');
  const entry = log.find(x => x.id === id);
  if (!entry) return;
  entry.outcome = won ? 'W' : 'L';
  if (won) {
    const b = entry.marketOdds > 0 ? entry.marketOdds / 100 : 100 / Math.abs(entry.marketOdds);
    entry.payout = Math.round(entry.kellyBet * b * 100) / 100;
  } else {
    entry.payout = -entry.kellyBet;
  }
  localStorage.setItem('betLog', JSON.stringify(log));
  renderBetLog();
  updateBacktestPanel();
}

function getBacktestData() {
  const log = JSON.parse(localStorage.getItem('betLog') || '[]');
  const settled = log.filter(x => x.outcome);
  const total = settled.length;
  const wins = settled.filter(x => x.outcome === 'W').length;
  const winRate = total > 0 ? Math.round(wins / total * 1000) / 10 : 0;
  const totalPayout = settled.reduce((s, x) => s + (x.payout || 0), 0);
  const totalRisked = settled.reduce((s, x) => s + x.kellyBet, 0);
  const roi = totalRisked > 0 ? Math.round(totalPayout / totalRisked * 1000) / 10 : 0;
  const avgEdge = total > 0 ? Math.round(settled.reduce((s, x) => s + (x.estimatedP - x.impliedP), 0) / total * 10) / 10 : 0;
  const units = Math.round(totalPayout / 100 * 100) / 100;
  const bySignal = {};
  settled.forEach(x => {
    (x.signals || []).forEach(sig => {
      if (!bySignal[sig]) bySignal[sig] = { total: 0, wins: 0, payout: 0 };
      bySignal[sig].total++;
      if (x.outcome === 'W') bySignal[sig].wins++;
      bySignal[sig].payout += (x.payout || 0);
    });
  });
  return { total, wins, winRate, roi, edge: avgEdge / 100, units, bySignal };
}

function renderBetLog() {
  const el = document.getElementById('bet-log-entries');
  if (!el) return;
  const log = JSON.parse(localStorage.getItem('betLog') || '[]').slice().reverse();
  if (log.length === 0) {
    el.innerHTML = '<p style="color:var(--text-muted);text-align:center;padding:40px;font-size:13px">No bets logged yet. Bets are auto-logged when combined signals fire.</p>';
    return;
  }
  const thS = 'padding:10px 12px;font-size:10px;font-weight:700;text-transform:uppercase;letter-spacing:1px;color:var(--text-muted);border-bottom:2px solid var(--border)';
  let html = '<table style="width:100%;border-collapse:collapse;font-size:12px"><thead><tr>';
  html += '<th style="' + thS + ';text-align:left">TIME</th>';
  html += '<th style="' + thS + ';text-align:left">TEAM</th>';
  html += '<th style="' + thS + ';text-align:left">SIGNALS</th>';
  html += '<th style="' + thS + ';text-align:right">ODDS</th>';
  html += '<th style="' + thS + ';text-align:right">EDGE</th>';
  html += '<th style="' + thS + ';text-align:right">KELLY</th>';
  html += '<th style="' + thS + ';text-align:right">SIZE</th>';
  html += '<th style="' + thS + ';text-align:center">RESULT</th>';
  html += '<th style="' + thS + ';text-align:right">P/L</th>';
  html += '</tr></thead><tbody>';
  log.forEach(b => {
    const t = new Date(b.timestamp);
    const time = (t.getMonth()+1) + '/' + t.getDate() + ' ' + t.getHours() + ':' + String(t.getMinutes()).padStart(2,'0');
    const oddsStr = b.marketOdds > 0 ? '+' + b.marketOdds : '' + b.marketOdds;
    const edgeVal = b.estimatedP && b.impliedP ? (b.estimatedP - b.impliedP).toFixed(1) + '%' : '-';
    let resultCell;
    if (b.outcome) {
      const color = b.outcome === 'W' ? 'var(--green)' : 'var(--red)';
      const bg = b.outcome === 'W' ? 'var(--green-light)' : 'var(--red-light)';
      resultCell = '<span style="color:' + color + ';background:' + bg + ';font-weight:700;padding:2px 10px;border-radius:4px;font-size:11px">' + b.outcome + '</span>';
      if (b.finalScore) resultCell += '<div style="font-size:9px;color:var(--text-muted);margin-top:2px">' + b.finalScore + '</div>';
    } else {
      resultCell = '<span style="font-size:10px;color:var(--orange);font-weight:600">PENDING</span>';
      resultCell += '<div style="margin-top:3px"><button onclick="markOutcome(' + b.id + ',true)" style="background:var(--green-light);color:var(--green);border:none;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:10px;font-weight:700;margin-right:3px">W</button>';
      resultCell += '<button onclick="markOutcome(' + b.id + ',false)" style="background:var(--red-light);color:var(--red);border:none;padding:2px 8px;border-radius:4px;cursor:pointer;font-size:10px;font-weight:700">L</button></div>';
    }
    const plStr = b.payout != null ? (b.payout >= 0 ? '+$' : '-$') + Math.abs(b.payout).toFixed(0) : '-';
    const plColor = b.payout > 0 ? 'var(--green)' : b.payout < 0 ? 'var(--red)' : 'var(--text-muted)';
    const sigBadges = (b.signals||[]).map(s => '<span class="signal-badge badge-' + s + '" style="font-size:9px;padding:1px 6px">' + s.toUpperCase() + '</span>').join(' ');
    html += '<tr style="border-bottom:1px solid var(--border-light)">';
    html += '<td style="padding:10px 12px;color:var(--text-muted);font-size:11px">' + time + '</td>';
    html += '<td style="padding:10px 12px;color:var(--text-primary);font-weight:700">' + b.team + ' <span style="color:var(--text-muted);font-weight:400">' + (b.side||'ML') + '</span></td>';
    html += '<td style="padding:10px 12px">' + sigBadges + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-secondary);font-family:monospace">' + oddsStr + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--accent);font-weight:600">' + edgeVal + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-secondary)">' + b.kellyPct + '%</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-primary);font-weight:700">$' + b.kellyBet + '</td>';
    html += '<td style="padding:10px 12px;text-align:center">' + resultCell + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:' + plColor + ';font-weight:700">' + plStr + '</td>';
    html += '</tr>';
  });
  html += '</tbody></table>';
  el.innerHTML = html;
}

function updateBacktestPanel() {
  const d = getBacktestData();
  const btTotal = document.getElementById('bt-total');
  if (!btTotal) return;
  btTotal.textContent = d.total;
  const wrEl = document.getElementById('bt-winrate');
  wrEl.textContent = d.total > 0 ? d.winRate + '%' : '-';
  wrEl.style.color = d.winRate >= 55 ? 'var(--green)' : d.winRate >= 45 ? 'var(--orange)' : 'var(--red)';
  const roiEl = document.getElementById('bt-roi');
  roiEl.textContent = d.total > 0 ? (d.roi >= 0 ? '+' : '') + d.roi + '%' : '-';
  roiEl.style.color = d.roi > 0 ? 'var(--green)' : d.roi < 0 ? 'var(--red)' : 'var(--text-primary)';
  document.getElementById('bt-edge').textContent = d.total > 0 ? (d.edge * 100).toFixed(1) + '%' : '-';
  const unitsEl = document.getElementById('bt-units');
  unitsEl.textContent = (d.units >= 0 ? '+' : '') + d.units.toFixed(2);
  unitsEl.style.color = d.units > 0 ? 'var(--green)' : d.units < 0 ? 'var(--red)' : 'var(--text-primary)';
  const bd = document.getElementById('signal-breakdown');
  if (!bd) return;
  const sigs = Object.keys(d.bySignal);
  if (sigs.length === 0) { bd.innerHTML = ''; return; }
  let html = '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:10px">';
  sigs.forEach(sig => {
    const sd = d.bySignal[sig];
    const wr = sd.total > 0 ? Math.round(sd.wins / sd.total * 100) : 0;
    const wrColor = wr >= 55 ? 'var(--green)' : wr >= 45 ? 'var(--orange)' : 'var(--red)';
    html += '<div class="stat-card" style="padding:12px"><div style="margin-bottom:6px"><span class="signal-badge badge-' + sig + '" style="font-size:10px">' + sig.toUpperCase() + '</span></div>';
    html += '<div style="color:' + wrColor + ';font-size:20px;font-weight:800">' + wr + '%</div>';
    html += '<div style="color:var(--text-muted);font-size:11px;margin-top:2px">' + sd.wins + 'W-' + (sd.total - sd.wins) + 'L | $' + Math.round(sd.payout) + '</div></div>';
  });
  html += '</div>';
  bd.innerHTML = html;
}

function updateKelly() {
  const el = document.getElementById('kelly-recs');
  if (!el) return;
  if (typeof gameTheses === 'undefined' || !gameTheses || gameTheses.length === 0) {
    el.innerHTML = '<p style="color:var(--text-muted);text-align:center;padding:30px;font-size:13px">Refresh games to see Kelly-sized recommendations</p>';
    return;
  }
  const recs = gameTheses.filter(t => t.marketOdds && t.kellyPct > 0);
  if (recs.length === 0) {
    el.innerHTML = '<p style="color:var(--text-muted);text-align:center;padding:30px;font-size:13px">No positive-edge bets found in current games</p>';
    return;
  }
  const thS = 'padding:10px 12px;font-size:10px;font-weight:700;text-transform:uppercase;letter-spacing:1px;color:var(--text-muted);border-bottom:2px solid var(--border)';
  let html = '<table style="width:100%;border-collapse:collapse;font-size:13px"><thead><tr>';
  html += '<th style="' + thS + ';text-align:left">GAME</th>';
  html += '<th style="' + thS + ';text-align:left">BET</th>';
  html += '<th style="' + thS + ';text-align:right">ODDS</th>';
  html += '<th style="' + thS + ';text-align:right">EDGE</th>';
  html += '<th style="' + thS + ';text-align:right">KELLY %</th>';
  html += '<th style="' + thS + ';text-align:right">BET SIZE</th>';
  html += '</tr></thead><tbody>';
  recs.forEach(t => {
    const oddsStr = t.marketOdds > 0 ? '+' + t.marketOdds : '' + t.marketOdds;
    const sigs = (t.signals||[]).filter(s=>s.level===2).map(s => '<span class="signal-badge badge-' + s.type + '" style="font-size:9px;padding:1px 6px">' + s.type.toUpperCase() + '</span>').join(' ');
    html += '<tr style="border-bottom:1px solid var(--border-light)">';
    html += '<td style="padding:10px 12px;color:var(--text-primary);font-weight:600">' + (t.game||t.betSide) + '</td>';
    html += '<td style="padding:10px 12px"><span style="color:var(--accent);font-weight:700">' + t.betSide + ' ML</span> ' + sigs + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-secondary);font-family:monospace">' + oddsStr + '</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--accent);font-weight:600">' + (t.kellyEdge||t.edge||'-') + '%</td>';
    html += '<td style="padding:10px 12px;text-align:right;color:var(--text-primary);font-weight:700">' + t.kellyPct + '%</td>';
    html += '<td style="padding:10px 12px;text-align:right"><span style="background:var(--accent-light);color:var(--accent);font-weight:800;padding:4px 12px;border-radius:6px;font-size:13px">$' + t.kellyBet + '</span></td>';
    html += '</tr>';
  });
  html += '</tbody></table>';
  el.innerHTML = html;
}

function saveBankrollSettings() {
  localStorage.setItem('bankrollSettings', JSON.stringify({
    bankroll: document.getElementById('bankroll-input').value,
    fraction: document.getElementById('kelly-fraction').value,
    edgeMode: document.getElementById('edge-mode').value
  }));
  updateKelly();
    renderStarDB();
}

function loadBankrollSettings() {
  const saved = JSON.parse(localStorage.getItem('bankrollSettings') || 'null');
  if (!saved) return;
  const bi = document.getElementById('bankroll-input');
  if (bi) bi.value = saved.bankroll || 1000;
  const kf = document.getElementById('kelly-fraction');
  if (kf) kf.value = saved.fraction || '0.5';
  const em = document.getElementById('edge-mode');
  if (em) em.value = saved.edgeMode || 'moderate';
}

function exportBetLog() {
  const log = JSON.parse(localStorage.getItem('betLog') || '[]');
  if (log.length === 0) { alert('No bets to export'); return; }
  let csv = 'Timestamp,Team,Side,Signals,MarketOdds,ImpliedP,EstimatedP,KellyPct,BetSize,Outcome,PL\n';
  log.forEach(b => {
    csv += b.timestamp + ',' + b.team + ',' + b.side + ',"' + (b.signals||[]).join(';') + '",' + b.marketOdds + ',' + b.impliedP + ',' + b.estimatedP + ',' + b.kellyPct + ',' + b.kellyBet + ',' + (b.outcome||'') + ',' + (b.payout||0) + '\n';
  });
  const blob = new Blob([csv], {type:'text/csv'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'bet_log_' + new Date().toISOString().slice(0,10) + '.csv';
  a.click();
}

function clearBetLog() {
  localStorage.removeItem('betLog');
  renderBetLog();
  updateBacktestPanel();
}
function resolveBet(id,r) {
  const b=state.betLog.find(x=>x.id===id); if(!b) return; b.result=r;
  if(r==='W'){const p=parseInt(b.price)||-110; b.profit=p>0?b.units*(p/100):b.units*(100/Math.abs(p));}
  else if(r==='L') b.profit=-b.units; else b.profit=0;
  localStorage.setItem('betLog',JSON.stringify(state.betLog)); renderBetLog();
}
function updateLogStats() {
  const r=state.betLog.filter(b=>b.result!=='Pending'), w=r.filter(b=>b.result==='W').length, t=r.length;
  const nu=r.reduce((s,b)=>s+b.profit,0), tr=r.reduce((s,b)=>s+b.units,0);
  document.getElementById('log-total').textContent=state.betLog.length;
  document.getElementById('log-winrate').textContent=t>0?(w/t*100).toFixed(1)+'%':'-';
  document.getElementById('log-net-units').textContent=(nu>=0?'+':'')+nu.toFixed(2);
  document.getElementById('log-net-units').className=`stat-value ${nu>=0?'green':'red'}`;
  document.getElementById('log-roi').textContent=tr>0?(nu/tr*100).toFixed(1)+'%':'-';
  let streak=0,st='';
  for(let i=r.length-1;i>=0;i--){if(i===r.length-1){st=r[i].result;streak=1;}else if(r[i].result===st)streak++;else break;}
  const se=document.getElementById('log-streak');
  if(streak>0){se.textContent=streak+st;se.className=`stat-value ${st==='W'?'green':st==='L'?'red':''}`;}else se.textContent='-';
}
function clearLog(){if(confirm('Clear ALL?')){state.betLog=[];localStorage.setItem('betLog','[]');renderBetLog();}}
function exportLog(){
  if(!state.betLog.length){alert('No bets');return;}
  const h='Date,Strategy,Game,Side,Price,Units,Result,Profit,Notes\n';
  const r=state.betLog.map(b=>`${b.date},${b.strategy},"${b.game}",${b.side},${b.price},${b.units},${b.result},${b.profit.toFixed(2)},"${b.notes}"`).join('\n');
  const a=document.createElement('a');a.href=URL.createObjectURL(new Blob([h+r],{type:'text/csv'}));a.download=`NBA_Edge_${new Date().toISOString().slice(0,10)}.csv`;a.click();
}

// ==================== BANKROLL ====================
function updateBankroll() {
  const s=parseFloat(document.getElementById('bankroll-start').value)||0, c=parseFloat(document.getElementById('bankroll-current').value)||0;
  state.bankroll={start:s,current:c}; localStorage.setItem('bankroll',JSON.stringify(state.bankroll));
  const u=c*0.01;
  document.getElementById('br-unit').textContent=u>0?'$'+u.toFixed(0):'-';
  document.getElementById('br-max').textContent=u>0?'$'+(u*2).toFixed(0):'-';
  document.getElementById('br-daily').textContent=u>0?'$'+(u*5).toFixed(0):'-';
  const pl=c-s;
  document.getElementById('br-pl').textContent=s>0?(pl>=0?'+':'')+`$${pl.toFixed(0)}`:'-';
  document.getElementById('br-pl').className=`stat-value ${pl>=0?'green':'red'}`;
  const pct=s>0?(pl/s*100):0;
  document.getElementById('br-pl-pct').textContent=s>0?(pct>=0?'+':'')+pct.toFixed(1)+'%':'-';
  document.getElementById('br-pl-pct').className=`stat-value ${pct>=0?'green':'red'}`;
}
document.getElementById('logModal').addEventListener('click',function(e){if(e.target===this)closeModal();});


// ==================== SOUND SYSTEM (Web Audio API) ====================
let audioCtx = null;
let soundEnabled = JSON.parse(localStorage.getItem('soundEnabled') || 'true');

function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playAlertSound(type) {
  return; // No sounds â€” alerts disabled
  if (!soundEnabled) return;
  const ctx = initAudio();
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  osc.connect(gain);
  gain.connect(ctx.destination);
  
  if (type === 'cold') {
    // Descending alert: urgent but not annoying
    osc.type = 'sine';
    osc.frequency.setValueAtTime(880, ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(440, ctx.currentTime + 0.15);
    osc.frequency.setValueAtTime(880, ctx.currentTime + 0.2);
    osc.frequency.exponentialRampToValueAtTime(440, ctx.currentTime + 0.35);
    gain.gain.setValueAtTime(0.3, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 0.5);
  } else if (type === 'hot3pt') {
    // Triple beep for 3PT
    osc.type = 'square';
    gain.gain.setValueAtTime(0, ctx.currentTime);
    for (let i = 0; i < 3; i++) {
      const t = ctx.currentTime + i * 0.15;
      osc.frequency.setValueAtTime(660, t);
      gain.gain.setValueAtTime(0.2, t);
      gain.gain.setValueAtTime(0, t + 0.08);
    }
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 0.5);
  } else if (type === 'combined') {
    // Epic alert for combined signals
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(440, ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(880, ctx.currentTime + 0.2);
    osc.frequency.setValueAtTime(440, ctx.currentTime + 0.25);
    osc.frequency.exponentialRampToValueAtTime(1100, ctx.currentTime + 0.45);
    gain.gain.setValueAtTime(0.2, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.6);
    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 0.6);
  }
}

function toggleSound() {
  soundEnabled = !soundEnabled;
  localStorage.setItem('soundEnabled', JSON.stringify(soundEnabled));
  const btn = document.getElementById('soundToggle');
  btn.classList.toggle('active', soundEnabled);
  btn.innerHTML = soundEnabled ? '&#x1F50A; Sound' : '&#x1F507; Muted';
  if (soundEnabled) playAlertSound('cold'); // test beep
}
// Favorites / Watchlist
function toggleFavorite(gameId) {
  const idx = state.favorites.indexOf(gameId);
  if (idx >= 0) state.favorites.splice(idx, 1);
  else state.favorites.push(gameId);
  localStorage.setItem('favorites', JSON.stringify(state.favorites));
  // Re-sort: move favorites to top
  const grid = document.getElementById('live-games-grid');
  const cards = [...grid.querySelectorAll('.game-card')];
  cards.sort((a,b) => {
    const aFav = state.favorites.includes(a.dataset.gameId) ? 0 : 1;
    const bFav = state.favorites.includes(b.dataset.gameId) ? 0 : 1;
    return aFav - bFav;
  });
  cards.forEach(c => grid.appendChild(c));
  // Toggle star icon
  const star = event.target;
  star.textContent = idx >= 0 ? '\u2606' : '\u2605';
}

// Signal History Dashboard
function renderSignalHistory() {
  const hist = state.signalHistory;
  if (!hist.length) return '<div style="text-align:center;padding:20px;color:var(--text-muted);">No signals recorded yet. Start auto-refresh during live games.</div>';
  const total = hist.length;
  const byType = {};
  hist.forEach(h => { (h.signals||[]).forEach(s => { byType[s] = (byType[s]||0) + 1; }); });
  const typeStats = Object.entries(byType).map(([k,v]) => `<span style="background:var(--accent-light);color:var(--accent);padding:2px 8px;border-radius:10px;font-size:11px;font-weight:600;">${k.toUpperCase()}: ${v}</span>`).join(' ');
  const recent = hist.slice(-10).reverse().map(h => 
    `<div style="display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid var(--border-light);font-size:11px;">` +
    `<span style="font-weight:600;">${h.game}</span>` +
    `<span style="color:var(--accent);font-weight:700;">BET ${h.betSide}</span>` +
    `<span>${h.signals.map(s=>s.toUpperCase()).join('+')}</span>` +
    `<span style="color:var(--text-muted);">${h.date}</span></div>`
  ).join('');
  return `<div style="margin-bottom:12px;"><div style="font-size:13px;font-weight:700;margin-bottom:6px;">Signal Summary</div><div style="font-size:22px;font-weight:800;color:var(--accent);">${total}</div><div style="font-size:10px;color:var(--text-muted);">Total signals recorded</div><div style="margin-top:8px;">${typeStats}</div></div><div style="font-size:13px;font-weight:700;margin-bottom:6px;">Recent Signals</div>${recent}`;
}

function toggleDarkMode() {
  const html = document.documentElement;
  const isDark = html.getAttribute('data-theme') === 'dark';
  html.setAttribute('data-theme', isDark ? '' : 'dark');
  localStorage.setItem('darkMode', isDark ? '' : 'dark');
  const btn = document.getElementById('darkModeToggle');
  btn.textContent = isDark ? 'ðŸŒ™ Dark' : 'â˜€ï¸ Light';
}
// Auto-load dark mode preference
(function() {
  const saved = localStorage.getItem('darkMode');
  if (saved === 'dark') {
    document.documentElement.setAttribute('data-theme', 'dark');
    setTimeout(() => { const btn = document.getElementById('darkModeToggle'); if(btn) btn.textContent = 'â˜€ï¸ Light'; }, 100);
  }
})();

// Init sound button state
document.addEventListener('DOMContentLoaded', function() {
    loadBankrollSettings();
    renderBetLog();
    updateBacktestPanel();
    updateKelly();
    renderStarDB();

  const btn = document.getElementById('soundToggle');
  if (btn) {
    btn.classList.toggle('active', soundEnabled);
    btn.innerHTML = soundEnabled ? '&#x1F50A; Sound' : '&#x1F507; Muted';
  }
});

// ==================== SCENARIO ALERT SYSTEM ====================
let activeAlerts = [];
let alertIdCounter = 0;
const ALERT_HISTORY = JSON.parse(localStorage.getItem('alertHistory') || '[]');

function showScenarioAlert(data) {
  // No popup alerts â€” signals show on chips and game cards only
  // Just save to history silently
  ALERT_HISTORY.unshift({ ...data, time: new Date().toISOString() });
  if (ALERT_HISTORY.length > 50) ALERT_HISTORY.length = 50;
  localStorage.setItem('alertHistory', JSON.stringify(ALERT_HISTORY));
}

function dismissAlert(id) {
  const el = document.getElementById(id);
  if (el) {
    el.style.animation = 'alertSlideIn 0.3s ease-in reverse';
    setTimeout(() => el.remove(), 300);
  }
  activeAlerts = activeAlerts.filter(a => a !== id);
}

// ==================== DEMO SIMULATION MODE ====================
// ==================== HOOK: FIRE SCENARIO ALERTS FROM LIVE DATA ====================
// Override the original signal detection to also trigger scenario alerts
const _origShowQuarterToast = showQuarterToast;
const _firedAlerts = new Set(); // prevent duplicate alerts per game refresh

function fireStarColdAlert(leader, star, gMins, per, clk, gLabel, paceRatio) {
  const alertKey = star.name + '_' + per + '_' + Math.floor(gMins);
  if (_firedAlerts.has(alertKey)) return;
  _firedAlerts.add(alertKey);
  // Clear old keys every 5 minutes
  setTimeout(() => _firedAlerts.delete(alertKey), 300000);
  
  const exp = getExpectedByTime(star.ppg, gMins);
  showScenarioAlert({
    player: leader.name,
    team: star.team,
    game: gLabel,
    quarter: per,
    clock: clk,
    currentPts: leader.pts,
    expectedPts: exp,
    ppg: star.ppg,
    pacePercent: paceRatio * 100,
    type: 'cold',
    signals: ['Star at ' + (paceRatio * 100).toFixed(0) + '% pace', 'Below 60% threshold']
  });
}

function fire3PTAlert(teamAbbr, pct, made, att, gLabel, per, clk) {
  const alertKey = teamAbbr + '_3pt_' + per;
  if (_firedAlerts.has(alertKey)) return;
  _firedAlerts.add(alertKey);
  setTimeout(() => _firedAlerts.delete(alertKey), 300000);
  
  showScenarioAlert({
    player: teamAbbr + ' Team',
    team: teamAbbr + ' shooting unsustainably hot',
    game: gLabel,
    quarter: per,
    clock: clk,
    currentPts: parseFloat(pct),
    expectedPts: getLeague3PtAvg(),
    ppg: getLeague3PtAvg(),
    pacePercent: (parseFloat(pct) / getLeague3PtAvg()) * 100,
    type: 'hot3pt',
    signals: [teamAbbr + ' at ' + pct + '% from 3 (' + made + '/' + att + ')']
  });

    // Ensure star DB renders on page load
    renderStarDB();

}

</script>
<script>try { renderStarDB(); } catch(e) {}</script>
<script>
// Sync 3PT stats from original IDs to signal strip duplicates
(function() {
  var pairs = [];
  function syncStats() {
    pairs.forEach(function(p) {
      var src = document.getElementById(p[0]);
      var dst = document.getElementById(p[1]);
      if (src && dst && dst.textContent !== src.textContent) {
        dst.textContent = src.textContent;
        // Copy color class
        dst.className = dst.className.replace(/ ?(orange|red|purple|green|teal)/g, '');
        if (src.classList.contains('orange')) dst.classList.add('orange');
        if (src.classList.contains('red')) dst.classList.add('red');
        if (src.classList.contains('purple')) dst.classList.add('purple');
        if (src.classList.contains('teal')) dst.classList.add('teal');
      }
    });
  }
  setInterval(syncStats, 2000);
  setTimeout(syncStats, 1000);
})();
</script>
<script>
// Pre-compute odds API URL for historical odds
try {
  var _s = fetchLiveOdds.toString();
  var _k = _s.match(/[a-f0-9]{32}/);
  if (_k) {
    var _sp = (typeof getOddsSport === 'function') ? getOddsSport() : 'basketball_nba';
    window.__ODDS_BASE_URL = 'https://api.the-odds-api.com/v4/sports/' + _sp + '/odds?apiK' + 'ey=' + _k[0] + '&regions=us&markets=h2h&oddsFormat=american&bookmakers=fanduel,draftkings,betmgm';
  }
} catch(e) {}
</script>
<script>
// ==================== ODDS HISTORY TRACKER (API-BASED) ====================
(function() {
  var OH_CACHE_KEY = 'oddsHistoryCache';
  var CACHE_TTL = 1800000; // 30 min cache

  // Intercept the live odds fetch to capture the base URL with API key
  var capturedBaseURL = window.__ODDS_BASE_URL || null;

    // Extract API URL from fetchLiveOdds source code
    try {
      if (typeof fetchLiveOdds === 'function') {
        var src = fetchLiveOdds.toString();
        var hexMatch = src.match(/[a-f0-9]{32}/);
        if (hexMatch) {
          var sport = (typeof getOddsSport === 'function') ? getOddsSport() : 'basketball_nba';
          capturedBaseURL = 'https://api.the-odds-api.com/v4/sports/' + sport + '/odds?apiKey=' + hexMatch[0] + '&regions=us&markets=h2h&oddsFormat=american&bookmakers=fanduel,draftkings,betmgm';
        }
      }
    } catch(e) {}

    // Also wrap fetch calls to capture URL at runtime as backup
    function _wrapFetchForCapture(orig) {
      return function(url) {
        if (typeof url === 'string' && url.indexOf('the-odds-api') > -1 && url.indexOf('v4/sports') > -1) {
          capturedBaseURL = url;
        }
        return orig.apply(this, arguments);
      };
    }
    if (window._origFetchReal) { window._origFetchReal = _wrapFetchForCapture(window._origFetchReal); }
    window.fetch = _wrapFetchForCapture(window.fetch);
    var _realFetch = window._origFetchReal || window.fetch;

    function buildHistoricalURL(dateISO) {
    if (!capturedBaseURL) return null;
    // Change /v4/sports/ to /v4/historical/sports/ and add date param
    var histURL = capturedBaseURL.replace('/v4/sports/', '/v4/historical/sports/');
    histURL += '&date=' + encodeURIComponent(dateISO);
    return histURL;
  }

  // Fetch 24h of historical odds (1 per hour)
  async function fetchOddsHistory(eventId, awayName, homeName) {
    var cacheKey = OH_CACHE_KEY + '_' + eventId;
    var cached = null;
    try { cached = JSON.parse(localStorage.getItem(cacheKey)); } catch(e) {}
    if (cached && (Date.now() - cached.ts) < CACHE_TTL) {
      return cached.data;
    }

    if (!capturedBaseURL) {
      // Try to trigger a fetch first
      if (typeof fetchLiveOdds === 'function') {
        try { await fetchLiveOdds(); } catch(e) {}
        await new Promise(function(r) { setTimeout(r, 2000); });
      }
      if (!capturedBaseURL) return [];
    }

    var points = [];
    var now = new Date();
    // Fetch every 3 hours for last 24h = 8 API calls (saves credits)
    var intervals = [0, 3, 6, 9, 12, 15, 18, 21, 24];
    
    for (var i = intervals.length - 1; i >= 0; i--) {
      var hrs = intervals[i];
      if (hrs === 0) continue; // skip current (we already have live)
      var d = new Date(now.getTime() - hrs * 3600000);
      var iso = d.toISOString().replace(/\.\d+Z/, 'Z');
      var url = buildHistoricalURL(iso);
      if (!url) continue;
      
      try {
        var resp = await _realFetch(url);
        if (!resp.ok) continue;
        var json = await resp.json();
        var data = json.data || json;
        if (!Array.isArray(data)) continue;
        
        // Find the matching event
        for (var j = 0; j < data.length; j++) {
          var ev = data[j];
          var matchesEvent = ev.id === eventId;
          var matchesTeam = false;
          if (!matchesEvent && ev.home_team && ev.away_team) {
            var ht = ev.home_team.toLowerCase();
            var at = ev.away_team.toLowerCase();
            matchesTeam = ht.includes(homeName.toLowerCase().substring(0,4)) ||
                          at.includes(awayName.toLowerCase().substring(0,4));
          }
          if (matchesEvent || matchesTeam) {
            var bk = ev.bookmakers && ev.bookmakers[0];
            if (bk && bk.markets) {
              var mkt = bk.markets.find(function(m) { return m.key === 'h2h'; });
              if (mkt && mkt.outcomes) {
                var awayOdds = null, homeOdds = null;
                mkt.outcomes.forEach(function(o) {
                  if (o.name === ev.away_team) awayOdds = o.price;
                  if (o.name === ev.home_team) homeOdds = o.price;
                });
                points.push({
                  t: d.getTime(),
                  a: awayOdds,
                  h: homeOdds,
                  src: bk.title || bk.key
                });
              }
            }
            break;
          }
        }
      } catch(e) {
        console.log('[Alpha Hunter] Historical fetch error for -' + hrs + 'h:', e.message);
      }
    }

    // Add current odds from oddsCache if available
    if (typeof oddsCache !== 'undefined') {
      var keys = Object.keys(oddsCache);
      for (var k = 0; k < keys.length; k++) {
        var ck = keys[k];
        if (ck.toLowerCase().includes(homeName.toLowerCase().substring(0,4)) ||
            ck.toLowerCase().includes(awayName.toLowerCase().substring(0,4))) {
          var co = oddsCache[ck];
          if (co && co.h2h) {
            points.push({ t: now.getTime(), a: co.h2h.away, h: co.h2h.home, src: 'Live' });
          }
          break;
        }
      }
    }

    // Sort by time
    points.sort(function(a, b) { return a.t - b.t; });

    // Cache
    try {
      if (points.length > 0) localStorage.setItem(cacheKey, JSON.stringify({ ts: Date.now(), data: points }));
    } catch(e) {}

    return points;
  }

  // Format ML odds
  function fmtML(val) {
    if (val === undefined || val === null) return '-';
    var n = parseFloat(val);
    return n > 0 ? '+' + n : '' + n;
  }

  function fmtTime(ts) {
    var d = new Date(ts);
    var h = d.getHours();
    var ampm = h >= 12 ? 'p' : 'a';
    h = h % 12 || 12;
    return h + ampm;
  }

  function buildOddsHistoryHTML(points, awayName, homeName) {
    if (!points || points.length === 0) {
      return '<div style="padding:16px;color:#9ca3af;font-size:13px;text-align:center;">No historical data available. Click Refresh first to load games.</div>';
    }

    var rows = '';
    var prevA = null, prevH = null;
    points.forEach(function(p) {
      var timeStr = fmtTime(p.t);
      var awayML = fmtML(p.a);
      var homeML = fmtML(p.h);

      // Arrow indicators for movement
      var aDelta = prevA !== null && p.a !== null ? (p.a > prevA ? ' \u2191' : p.a < prevA ? ' \u2193' : '') : '';
      var hDelta = prevH !== null && p.h !== null ? (p.h > prevH ? ' \u2191' : p.h < prevH ? ' \u2193' : '') : '';
      var aColor = p.a > 0 ? '#dc2626' : '#059669';
      var hColor = p.h > 0 ? '#dc2626' : '#059669';

      rows += '<tr style="border-bottom:1px solid #f3f4f6;">' +
        '<td style="padding:5px 10px;font-size:11px;color:#6b7280;white-space:nowrap;">' + timeStr + '</td>' +
        '<td style="padding:5px 10px;font-size:13px;font-weight:700;color:' + aColor + ';text-align:right;font-variant-numeric:tabular-nums;">' + awayML + '<span style="font-size:10px;">' + aDelta + '</span></td>' +
        '<td style="padding:5px 10px;font-size:13px;font-weight:700;color:' + hColor + ';text-align:right;font-variant-numeric:tabular-nums;">' + homeML + '<span style="font-size:10px;">' + hDelta + '</span></td>' +
        '<td style="padding:5px 10px;font-size:10px;color:#9ca3af;">' + (p.src || '') + '</td></tr>';

      prevA = p.a; prevH = p.h;
    });

    // Show movement summary
    var first = points[0], last = points[points.length - 1];
    var aMoved = first.a && last.a ? (last.a - first.a) : 0;
    var hMoved = first.h && last.h ? (last.h - first.h) : 0;
    var summary = '<div style="display:flex;gap:16px;padding:8px 12px;background:#f8fafc;font-size:11px;color:#4b5563;">' +
      '<span><b>' + (awayName || 'Away') + '</b> moved ' + (aMoved > 0 ? '+' : '') + aMoved + '</span>' +
      '<span><b>' + (homeName || 'Home') + '</b> moved ' + (hMoved > 0 ? '+' : '') + hMoved + '</span>' +
      '<span style="margin-left:auto;color:#9ca3af;">' + points.length + ' snapshots</span></div>';

    return summary +
      '<div style="max-height:260px;overflow-y:auto;">' +
      '<table style="width:100%;border-collapse:collapse;font-family:Inter,sans-serif;">' +
      '<thead><tr style="background:#f8fafc;position:sticky;top:0;">' +
      '<th style="padding:5px 10px;font-size:9px;color:#9ca3af;text-align:left;font-weight:700;text-transform:uppercase;">Time</th>' +
      '<th style="padding:5px 10px;font-size:9px;color:#9ca3af;text-align:right;font-weight:700;text-transform:uppercase;">' + (awayName || 'Away') + '</th>' +
      '<th style="padding:5px 10px;font-size:9px;color:#9ca3af;text-align:right;font-weight:700;text-transform:uppercase;">' + (homeName || 'Home') + '</th>' +
      '<th style="padding:5px 10px;font-size:9px;color:#9ca3af;font-weight:700;text-transform:uppercase;">Book</th>' +
      '</tr></thead><tbody>' + rows + '</tbody></table></div>';
  }

  // Toggle odds history panel
  window.toggleOddsHistory = async function(btn, matchKey, awayName, homeName) {
    var card = btn.closest('.game-card') || btn.parentElement.parentElement;
    var existing = card.querySelector('.odds-history-panel');
    if (existing) {
      existing.remove();
      btn.textContent = '24h Odds';
      btn.style.background = '#f0f4ff';
      return;
    }

    btn.textContent = 'Loading...';
    btn.style.background = '#dbeafe';

    var points = await fetchOddsHistory(matchKey, awayName, homeName);

    var panel = document.createElement('div');
    panel.className = 'odds-history-panel';
    panel.style.cssText = 'margin-top:8px;border:1px solid #e5e7eb;border-radius:10px;background:#fff;overflow:hidden;box-shadow:0 2px 8px rgba(0,0,0,0.04);';
    panel.innerHTML = '<div style="padding:10px 14px;background:linear-gradient(135deg,#f8fafc,#f0f4ff);border-bottom:1px solid #e5e7eb;font-size:12px;font-weight:700;color:#1e3a5f;display:flex;align-items:center;gap:6px;">ML Movement (24h) <span style="font-size:10px;color:#9ca3af;font-weight:500;">via Historical API</span></div>' +
      buildOddsHistoryHTML(points, awayName, homeName);
    card.appendChild(panel);
    btn.textContent = 'Hide';
  };

  // Inject buttons into game cards
  function injectOddsButtons() {
    var cards = document.querySelectorAll('.game-card');
    cards.forEach(function(card) {
      if (card.querySelector('.odds-hist-btn')) return;
      var teams = card.querySelectorAll('.team-name');
      var teamTexts = [];
      teams.forEach(function(t) { if (t.textContent.trim()) teamTexts.push(t.textContent.trim()); });
      var awayName = teamTexts[0] || 'Away';
      var homeName = teamTexts[1] || teamTexts[teamTexts.length-1] || 'Home';
      var matchKey = '';
      if (typeof oddsCache !== 'undefined') {
        var cacheKeys = Object.keys(oddsCache);
        for (var i = 0; i < cacheKeys.length; i++) {
          var k = cacheKeys[i];
          for (var j = 0; j < teamTexts.length; j++) {
            if (k.toLowerCase().indexOf(teamTexts[j].toLowerCase().substring(0,4)) > -1) {
              matchKey = k; break;
            }
          }
          if (matchKey) break;
        }
      }
      if (!matchKey) matchKey = awayName + ' vs ' + homeName;

      var btn = document.createElement('button');
      btn.className = 'odds-hist-btn';
      btn.textContent = '24h Odds';
      btn.style.cssText = 'margin:6px 8px;padding:5px 14px;font-size:11px;font-weight:700;border:1px solid #1e3a5f;color:#1e3a5f;background:#f0f4ff;border-radius:20px;cursor:pointer;transition:all 0.2s;';
      btn.onmouseover = function() { this.style.background='#dbeafe'; };
      btn.onmouseout = function() { if(this.textContent!=='Hide') this.style.background='#f0f4ff'; };
      btn.onclick = function() { toggleOddsHistory(this, matchKey, awayName, homeName); };
      var cardBody = card.querySelector('.game-card-body') || card;
      cardBody.appendChild(btn);
    });
  }

  var container = document.getElementById('edgeThesisContainer');
  if (container) {
    new MutationObserver(function() { setTimeout(injectOddsButtons, 500); })
      .observe(container, { childList: true, subtree: true });
  }
  setInterval(injectOddsButtons, 5000);
  setTimeout(injectOddsButtons, 2000);
})();
</script>
<div id="content-history" class="tab-content">
  <div class="card">
    <div class="card-header"><span>ðŸ“Š Signal History Dashboard</span>
      <button class="btn btn-sm" onclick="document.getElementById('historyContent').innerHTML=renderSignalHistory()">Refresh</button>
      <button class="btn btn-sm btn-red" onclick="if(confirm('Clear all signal history?')){state.signalHistory=[];localStorage.removeItem('signalHistory');document.getElementById('historyContent').innerHTML=renderSignalHistory();}">Clear</button>
    </div>
    <div class="card-body" id="historyContent">
      <div style="text-align:center;padding:20px;color:var(--text-muted);">Click Refresh to load signal history.</div>
    </div>
  </div>
</div>

<div id="content-guide" class="tab-content">
<div class="guide-section">
<h2 style="font-size:22px;font-weight:700;margin-bottom:4px">Signal Guide</h2>

<!-- ===== QUICK START - HOW TO USE ===== -->
<div style="background:linear-gradient(135deg, var(--accent-light), var(--purple-light));border:2px solid var(--accent);border-radius:var(--radius);padding:20px;margin:16px 0 24px;">
<h3 style="font-size:16px;font-weight:800;margin-bottom:12px;">ðŸŽ¯ How This Works (Quick Start)</h3>
<div style="font-size:13px;line-height:1.7;color:var(--text-primary);">
<p style="margin-bottom:10px;"><strong>The idea is simple:</strong> Sometimes a team is winning because of things that won't last â€” like making every 3-pointer, or getting way more free throws than normal. When that happens, the live betting odds are wrong because they think the score is "real." We catch that.</p>
<p style="margin-bottom:14px;"><strong>How to use it:</strong></p>
<div style="display:grid;grid-template-columns:1fr;gap:10px;">
<div style="background:var(--card-bg);border-radius:var(--radius-sm);padding:12px 14px;border-left:3px solid var(--accent);">
<strong style="font-size:12px;">Step 1:</strong> <span style="font-size:13px;">Hit <strong>Start</strong> to auto-refresh. The dashboard watches every live game.</span>
</div>
<div style="background:var(--card-bg);border-radius:var(--radius-sm);padding:12px 14px;border-left:3px solid var(--orange);">
<strong style="font-size:12px;">Step 2:</strong> <span style="font-size:13px;">When a signal fires, the chip turns on and shows a number. <strong>Click it</strong> to see which game, then <strong>click the game</strong> to jump to it.</span>
</div>
<div style="background:var(--card-bg);border-radius:var(--radius-sm);padding:12px 14px;border-left:3px solid var(--green);">
<strong style="font-size:12px;">Step 3:</strong> <span style="font-size:13px;">The game card tells you <strong>who to bet on</strong> and <strong>why</strong>. Green = bet this team's moneyline. Purple = bet Over or Under.</span>
</div>
</div>
</div>
</div>

<!-- ===== WHAT EACH SIGNAL MEANS (PLAIN ENGLISH) ===== -->
<div style="background:var(--card-bg);border:1px solid var(--border);border-radius:var(--radius);padding:20px;margin-bottom:24px;">
<h3 style="font-size:15px;font-weight:800;margin-bottom:14px;">ðŸ“‹ What Each Signal Means</h3>
<table style="width:100%;font-size:12px;border-collapse:collapse;">
<thead><tr style="border-bottom:2px solid var(--border);text-align:left;">
<th style="padding:8px 6px;font-weight:700;color:var(--text-muted);font-size:10px;text-transform:uppercase;">Signal</th>
<th style="padding:8px 6px;font-weight:700;color:var(--text-muted);font-size:10px;text-transform:uppercase;">In Plain English</th>
<th style="padding:8px 6px;font-weight:700;color:var(--text-muted);font-size:10px;text-transform:uppercase;">What to Bet</th>
</tr></thead>
<tbody>
<tr style="border-bottom:1px solid var(--border-light);">
<td style="padding:10px 6px;"><span class="signal-badge badge-3pt" style="font-size:10px;">3PT FRAGILE</span></td>
<td style="padding:10px 6px;color:var(--text-secondary);line-height:1.5;">A team is <strong>way too hot from 3</strong> (50%+) and their entire lead depends on it. That shooting will cool off â†’ lead will shrink.</td>
<td style="padding:10px 6px;font-weight:700;color:var(--green);">Bet the <strong>other team's moneyline</strong> (the one behind). Their opponent's lead is fake.</td>
</tr>
<tr style="border-bottom:1px solid var(--border-light);">
<td style="padding:10px 6px;"><span class="signal-badge badge-star" style="font-size:10px;">STAR COLD</span></td>
<td style="padding:10px 6px;color:var(--text-secondary);line-height:1.5;">A star player (25+ PPG) is having a cold game â€” way below their normal pace. Stars <strong>almost always bounce back</strong>.</td>
<td style="padding:10px 6px;font-weight:700;color:var(--green);">Bet the <strong>star's team moneyline</strong>. They're undervalued because their best player is cold right now.</td>
</tr>
<tr style="border-bottom:1px solid var(--border-light);">
<td style="padding:10px 6px;"><span class="signal-badge badge-ft" style="font-size:10px;">FT</span></td>
<td style="padding:10px 6px;color:var(--text-secondary);line-height:1.5;">The leading team has <strong>way more free throws</strong> (10+ more FTA). Refs tend to even out the calls â€” that FT advantage won't last.</td>
<td style="padding:10px 6px;font-weight:700;color:var(--green);">Bet the <strong>trailing team's moneyline</strong>. Part of the lead is built on ref luck.</td>
</tr>
<tr style="border-bottom:1px solid var(--border-light);">
<td style="padding:10px 6px;"><span class="signal-badge badge-combined" style="font-size:10px;">COMBINED</span></td>
<td style="padding:10px 6px;color:var(--text-secondary);line-height:1.5;"><strong>2+ signals firing on the same game.</strong> Multiple things are unsustainable at once â€” strongest edge.</td>
<td style="padding:10px 6px;font-weight:700;color:var(--green);">Same as the individual signals â€” bet the team that benefits when things regress. <strong>Highest confidence.</strong></td>
</tr>
</tbody>
</table>
</div>

<div id="nba-guide">
<p class="guide-intro" style="margin-bottom:12px;"><strong>Core thesis:</strong> The current score was built on something unsustainable, so the live odds are mispriced. We bet on regression.</p>
<div class="guide-grid">
<div class="guide-card"><h3><span class="signal-badge badge-3pt">3PT FRAGILE</span> 3PT Fragile Lead</h3><p class="edge-label">Team is winning because of hot 3PT shooting â€” and the lead depends on it</p><p>Fires when BOTH are true: (1) a team is shooting 50%+ from 3 on 12+ attempts, AND (2) their lead is built on that 3PT shooting while the opponent scores from paint. When the shooting cools off (and it will), the lead shrinks fast.</p><div class="threshold">Trigger: 50%+ on 12+ att AND lead 42%+ from 3PT AND opponent 58%+ non-3PT.</div></div>
<div class="guide-card"><h3><span class="signal-badge badge-star">STAR</span> Star Cold</h3><p class="edge-label">A star player is way below their normal scoring pace â€” they'll bounce back</p><p>When a 25+ PPG star has scored way less than expected through Q2-Q3, history says they heat up. The market undervalues their team while the star is cold. That's the buy window.</p><div class="threshold">Trigger: Star at &lt;60% of expected scoring pace, at least 20% of game elapsed.</div></div>
<div class="guide-card"><h3><span class="signal-badge badge-ft">FT</span> FT Inflation</h3><p class="edge-label">Leading team got way more free throws than the other team â€” refs will even out</p><p>If Team A has 10+ more free throw attempts than Team B, part of that lead is from unsustainable ref treatment. Refs tend to balance calls â€” the FT advantage will shrink.</p><div class="threshold">Trigger: Leading team has 10+ more FTA than trailing team.</div></div>
<div class="guide-card"><h3><span class="signal-badge badge-combined">COMBINED</span> Combined Edge</h3><p class="edge-label">2+ signals firing on the same game = strongest edge, most confidence</p><p>When multiple signals agree on the same game, the live odds are wrong from multiple angles. Each signal catches something different â€” so when 2+ fire together, the mispricing is larger.</p><div class="threshold">Trigger: 2+ of {3PT Fragile, Star Cold, FT Inflation} on same game.</div></div>

</div></div>
<div id="theory-panel" class="theory-panel">
  <h4>How This Dashboard Works</h4>
  <p>Every signal in this dashboard shares one thesis: <strong>the current score was built on something unsustainable, so the live moneyline is mispriced.</strong> Live odds react to the scoreboard, but they fail to distinguish between sustainable scoring (paint, mid-range) and unsustainable scoring (hot 3PT streaks, FT inflation). The 3-signal system (3PT Fragile, Star Cold, FT Inflation) plus Combined Edge identifies when these unsustainable conditions exist â€” that is the edge.</p>
  <hr class="signal-divider">
  <h4>1. 3PT Fragile Lead (Merged Signal)</h4>
  <p><strong>What it detects:</strong> This is the most selective signal â€” it requires BOTH of two conditions to be true simultaneously:</p>
  <p><strong>Condition 1 â€” Hot 3PT Shooting:</strong> A team shooting 50%+ from three-point range on 12+ attempts (or 55%+ on 8+). The NBA league average is ~36.5%. This rate is 2+ standard deviations above the mean and will regress.</p>
  <p><strong>Condition 2 â€” Fragile Lead Composition:</strong> The same team's lead is 42%+ dependent on 3PT scoring AND the trailing team scores from the paint (58%+ non-3PT). The lead is not just hot â€” it's structurally dependent on that hot shooting.</p>
  <p><strong>Why both conditions matter:</strong> Hot 3PT shooting alone doesn't mean the lead is fragile â€” the team might also be scoring from the paint. And a fragile lead composition alone doesn't mean the shooting will regress â€” the percentage might be within normal range. Only when BOTH are true is the edge genuine: the shooting WILL cool off AND the lead DEPENDS on it.</p>
  <div class="edge-box">
    <p><strong>Trigger:</strong> 3PT% &ge;50% on &ge;12 attempts (or 55%+ on 8+) AND lead composition &ge;42% from 3PT AND opponent &ge;58% non-3PT AND &ge;20 total points. All conditions must be met for Level 2 (strong) signal.</p>
  </div>
  <p><strong>When only one condition is met:</strong> If only the 3PT shooting is hot (no fragile lead) or only the lead is fragile (shooting not extreme), the system shows a Level 1 warning but does NOT fire the full signal. This eliminates false positives from the old system where 3PT and Fragile were counted as separate signals despite measuring the same underlying phenomenon.</p>
  <hr class="signal-divider">
  <h4>2. Star Player Cold / Below Pace</h4>
  <p><strong>What it detects:</strong> A franchise-caliber player performing well below their expected scoring pace early in the game (Q1-Q3 for NBA). The system tracks each team's leading scorer and compares their actual output to their per-minute expected production.</p>
  <p><strong>Why it is an edge:</strong> Star players regress <em>upward</em>. A player averaging 28 PPG who has 6 points through two quarters is not suddenly a bad player â€” they are having an off stretch that will likely correct. If their team is losing partly because their star is cold, the market is undervaluing that team's true offensive potential.</p>
  <div class="edge-box green">
    <p><strong>Trigger:</strong> Star's actual production &lt;60% of expected pace AND Q3 or earlier. The system calculates expected output using per-minute projections from season averages. Example: A 30 PPG scorer expected to have 20 pts by halftime who only has 8 â€” that gap will likely close.</p>
  </div>
  <hr class="signal-divider">
  <h4>3. FT Inflation</h4>
  <p><strong>What it detects:</strong> When the leading team has significantly more free throw attempts than the trailing team, indicating their lead is partly built on unsustainable FT volume.</p>
  <p><strong>Why it is an edge:</strong> A large FTA gap means the leading team is getting to the line at an abnormal rate. Free throw rates regress within a game &mdash; referees tend to even out calls. The FT-inflated portion of the lead is not built on genuine offensive superiority.</p>
  <div class="edge-box red">
    <p><strong>Trigger:</strong> Leading team has 10+ more FTA than the trailing team. FTA data is fetched from ESPN's summary endpoint (same source used for box score stats).</p>
  </div>
  <hr class="signal-divider">
  <h4>4. Combined Edge</h4>
  <p><strong>What it detects:</strong> When 2+ of the 3 independent signals (3PT Fragile, Star Cold, FT Inflation) fire on the same game. Each signal measures a genuinely different dimension of unsustainability â€” no overlap or double-counting.</p>
  <div class="edge-box purple">
    <p><strong>How stacking works:</strong> The system checks for Level 2 signals across all 3 types. Any 2+ active signals elevates the thesis to signalLevel = 2 (strong combined).</p>
    <p style="margin-top:6px"><strong>Strongest combos:</strong></p>
    <p style="margin-top:4px"><strong>3PT Fragile + Star Cold:</strong> Opponent's lead is built on hot 3PT shooting AND their star is cold. When the star heats up and 3PT% drops, momentum shifts hard.</p>
    <p style="margin-top:4px"><strong>3PT Fragile + FT Inflation:</strong> Lead is both 3PT-dependent AND FT-inflated. Two genuinely independent unsustainable foundations.</p>
    <p style="margin-top:4px"><strong>Star Cold + FT Inflation:</strong> Star underperforming AND opponent lead inflated by FTs. Both forces favor the trailing team.</p>
  </div>
  <hr class="signal-divider">
  <h4>Bet Side Logic (ML Signals)</h4>
  <p>The system scores each side's "unsustainability count." Away has 3PT Fragile lead = awayFade++. Away lead FT-inflated = awayFade++. Star cold on a team = bet ON that team (star regresses upward = fade the other side). The side with more fade reasons gets faded; the system recommends the opposite side â€” the team whose advantages are real, sustainable, and undervalued.</p>
  <hr class="signal-divider">
  <h4>Data Sources &amp; Limitations</h4>
  <p>All data comes from ESPN's live scoreboard API (scores, period/clock, team stats, leader boards) and ESPN's summary endpoint (FTA, box score details). Refreshes on configurable interval (default 30s).</p>
  <p><strong>Not captured:</strong> Individual player foul counts, play-by-play data, lineup changes, injury updates, referee tendencies, pace-of-play, and real-time odds. The system focuses on what IS measurable and predictive: shooting rates, scoring composition, free throw attempts, and star production.</p>
  <p><strong>Important:</strong> No signal guarantees an outcome. These are probabilistic edges based on mean reversion and market inefficiency. Responsible bankroll management is essential.</p>
</div>

</body>
</html>


    
